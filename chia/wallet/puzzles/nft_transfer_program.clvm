(mod (METADATA CURRY_PARAMS SINGLETON_STRUCT current_owner my_did_inner_hash new_did new_did_inner_hash solution)
    ; METADATA and CURRY_PARAMS are not actually curried into the mod hash but are curried into the NFT layer and passed in
    ; This effectively achieves the same result - fixing the values - but means that the transfer program mod never changes
    ; CURRY_PARAMS are: (ROYALTY_ADDRESS TRADE_PRICE_PERCENTAGE SETTLEMENT_MOD_HASH CAT_MOD_HASH)

    ; SINGLETON_STRUCT is ((SINGLETON_MOD_HASH, (SINGLETON_LAUNCHER_ID, LAUNCHER_PUZZLE_HASH)))

    ; For this transfer program solution is (trade_prices_list new_url)

    (include condition_codes.clvm)
    (include curry-and-treehash.clinc)
    (defconstant HUNDRED 100)

    ; trade_prices_list is a list of (amount type) pairs
    ; type 0 is standard chia
    ; any other type is a bytes32 mod hash of a launcher

    (defun-inline cat_settlement_puzzle_hash (CAT_MOD_HASH tail_hash SETTLEMENT_MOD_HASH)
      (puzzle-hash-of-curried-function CAT_MOD_HASH
                                       SETTLEMENT_MOD_HASH
                                       (sha256 ONE tail_hash)
                                       (sha256 ONE CAT_MOD_HASH)
      )
    )

    ;; return the full puzzlehash for a singleton with the innerpuzzle curried in
    ; puzzle-hash-of-curried-function is imported from curry-and-treehash.clinc
    (defun-inline calculate_full_puzzle_hash (SINGLETON_STRUCT inner_puzzle_hash)
       (puzzle-hash-of-curried-function (f SINGLETON_STRUCT)
                                        inner_puzzle_hash
                                        (sha256tree1 SINGLETON_STRUCT)
       )
    )

    (defun round_down_to_even (value)
      (if (logand value ONE) (- value ONE) value)
    )

    (defun-inline calculate_percentage (amount percentage)
      (f (divmod (* amount percentage) HUNDRED))
    )

    (defun sha256tree1 (TREE)
          (if (l TREE)
              (sha256 2 (sha256tree1 (f TREE)) (sha256tree1 (r TREE)))
              (sha256 ONE TREE)
          )
    )

    ; Loop of the trade prices list and either assert a puzzle announcement or generate xch
    (defun parse_trade_prices_list ((ROYALTY_ADDRESS TRADE_PRICE_PERCENTAGE SETTLEMENT_MOD_HASH CAT_MOD_HASH) trade_prices_list my_nft_id)
      (if trade_prices_list
        (c
          (if (r (f trade_prices_list))
              (list ASSERT_PUZZLE_ANNOUNCEMENT (sha256 (cat_settlement_puzzle_hash CAT_MOD_HASH (f (r (f trade_prices_list))) SETTLEMENT_MOD_HASH) (sha256tree1 (c my_nft_id (list (list ROYALTY_ADDRESS (calculate_percentage (f (f trade_prices_list)) TRADE_PRICE_PERCENTAGE)))))))
              (list CREATE_COIN ROYALTY_ADDRESS (round_down_to_even (calculate_percentage (f (f trade_prices_list)) TRADE_PRICE_PERCENTAGE)))
          )
          (parse_trade_prices_list (list ROYALTY_ADDRESS TRADE_PRICE_PERCENTAGE SETTLEMENT_MOD_HASH CAT_MOD_HASH) (r trade_prices_list) my_nft_id)
        )
        ()
      )
    )

    ; if we are part of a complex trade then we assert an announcement from the recipient of the trade_price and then parse the trade price list
    (defun generate_conditions_for_trade (
      SINGLETON_STRUCT
      CURRENT_OWNER_DID
      CURRY_PARAMS
      my_did_inner_hash
      new_did
      new_did_inner_hash
      trade_prices_list
      trade_prices_list_hash
    )
    (c (list CREATE_PUZZLE_ANNOUNCEMENT trade_prices_list_hash new_did)
      (c (list ASSERT_PUZZLE_ANNOUNCEMENT (sha256 (calculate_full_puzzle_hash (c (f SINGLETON_STRUCT) (c new_did (r (r SINGLETON_STRUCT)))) new_did_inner_hash) trade_prices_list_hash (f (r SINGLETON_STRUCT))))
        (parse_trade_prices_list CURRY_PARAMS trade_prices_list (f (r SINGLETON_STRUCT)))
      )
    )
  )

  ; once we find 'u' we don't need to continue looping
    (defun add_url (METADATA new_url)
      (if METADATA
        (if (= (f (f METADATA)) 'u')
          (c (c 'u' (c new_url (r (f METADATA)))) (r METADATA))
          (c (f METADATA) (add_url (r METADATA) new_url))
        )
        ()
      )
    )

    (defun check_if_add_url (METADATA CURRY_PARAMS solution output)
      (if solution
        (c (list -22 (add_url METADATA solution) CURRY_PARAMS) output)
        output
      )
    )

    (defun check_if_gift (
      SINGLETON_STRUCT
      CURRENT_OWNER_DID
      CURRY_PARAMS
      my_did_inner_hash
      new_did
      new_did_inner_hash
      trade_prices_list
      )
      (if trade_prices_list
        (generate_conditions_for_trade
          SINGLETON_STRUCT
          CURRENT_OWNER_DID
          CURRY_PARAMS
          my_did_inner_hash
          new_did
          new_did_inner_hash
          trade_prices_list
          (sha256tree1 trade_prices_list)
        )
        (list (list CREATE_PUZZLE_ANNOUNCEMENT 0))
      )
    )

    ; main
    (check_if_add_url
      METADATA
      CURRY_PARAMS
      (f (r solution))
      (check_if_gift
        SINGLETON_STRUCT
        current_owner
        CURRY_PARAMS
        my_did_inner_hash
        new_did
        new_did_inner_hash
        (f solution)
      )
    )
)
