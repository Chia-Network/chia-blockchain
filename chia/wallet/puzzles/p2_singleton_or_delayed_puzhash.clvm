(mod (SINGLETON_MOD_HASH LAUNCHER_ID LAUNCHER_PUZZLE_HASH SECONDS_DELAY DELAYED_PUZZLE_HASH delayed_puzzle_reveal p1 p2)

  ;; This puzzle has two escape conditions: the regular "claim via singleton", and the
  ;; delayed "claim via puzzle hash", delayed by a fixed number of seconds.

  ; SINGLETON_MOD_HASH is the mod-hash for the singleton_top_layer puzzle
  ; LAUNCHER_ID is the ID of the singleton we are commited to paying to
  ; LAUNCHER_PUZZLE_HASH is the puzzle hash of the launcher
  ; SECONDS_DELAY is the number of seconds before the coin can be spent with `DELAYED_PUZZLE_HASH`
  ; DELAYED_PUZZLE_HASH is the puzzle hash of the delayed puzzle
  ; delayed_puzzle_reveal is 0 for the "claim via singleton" case or the delayed puzzle reveal for the delay case
  ; p1 and p2 are parameters whose meaning changes depending upon which case we're using
    ; if we are paying to singleton then p1 is singleton_inner_puzzle_hash, and p2 is my_id
    ; if we are running the delayed case then p1 is the solution for delayed puzzle

  (include condition_codes.clvm)
  (include curry-and-treehash.clinc)

  ; takes a lisp tree and returns the hash of it
  (defun sha256tree (TREE)
      (if (l TREE)
          (sha256 2 (sha256tree (f TREE)) (sha256tree (r TREE)))
          (sha256 1 TREE)
      )
  )

  ;; return the full puzzlehash for a singleton with the innerpuzzle curried in
  ; puzzle-hash-of-curried-function is imported from curry-and-treehash.clinc
  (defun-inline calculate_full_puzzle_hash (SINGLETON_MOD_HASH LAUNCHER_ID LAUNCHER_PUZZLE_HASH inner_puzzle_hash)
     (puzzle-hash-of-curried-function SINGLETON_MOD_HASH
                                      inner_puzzle_hash
                                      (sha256tree (c SINGLETON_MOD_HASH (c LAUNCHER_ID LAUNCHER_PUZZLE_HASH)))
     )
  )

  ;; return the full puzzlehash for a singleton with the innerpuzzle curried in
  ; puzzle-hash-of-curried-function is imported from curry-and-treehash.clinc
  (defun-inline delayed-spend (SECONDS_DELAY DELAYED_PUZZLE_HASH delayed_puzzle_reveal delayed_puzzle_solution)
    (if (= (sha256tree delayed_puzzle_reveal) DELAYED_PUZZLE_HASH)
      (c (list ASSERT_SECONDS_RELATIVE SECONDS_DELAY) (a delayed_puzzle_reveal delayed_puzzle_solution))
      (x)
    )
  )

  (defun-inline claim-rewards (SINGLETON_MOD_HASH LAUNCHER_ID LAUNCHER_PUZZLE_HASH singleton_inner_puzzle_hash my_id)
    (list
        (list ASSERT_PUZZLE_ANNOUNCEMENT (sha256 (calculate_full_puzzle_hash SINGLETON_MOD_HASH LAUNCHER_ID LAUNCHER_PUZZLE_HASH singleton_inner_puzzle_hash) my_id))
        (list CREATE_COIN_ANNOUNCEMENT 0x80)
        (list ASSERT_MY_COIN_ID my_id))
  )

  ; main
  (if delayed_puzzle_reveal
    (delayed-spend SECONDS_DELAY DELAYED_PUZZLE_HASH delayed_puzzle_reveal p1)
    (claim-rewards SINGLETON_MOD_HASH LAUNCHER_ID LAUNCHER_PUZZLE_HASH p1 p2)
  )
)
