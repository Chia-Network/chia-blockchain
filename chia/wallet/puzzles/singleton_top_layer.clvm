(mod (MOD_HASH GENESIS_ID LAUNCHER_PUZZLE_HASH INNERPUZ parent_info my_amount inner_solution)

; MOD_HASH, GENESIS_ID, INNERPUZ are curried in by the wallet

; EXAMPLE SOLUTION '(0xfadeddab 0xdeadbeef 1 (0xdeadbeef 200) 50 ((51 0xfadeddab 100) (60 "trash") (51 deadbeef 0)))'


; This puzzle is a wrapper around an inner smart puzzle which guarantees uniqueness.
; It takes its singleton identity from a coin with a launcher puzzle which guarantees that it is unique.

  (include condition_codes.clvm)
  (include curry-and-treehash.clinc)

  ; takes a lisp tree and returns the hash of it
  (defun sha256tree1 (TREE)
      (if (l TREE)
          (sha256 2 (sha256tree1 (f TREE)) (sha256tree1 (r TREE)))
          (sha256 1 TREE)
      )
  )

  ; "assert" is a macro that wraps repeated instances of "if"
  ; usage: (assert A0 A1 ... An R)
  ; all of A0, A1, ... An must evaluate to non-null, or an exception is raised
  ; return the value of R (if we get that far)

  (defmacro assert items
    (if (r items)
        (list if (f items) (c assert (r items)) (q . (x "three")))
      (f items)
      )
    )

  ;; boolean and macro
  ;; This lets you write something like (if (and COND1 COND2 COND3) (do-something) (do-something-else))
  (defmacro and ARGS
    (if ARGS
        (qq (if (unquote (f ARGS))
                (unquote (c and (r ARGS)))
              ()
              ))
      1)
    )

  ;; return the full puzzlehash for a singleton with the innerpuzzle curried in
  ; puzzle-hash-of-curried-function is imported from curry-and-treehash.clinc
  (defun-inline calculate_full_puzzle_hash (MOD_HASH LAUNCHER_ID LAUNCHER_PUZZLE_HASH inner_puzzle_hash)
     (puzzle-hash-of-curried-function MOD_HASH inner_puzzle_hash (sha256 1 LAUNCHER_PUZZLE_HASH) (sha256 1 LAUNCHER_ID) (sha256 1 MOD_HASH))
  )

  ; assembles information from the solution to create our own full ID including asserting our parent is a singleton
  (defun create_my_ID (MOD_HASH LAUNCHER_ID LAUNCHER_PUZZLE_HASH full_puzzle_hash parent_parent parent_inner_puzzle parent_amount my_amount)
    (sha256 (sha256 parent_parent (calculate_full_puzzle_hash MOD_HASH LAUNCHER_ID LAUNCHER_PUZZLE_HASH parent_inner_puzzle) parent_amount)
            full_puzzle_hash
            my_amount)
  )

  ;; take a boolean and a non-empty list of conditions
  ;; strip off the first condition if a boolean is set
  ;; this is used to remove `(CREATE_COIN xxx -113)`
  ;; pretty sneaky, eh?
  (defun strip_first_condition_if (boolean condition_list)
    (if boolean
      (r condition_list)
      condition_list
    )
  )

  (defun morph_condition (condition MOD_HASH LAUNCHER_ID LAUNCHER_PUZZLE_HASH)
    (list (f condition) (calculate_full_puzzle_hash MOD_HASH LAUNCHER_ID LAUNCHER_PUZZLE_HASH (f (r condition))) (f (r (r condition))))
  )

  ;; return the value of the coin created if this is a `CREATE_COIN` condition, or 0 otherwise
  (defun created_coin_value_or_0 (condition)
    (if (= (f condition) CREATE_COIN)
        (f (r (r condition)))
        0
    )
  )

  ;;
  (defun odd_cons_m113 (output_amount)
    (c
      (= (logand output_amount 1) 1)
      (= output_amount -113)
    )
  )

  ; Assert exactly one output with odd value exists - ignore it if value is -113

  ;; this function iterates over the output conditions from the inner puzzle & solution
  ;; and both checks that exactly one unique singleton child is created (with odd valued output),
  ;; and wraps the inner puzzle with this same singleton wrapper puzzle
  ;;
  ;; The special case where the output value is -113 means a child singleton is intentionally
  ;; *NOT* being created, thus forever ending this singleton's existence

  (defun check_and_morph_conditions_for_singleton (MOD_HASH LAUNCHER_ID LAUNCHER_PUZZLE_HASH conditions odd_output_found)
    (if conditions
        (morph_next_condition MOD_HASH LAUNCHER_ID LAUNCHER_PUZZLE_HASH conditions odd_output_found (odd_cons_m113 (created_coin_value_or_0 (f conditions))))
          (if (odd_output_found)
              0
              (x "four")  ;; no odd output found
          )
        )
   )

   ;; a continuation of `check_and_morph_conditions_for_singleton` with booleans `output_odd` and `output_m113`
   ;; precalculated
   (defun morph_next_condition (MOD_HASH LAUNCHER_ID LAUNCHER_PUZZLE_HASH conditions odd_output_found (output_odd . output_m113))
       (assert
          (not (all output_odd odd_output_found))
          (strip_first_condition_if
             output_m113
             (c (if output_odd
                    (morph_condition (f conditions) MOD_HASH LAUNCHER_ID LAUNCHER_PUZZLE_HASH)
                    (f conditions)
                )
                (check_and_morph_conditions_for_singleton MOD_HASH LAUNCHER_ID LAUNCHER_PUZZLE_HASH (r conditions) (any output_odd odd_output_found))
             )
          )
      )
   )

  ; this final stager asserts our ID
  ; it also runs the innerpuz with the innersolution with the "truths" added
  ; it then passes that output conditions from the innerpuz to the morph conditions function

  (defun stager_three (MOD_HASH GENESIS_ID LAUNCHER_PUZZLE_HASH parent_info my_id full_puzhash innerpuzhash my_amount INNERPUZ inner_solution)
    (c (list ASSERT_MY_COIN_ID my_id) (check_and_morph_conditions_for_singleton MOD_HASH GENESIS_ID LAUNCHER_PUZZLE_HASH (a INNERPUZ (c (list MOD_HASH GENESIS_ID my_id full_puzhash innerpuzhash my_amount parent_info) inner_solution)) 0))
  )

  ; this checks whether we are an eve spend or not and calculates our full coin ID appropriately and passes it on to the final stager
  ; if we are the eve spend it also adds the additional checks that our parent's puzzle is the standard launcher format and that out parent ID is the same as our singleton ID

  (defun stager_two (MOD_HASH GENESIS_ID LAUNCHER_PUZZLE_HASH parent_info full_puzhash innerpuzhash my_amount INNERPUZ inner_solution)
    (if (r (r parent_info))
      (stager_three MOD_HASH GENESIS_ID LAUNCHER_PUZZLE_HASH parent_info (create_my_ID MOD_HASH GENESIS_ID LAUNCHER_PUZZLE_HASH full_puzhash (f parent_info) (f (r parent_info)) (f (r (r parent_info))) my_amount) full_puzhash innerpuzhash my_amount INNERPUZ inner_solution)
      (if (= GENESIS_ID (sha256 (f parent_info) LAUNCHER_PUZZLE_HASH (f (r parent_info))))
        (stager_three MOD_HASH GENESIS_ID LAUNCHER_PUZZLE_HASH parent_info (sha256 GENESIS_ID full_puzhash my_amount) full_puzhash innerpuzhash my_amount INNERPUZ inner_solution)
        (x "one")
      )
    )
  )

  ; this calculates our current full puzzle hash and passes it to stager two
  (defun stager_one (MOD_HASH GENESIS_ID LAUNCHER_PUZZLE_HASH parent_info my_innerpuzhash my_amount INNERPUZ inner_solution)
    (stager_two MOD_HASH GENESIS_ID LAUNCHER_PUZZLE_HASH parent_info (calculate_full_puzzle_hash MOD_HASH GENESIS_ID LAUNCHER_PUZZLE_HASH my_innerpuzhash) my_innerpuzhash my_amount INNERPUZ inner_solution)
  )


  ; main

  ; if our value is not an odd amount then we are invalid
  ; this calculates my_innerpuzhash and passes all values to stager_one
  (if (logand my_amount 1)
    (stager_one MOD_HASH GENESIS_ID LAUNCHER_PUZZLE_HASH parent_info (sha256tree1 INNERPUZ) my_amount INNERPUZ inner_solution)
    (x "two")
  )

)
