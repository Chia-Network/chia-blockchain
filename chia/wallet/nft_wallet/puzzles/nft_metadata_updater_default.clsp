(mod (CURRENT_METADATA METADATA_UPDATER_PUZZLE_HASH (key new_url signature))

  ; METADATA and METADATA_UPDATER_PUZZLE_HASH are passed in as truths from the layer above
  ; This program returns ((new_metadata new_metadata_updater_puzhash) conditions)

  (include condition_codes.clib)
  (include curry-and-treehash.clib)

  ; Add uri to a field
  (defun add_url (METADATA key new_url)
    (if METADATA
        (if (= (f (f METADATA)) key)
            (c (c key (c new_url (r (f METADATA)))) (r METADATA))
            (c (f METADATA) (add_url (r METADATA) key new_url))
        )
        ()
    )
  )

  ; it would be cheaper on chain to refactor this to be a part of the same loop as add_url
  (defun scan_for_pk (METADATA msg signature)
    (if METADATA
      (if (= (f (f METADATA)) "pk")
        (if (secp256k1_verify (r (f METADATA)) msg signature)
          (x)
          0
        )  ; returns 0 if passed, fails otherwise
        (scan_for_pk (r METADATA) msg signature)
      )
      0  ; if the SECP PK is not set, then let anybody update the puzzle - this means that tests that don't have a PK still pass
    )
  )

  ; main
  ; returns ((new_metadata new_metadata_updater_puzhash) conditions)
  (list
    (list
      (if (all key new_url)
          (if (any (= key "mu") (= key "lu") (= key "u") (= key "did"))
              (add_url CURRENT_METADATA key new_url)
              CURRENT_METADATA
          )
          CURRENT_METADATA
      )
      METADATA_UPDATER_PUZZLE_HASH
    )
    ; TODO: this is vulnerable to replay attacks - pass in my_coin_ID as part of the signature and return an assert_my_id to fix
    (scan_for_pk CURRENT_METADATA (sha256 (sha256tree (list key new_url))) signature)
  )
)
