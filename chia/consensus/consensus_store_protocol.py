from __future__ import annotations

from collections.abc import Collection
from contextlib import AbstractAsyncContextManager
from typing import Optional, Protocol

import aiosqlite
from chia_rs import BlockRecord, FullBlock, SubEpochChallengeSegment, SubEpochSummary
from chia_rs.sized_bytes import bytes32
from chia_rs.sized_ints import uint32, uint64

from chia.types.blockchain_format.coin import Coin
from chia.types.coin_record import CoinRecord


class ConsensusStoreProtocol(Protocol):
    """
    Protocol for the consensus store, which provides methods to interact with
    the consensus-related data in the blockchain.
    """

    # Block store methods
    def transaction(self) -> AbstractAsyncContextManager[aiosqlite.Connection]: ...

    async def get_block_records_close_to_peak(
        self, blocks_n: int
    ) -> tuple[dict[bytes32, BlockRecord], Optional[bytes32]]: ...
    async def get_full_block(self, header_hash: bytes32) -> Optional[FullBlock]: ...
    async def add_full_block(self, header_hash: bytes32, block: FullBlock, block_record: BlockRecord) -> None: ...
    def rollback_cache_block(self, header_hash: bytes32) -> None: ...
    async def get_block_records_by_hash(self, header_hashes: list[bytes32]) -> list[BlockRecord]: ...
    async def rollback(self, height: int) -> None: ...
    async def set_in_chain(self, header_hashes: list[tuple[bytes32]]) -> None: ...
    async def set_peak(self, header_hash: bytes32) -> None: ...
    async def get_block_records_in_range(self, start: int, stop: int) -> dict[bytes32, BlockRecord]: ...
    def get_block_from_cache(self, header_hash: bytes32) -> Optional[FullBlock]: ...
    async def get_blocks_by_hash(self, header_hashes: list[bytes32]) -> list[FullBlock]: ...
    async def get_block_record(self, header_hash: bytes32) -> Optional[BlockRecord]: ...
    async def get_prev_hash(self, header_hash: bytes32) -> bytes32: ...
    async def persist_sub_epoch_challenge_segments(
        self, ses_block_hash: bytes32, segments: list[SubEpochChallengeSegment]
    ) -> None: ...
    async def get_sub_epoch_challenge_segments(
        self, ses_block_hash: bytes32
    ) -> Optional[list[SubEpochChallengeSegment]]: ...
    async def get_generator(self, header_hash: bytes32) -> Optional[bytes]: ...
    async def get_generators_at(self, heights: set[uint32]) -> dict[uint32, bytes]: ...

    # Coin store methods
    async def get_coin_records(self, names: Collection[bytes32]) -> list[CoinRecord]: ...
    async def rollback_to_block(self, block_index: int) -> dict[bytes32, CoinRecord]: ...
    async def new_block(
        self,
        height: uint32,
        timestamp: uint64,
        included_reward_coins: Collection[Coin],
        tx_additions: Collection[tuple[bytes32, Coin, bool]],
        tx_removals: list[bytes32],
    ) -> None: ...
    async def get_coins_added_at_height(self, height: uint32) -> list[CoinRecord]: ...
    async def get_coins_removed_at_height(self, height: uint32) -> list[CoinRecord]: ...

    # Height map methods
    def get_ses_heights(self) -> list[uint32]: ...
    def get_ses(self, height: uint32) -> SubEpochSummary: ...
    def contains_height(self, height: uint32) -> bool: ...
    def get_hash(self, height: uint32) -> bytes32: ...
    def rollback_height_map(self, height: uint32) -> None: ...
    def update_height_map(self, height: uint32, block_hash: bytes32, ses: Optional[SubEpochSummary]) -> None: ...
    async def maybe_flush_height_map(self) -> None: ...
