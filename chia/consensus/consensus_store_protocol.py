from __future__ import annotations

from collections.abc import Collection
from typing import Optional, Protocol

from chia_rs import BlockRecord, FullBlock, SubEpochChallengeSegment, SubEpochSummary
from chia_rs.sized_bytes import bytes32
from chia_rs.sized_ints import uint32, uint64
from typing_extensions import AsyncContextManager

from chia.types.blockchain_format.coin import Coin
from chia.types.coin_record import CoinRecord


class ConsensusStoreWriteProtocol(Protocol):
    """
    Protocol for performing mutating operations on the consensus store.

    Instances implementing this protocol should be acquired via the async
    context manager on ConsensusStoreProtocol to ensure atomic write
    operations (e.g., wrapping all writes in a single DB transaction).
    """

    # Block store writes
    async def add_full_block(self, header_hash: bytes32, block: FullBlock, block_record: BlockRecord) -> None: ...
    async def rollback(self, height: int) -> None: ...
    async def set_in_chain(self, header_hashes: list[tuple[bytes32]]) -> None: ...
    async def set_peak(self, header_hash: bytes32) -> None: ...
    async def persist_sub_epoch_challenge_segments(
        self, ses_block_hash: bytes32, segments: list[SubEpochChallengeSegment]
    ) -> None: ...

    # Coin store writes
    async def rollback_to_block(self, block_index: int) -> dict[bytes32, CoinRecord]: ...
    async def new_block(
        self,
        height: uint32,
        timestamp: uint64,
        included_reward_coins: Collection[Coin],
        tx_additions: Collection[tuple[bytes32, Coin, bool]],
        tx_removals: list[bytes32],
    ) -> None: ...


class ConsensusStoreProtocol(Protocol):
    """
    Read-only protocol for the consensus store.

    This protocol is callable and returns an async context manager. Entering the context
    yields a ConsensusStoreWriteProtocol instance, which must be used for
    performing write (mutating) operations. This ensures atomic writes and
    makes it harder to accidentally perform writes outside a transaction.

    Example usage:
        async with store.writer() as writer:
            await writer.add_full_block(...)
            await writer.set_peak(...)

        # Outside the context, only read methods are available
        br = await store.get_block_record(header_hash)
    """

    # Writer method that returns async context manager
    def writer(self) -> AsyncContextManager[ConsensusStoreWriteProtocol]: ...

    # Block store reads
    async def get_block_records_close_to_peak(
        self, blocks_n: int
    ) -> tuple[dict[bytes32, BlockRecord], Optional[bytes32]]: ...
    async def get_full_block(self, header_hash: bytes32) -> Optional[FullBlock]: ...
    async def get_block_records_by_hash(self, header_hashes: list[bytes32]) -> list[BlockRecord]: ...
    async def get_block_records_in_range(self, start: int, stop: int) -> dict[bytes32, BlockRecord]: ...
    def get_block_from_cache(self, header_hash: bytes32) -> Optional[FullBlock]: ...
    async def get_blocks_by_hash(self, header_hashes: list[bytes32]) -> list[FullBlock]: ...
    async def get_block_record(self, header_hash: bytes32) -> Optional[BlockRecord]: ...
    async def get_prev_hash(self, header_hash: bytes32) -> bytes32: ...
    async def get_sub_epoch_challenge_segments(
        self, ses_block_hash: bytes32
    ) -> Optional[list[SubEpochChallengeSegment]]: ...
    async def get_generator(self, header_hash: bytes32) -> Optional[bytes]: ...
    async def get_generators_at(self, heights: set[uint32]) -> dict[uint32, bytes]: ...

    # Coin store reads
    async def get_coin_records(self, names: Collection[bytes32]) -> list[CoinRecord]: ...
    async def get_coin_record(self, coin_name: bytes32) -> Optional[CoinRecord]: ...
    async def get_coins_added_at_height(self, height: uint32) -> list[CoinRecord]: ...
    async def get_coins_removed_at_height(self, height: uint32) -> list[CoinRecord]: ...

    # Height map methods (kept here for now; non-async and maybe_flush remain on read protocol)
    def get_ses_heights(self) -> list[uint32]: ...
    def get_ses(self, height: uint32) -> SubEpochSummary: ...
    def contains_height(self, height: uint32) -> bool: ...
    def get_hash(self, height: uint32) -> bytes32: ...
    def rollback_height_map(self, height: uint32) -> None: ...
    def update_height_map(self, height: uint32, block_hash: bytes32, ses: Optional[SubEpochSummary]) -> None: ...
    async def maybe_flush_height_map(self) -> None: ...
    def rollback_cache_block(self, header_hash: bytes32) -> None: ...
