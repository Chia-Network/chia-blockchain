from __future__ import annotations

from contextlib import AbstractAsyncContextManager
from typing import Any, Optional, Protocol

from chia_rs import BlockRecord, FullBlock, SubEpochChallengeSegment
from chia_rs.sized_bytes import bytes32
from chia_rs.sized_ints import uint32

from chia.consensus.generator_block_info import GeneratorBlockInfo


class BlockStoreProtocol(Protocol):
    async def add_full_block(self, header_hash: bytes32, block: FullBlock, block_record: BlockRecord) -> None: ...
    def get_block_from_cache(self, header_hash: bytes32) -> Optional[FullBlock]: ...
    async def get_full_block(self, header_hash: bytes32) -> Optional[FullBlock]: ...
    async def get_full_block_bytes(self, header_hash: bytes32) -> Optional[bytes]: ...
    async def get_full_blocks_at(self, heights: list[uint32]) -> list[FullBlock]: ...
    async def get_block_info(self, header_hash: bytes32) -> Optional[GeneratorBlockInfo]: ...
    async def get_generator(self, header_hash: bytes32) -> Optional[bytes]: ...
    async def get_generators_at(self, heights: set[uint32]) -> dict[uint32, bytes]: ...
    async def get_block_record(self, header_hash: bytes32) -> Optional[BlockRecord]: ...
    async def get_block_records_in_range(self, start: int, stop: int) -> dict[bytes32, BlockRecord]: ...
    async def get_block_records_by_hash(self, header_hashes: list[bytes32]) -> list[BlockRecord]: ...
    async def get_block_bytes_by_hash(self, header_hashes: list[bytes32]) -> list[bytes]: ...
    async def get_blocks_by_hash(self, header_hashes: list[bytes32]) -> list[FullBlock]: ...
    async def get_peak(self) -> Optional[tuple[bytes32, uint32]]: ...
    async def get_block_bytes_in_range(self, start: int, stop: int) -> list[bytes]: ...
    async def get_random_not_compactified(self, number: int) -> list[int]: ...
    async def persist_sub_epoch_challenge_segments(
        self, ses_block_hash: bytes32, segments: list[SubEpochChallengeSegment]
    ) -> None: ...
    async def get_sub_epoch_challenge_segments(
        self,
        ses_block_hash: bytes32,
    ) -> Optional[list[SubEpochChallengeSegment]]: ...
    async def rollback(self, height: int) -> None: ...
    def rollback_cache_block(self, header_hash: bytes32) -> None: ...
    async def set_in_chain(self, header_hashes: list[tuple[bytes32]]) -> None: ...
    async def set_peak(self, header_hash: bytes32) -> None: ...
    async def is_fully_compactified(self, header_hash: bytes32) -> Optional[bool]: ...
    async def replace_proof(self, header_hash: bytes32, block: FullBlock) -> None: ...
    async def count_compactified_blocks(self) -> int: ...
    async def count_uncompactified_blocks(self) -> int: ...
    async def get_block_records_close_to_peak(
        self, blocks_n: int
    ) -> tuple[dict[bytes32, BlockRecord], Optional[bytes32]]: ...

    async def get_prev_hash(self, header_hash: bytes32) -> bytes32: ...
    def transaction(self) -> AbstractAsyncContextManager[Any]: ...
