; Coins locked with this puzzle are spendable ccs.
;
; Choose a list of n inputs (n>=1), I_1, ... I_n.
;
; A_k : the amount contributed as available for spending by input I_k
; I_k : the input coins, I_k = (parent_k, puzzle_hash_k, A_k) where A_k is an input "amount".
; L_k : the lock coin created by I_k and consumed by I_{k-1}
; O_k : the amount spent by I_k
; D_k = the "delta" O_k - A_k contribution of coin I_k, ie. how much debt this input accumulates
; S_k : the "running subtotal" of deltas (see below)
;
; Each input I_k has an inner solution that creates 0 or more outputs, with total amount O_k.
;
; All conditions go through a "transformer" that looks for CREATE_COIN conditions
; generated by the inner solution, and wraps the puzzle hash.
;
; Three output conditions are prepended to the list of conditions for each I_k:
;  (ASSERT_MY_ID I_k) to ensure that the passed in value for I_k is correct
;  (CREATE_COIN L_k 0) to create the lock coin
;  (ASSERT_COIN_CONSUMED L_{k+1}) to consume the next coin's lock
;
; For each k, define the "subtotal at k" S_k as follows:
;  S_1 = 0 (it could actually be any value, but 0 is an obvious nice way to start)
;  S_{k+1} = S_k + D_k = S_k + O_k - A_k
;
; Each input I_k creates a lock output L_k that has commitments to the following values:
;  - O_k (calculated from the inner puzzle & inner solution)
;  - I_k (passed in by the solution, and verified with ASSERT_MY_ID)
;  - I_{k+1} where k+1 wraps around to 1 if k = n (passed in by the solution)
;  - S_k (passed in by the solution)
;
; We generate a (CREATE_COIN L_k 0) condition, a lock coin with 0 value.
;
; The solution will also pass in O_{k+1} and I_{k+2}.
; With this, and knowing S_k, O_k and A_k, we can calculate L_{k+1} and
; generate an (ASSERT_COIN_CONSUMED L_{k+1}) condition.
;
; This is all we need to do to ensure ccs exactly balance in the inputs and outputs.
;
; Proof:
;   Consider n, k, I_k values, O_k values, S_k and A_k as above.
;   For the (CREATE_COIN L_k) and (ASSERT_COIN_CONSUMED L_{k+1}) to match,
;   we see that I_k can ensure that is has the correct values for many things,
;   including O_{k+1}, A_{k+1}.
;
;   By induction, we see that S_{m+1} = sum(i, 1, m) [O_i - A_i] = sum(i, 1, m) O_i - sum(i, 1, m) A_i
;   So S_{n+1} = sum(i, 1, n) O_i - sum(i, 1, n) A_i. But S_{n+1} is actually S_1 = 0,
;   so thus sum(i, 1, n) O_i = sum (i, 1, n) A_i, ie. output total equals input total.
;
; QUESTION: do we want a secondary puzzle that allows for coins to be spent? This could be good for
;  bleaching coins (sendable to any address), or reclaiming them by a central authority.
;

;; GLOSSARY:
;;  mod-hash: this code's sha256 tree hash
;;  genesis-coin-checker: the function that determines if a coin can mint new ccs
;;  inner-puzzle: the puzzle protecting the coins
;; ---- items above are curried into the puzzle hash ----
;;  inner-puzzle-solution: the solution to the inner puzzle
;;  my-coin-info: the triple representing "me"
;;  my-lineage-proof: the check that I am actually a valid cc, either via genesis-coin-checker
;          or by proof that my parent puzzle hash is a wrapping
;;  subtotal: S_k, the "subtotal" so far
;;  next-coin-info: the triple representing the "next" coin in the loop
;;  my-lineage-proof: the check that I am actually a valid cc, either via genesis-coin-checker
;          or by proof that my parent puzzle hash is a wrapping
;;  next-coin-output-value: O_{k+1}
;;  coin-after-next: I_{k+2}, used to help calculate L_{k+1}

(mod (mod-hash                ;; curried into puzzle
      genesis-coin-checker    ;; curried into puzzle
      inner-puzzle            ;; curried into puzzle
      inner-puzzle-solution   ;; if invalid, inner-puzzle will fail
      my-coin-info            ;; verified with ASSERT_MY_COIN_ID
      my-lineage-proof        ;; if not correct, (x) will raise
      subtotal                ;; if the subtotal doesn't match between two adjacent coins, the ASSERT_COIN_CONSUMED linking them will fail
      next-coin-info          ;; if not correct, this ASSERT_COIN_CONSUMED will fail
      next-coin-lineage-proof ;; if not correct, (x) will raise
      next-coin-output-value  ;; if not correct, this ASSERT_COIN_CONSUMED will fail
      coin-after-next         ;; if not correct, this ASSERT_COIN_CONSUMED will fail
    )

     ;;;;; start library code

     (defconstant CREATE_COIN 51)
     (defconstant ASSERT_COIN_CONSUMED 52)
     (defconstant ASSERT_MY_COIN_ID 53)

     (defmacro assert items
         (if (r items)
             (list if (f items) (c assert (r items)) (q (x)))
             (f items)
         )
     )

     ;; utility function used by `curry_args`
     (defun fix_curry_args (items core)
       (if items
           (qq (c (q (unquote (f items))) (unquote (fix_curry_args (r items) core))))
           core
       )
     )

     ; (curry_args sum (list 50 60)) => returns a function that is like (sum 50 60 ...)
     (defun curry_args (func list_of_args) (qq ((c (q (unquote func)) (unquote (fix_curry_args list_of_args (q 1)))))))

     ;; (curry sum 50 60) => returns a function that is like (sum 50 60 ...)
     (defun curry (func . args) (curry_args func args))

     (defun is-in-list (atom items)
       ;; returns 1 iff `atom` is in the list of `items`
       (if items
         (if (= atom (f items))
           1
           (is-in-list atom (r items))
         )
         0
       )
     )

     ;; hash a tree with escape values representing already-hashed subtrees
     ;; This optimization can be useful if you know the puzzle hash of a sub-expression.
     ;; You probably actually want to use `curry_and_hash` though.
     (defun sha256tree_esc_list
            (TREE LITERALS)
            (if (l TREE)
                (sha256 2 (sha256tree_esc_list (f TREE) LITERALS) (sha256tree_esc_list (r TREE) LITERALS))
                (if (is-in-list TREE LITERALS)
                    TREE
                    (sha256 1 TREE)
                )
            )
     )

     ;; hash a tree with escape values representing already-hashed subtrees
     ;; This optimization can be useful if you know the tree hash of a sub-expression.
     (defun sha256tree_esc
        (TREE . LITERAL)
        (sha256tree_esc_list TREE LITERAL)
     )

     ; takes a lisp tree and returns the hash of it
     (defun sha256tree1 (TREE)
           (if (l TREE)
               (sha256 2 (sha256tree1 (f TREE)) (sha256tree1 (r TREE)))
               (sha256 1 TREE)))

     ;;;;; end library code

     ;; return the puzzle hash for a cc with the given `genesis-coin-checker-hash` & `inner-puzzle`
     (defun cc-puzzle-hash (mod-hash mod-hash-hash genesis-coin-checker-hash inner-puzzle-hash)
       (sha256tree_esc (curry mod-hash mod-hash-hash genesis-coin-checker-hash inner-puzzle-hash)
                       mod-hash
                       mod-hash-hash
                       genesis-coin-checker-hash
                       inner-puzzle-hash)
     )

     ;; tweak `CREATE_COIN` condition by wrapping the puzzle hash, forcing it to be a cc
     (defun-inline morph-condition (condition mod-hash mod-hash-hash genesis-coin-checker-hash)
       (if (= (f condition) CREATE_COIN)
         (list CREATE_COIN
               (cc-puzzle-hash mod-hash mod-hash-hash genesis-coin-checker-hash (f (r condition)))
               (f (r (r condition)))
         )
         condition
       )
     )

     ;; tweak all `CREATE_COIN` conditions, enforcing created coins to be ccs
     (defun morph-conditions (conditions mod-hash mod-hash-hash genesis-coin-checker-hash)
       (if conditions
         (c
           (morph-condition (f conditions) mod-hash mod-hash-hash genesis-coin-checker-hash)
           (morph-conditions (r conditions) mod-hash mod-hash-hash genesis-coin-checker-hash)
         )
         ()
       )
     )

     ;; given a coin triplet, return the id of the coin
     (defun coin-id-for-coin ((parent-id puzzle-hash amount))
       (sha256 parent-id puzzle-hash amount)
     )

     ;; calculate the coin id of a lock coin
     (defun-inline calculate-lock-coin-id (output-value coin-info next-coin-info subtotal)
       (sha256 (coin-id-for-coin coin-info) (puzzle-hash-for-lock output-value next-coin-info subtotal) 0)
     )

     ;; utility to fetch coin amount from coin
     (defun-inline amount-for-coin (coin)
       (f (r (r coin)))
     )

     ;; given the subtotal for this coin, calculate the subtotal for the next coin
     (defun-inline new-subtotal (subtotal next-coin-output-value next-coin-amount)
       (- (+ subtotal next-coin-output-value) next-coin-amount)
     )

     ;; create the `ASSERT_COIN_CONSUMED` condition that ensures the next coin's lock is spent
     (defun-inline create-assert-next-lock-consumed-condition (my-coin-info next-coin-output-value next-coin-info coin-after-next subtotal)
       (list ASSERT_COIN_CONSUMED
             (calculate-lock-coin-id next-coin-output-value
                                     next-coin-info
                                     coin-after-next (new-subtotal subtotal
                                                                   next-coin-output-value
                                                                   (amount-for-coin next-coin-info))))
     )

     ;; calculate the puzzle hash for a lock coin
     (defun puzzle-hash-for-lock (o-sub-k next-coin-info subtotal)
       (sha256tree1 (curry (lambda ARGS ()) o-sub-k next-coin-info subtotal))
     )

     ;; here we commit to O_k, I_{k+1} and S_k
     (defun-inline create-lock-coin-condition (o-sub-k next-coin-info subtotal)
       (list CREATE_COIN
         (puzzle-hash-for-lock o-sub-k next-coin-info subtotal)
         0
       )
      )

     ;;;;;;;;;;;;;;;;;;;;;;;;;;;

     ;; this function takes a condition and returns an integer indicating
     ;; the value of all output coins created with CREATE_COIN. If it's not
     ;; a CREATE_COIN condition, it returns 0.

     (defun-inline output-value-for-condition (condition)
       (if (= (f condition) CREATE_COIN)
         (f (r (r condition)))
         0
       )
     )

     ;; this function takes a list of conditions and returns an integer indicating
     ;; the value of all output coins created with CREATE_COIN
     (defun output-totals (conditions)
       (if conditions
         (+ (output-value-for-condition (f conditions)) (output-totals (r conditions)))
         0
       )
     )

     ;; ensure `my-coin-info` is correct by creating the `ASSERT_MY_COIN_ID` condition
     (defun-inline create-assert-my-id (my-coin-info)
       (list ASSERT_MY_COIN_ID (coin-id-for-coin my-coin-info))
     )

     ;; add three conditions to the list of morphed conditions:
     ;; CREATE_COIN for the lock coin
     ;; ASSERT_MY_COIN_ID for `my-coin-info`
     ;; ASSERT_COIN_CONSUMED for the next coin's lock coin
     (defun-inline generate-final-output-conditions
       (
         o-sub-k
         morphed-conditions
         my-coin-info
         next-coin-info
         subtotal
         next-coin-output-value
         coin-after-next
       )
       (c (create-assert-my-id my-coin-info)
         (c (create-lock-coin-condition o-sub-k next-coin-info subtotal)
           (c (create-assert-next-lock-consumed-condition my-coin-info next-coin-output-value next-coin-info coin-after-next subtotal)
             morphed-conditions)
         )
       )
      )

     ;;;;;;;;;;;;;;;;;;;;;;;;;;; lineage checking

     ;; return true iff parent of `my-coin-info` is provably a cc
     (defun is-parent-cc (
       mod-hash
       mod-hash-hash
       genesis-coin-checker-hash
       my-coin-info
       (parent-parent-coin-id parent-inner-puzzle-hash parent-amount)
     )
       (= (f my-coin-info)
          (sha256 parent-parent-coin-id
                  (cc-puzzle-hash mod-hash mod-hash-hash genesis-coin-checker-hash parent-inner-puzzle-hash)
                  parent-amount
          )
       )
     )

     ;; return true iff the lineage proof is valid
     ;; my-lineage-proof is of one of two forms:
     ;;  (1 . (parent-parent-coin-id parent-inner-puzzle-hash parent-amount))
     ;;  (0 . some-opaque-proof-passed-to-genesis-coin-checker)
     ;; so the `f` value determines what kind of proof it is, and the `r` value is the proof

     (defun is-lineage-proof-valid (
       mod-hash mod-hash-hash genesis-coin-checker genesis-coin-checker-hash my-coin-info my-lineage-proof)
       (if
         (f my-lineage-proof)
         (is-parent-cc mod-hash mod-hash-hash genesis-coin-checker-hash my-coin-info (r my-lineage-proof))
         ((c genesis-coin-checker (list genesis-coin-checker-hash mod-hash mod-hash-hash my-coin-info (r my-lineage-proof))))
       )
     )

     ;;;;;;;;;;;;;;;;;;;;;;;;;;;

     (defun main (
         mod-hash
         mod-hash-hash
         genesis-coin-checker
         genesis-coin-checker-hash
         inner-conditions
         my-coin-info
         my-lineage-proof
         subtotal
         next-coin-info
         next-coin-lineage-proof
         next-coin-output-value
         coin-after-next
      )
      (assert
        ;; ensure my lineage is a legitimate cc
        (is-lineage-proof-valid mod-hash mod-hash-hash genesis-coin-checker genesis-coin-checker-hash my-coin-info my-lineage-proof)

        ;; ensure next coin lineage is a legitimate cc
        (is-lineage-proof-valid mod-hash mod-hash-hash genesis-coin-checker genesis-coin-checker-hash next-coin-info next-coin-lineage-proof)

        ;; cache some stuff: output conditions, and mod-hash-hash
        (generate-final-output-conditions
          (output-totals inner-conditions)
          (morph-conditions inner-conditions mod-hash mod-hash-hash genesis-coin-checker-hash)
          my-coin-info
          next-coin-info
          subtotal
          next-coin-output-value
          coin-after-next
        )
      )
    )

    (main
        mod-hash
        (sha256tree1 mod-hash)
        genesis-coin-checker
        (sha256tree1 genesis-coin-checker)
        ((c inner-puzzle inner-puzzle-solution))
        my-coin-info
        my-lineage-proof
        subtotal
        next-coin-info
        next-coin-lineage-proof
        next-coin-output-value
        coin-after-next
    )
)
