(mod (mod_hash genesis_id innerpuz parent_info my_amount solution)

;mod_hash, genesis_id, innerpuz are curried in

; EXAMPLE SOLUTION '(0xfadeddab 0xdeadbeef 1 (0xdeadbeef 0xcafef00d 200) 50 ((51 0xfadeddab 100) (60 "trash") (51 deadbeef 0)))'

; 51 = CREATE_COIN
; 52 = ASSERT_CONSUMED
; 53 = OP_ASSERT_MY_ID

(defconstant OP_ASSERT_MY_ID 53)

; This is for the core

  (defmacro and ARGS
    (if ARGS
      (qq (if (unquote (f ARGS))
            (unquote (c and (r ARGS)))
            ()
      ))
    1)
  )

  (defmacro not (ARGS)
    (qq (if (unquote ARGS) 0 1))
  )

  (defun is-in-list (atom items)
    ;; returns 1 iff `atom` is in the list of `items`
    (if items
      (if (= atom (f items))
        1
        (is-in-list atom (r items))
      )
      0
    )
  )

  ; takes a lisp tree and returns the hash of it, but allows for escape character 97 so i precomputed hash value can be used
  (defun sha256tree0 (TREE)
    (if (l TREE)
      (if (and (not (l (f TREE))) (= (f TREE) 97))
          (f (r TREE))
          (sha256 2 (sha256tree0 (f TREE)) (sha256tree0 (r TREE)))
      )
      (sha256 1 TREE)
    )
  )

  ; takes a lisp tree and returns the hash of it
  (defun sha256tree1 (TREE)
      (if (l TREE)
          (sha256 2 (sha256tree1 (f TREE)) (sha256tree1 (r TREE)))
          (sha256 1 TREE)
      )
  )

  ;; utility function used by `curry_args`
  (defun fix_curry_args (items core)
    (if items
        (qq (c (q (unquote (f items))) (unquote (fix_curry_args (r items) core))))
        core
    )
  )

  ; (curry_args sum (list 50 60)) => returns a function that is like (sum 50 60 ...)
  (defun curry_args (func list_of_args) (qq ((c (q (unquote func)) (unquote (fix_curry_args list_of_args (q 1)))))))

  ;; (curry sum 50 60) => returns a function that is like (sum 50 60 ...)
  (defun curry (func . args) (curry_args func args))

  ;; hash a tree with escape values representing already-hashed subtrees
  ;; This optimization can be useful if you know the puzzle hash of a sub-expression.
  ;; You probably actually want to use `curry_and_hash` though.
  (defun sha256tree_esc_list
         (TREE LITERALS)
         (if (l TREE)
             (sha256 2 (sha256tree_esc_list (f TREE) LITERALS) (sha256tree_esc_list (r TREE) LITERALS))
             (if (is-in-list TREE LITERALS)
                 TREE
                 (sha256 1 TREE)
             )
         )
  )

  ;; hash a tree with escape values representing already-hashed subtrees
  ;; This optimization can be useful if you know the tree hash of a sub-expression.
  (defun sha256tree_esc
     (TREE . LITERAL)
     (sha256tree_esc_list TREE LITERAL)
  )

  ;; return the puzzle hash for a cc with the given `genesis-coin-checker-hash` & `inner-puzzle`
  (defun create_fullpuzhash (mod_hash mod_hash_hash genesis_id inner_puzzle_hash)
    (sha256tree_esc (curry mod_hash mod_hash_hash genesis_id inner_puzzle_hash)
                    mod_hash
                    mod_hash_hash
                    inner_puzzle_hash)
  )

  (defmacro create_outputs (puzreveal solution)
      (qq ((c (unquote puzreveal) (unquote solution))))
  )

  ; assembles information from the solution to create our own full ID including asserting our parent is a coloured coin
  (defun-inline create_my_ID (mod_hash mod_hash_hash genesis_id innerpuzhash (parent_parent parent_innerpuz parent_amount) my_amount)
    (sha256 (sha256 parent_parent (create_fullpuzhash mod_hash mod_hash_hash genesis_id parent_innerpuz) parent_amount) (create_fullpuzhash mod_hash mod_hash_hash genesis_id my_innerpuzhash) my_amount)
  )

  (defun check_my_amount_and_ID (mod_hash mod_hash_hash genesis_id my_innerpuzhash parent_info my_value)
    (if (> my_value 0)
      (if (l parent_info)
        (list OP_ASSERT_MY_ID (create_my_ID mod_hash mod_hash_hash genesis_id my_innerpuzhash ((f parent_info) (f (r parent_info)) (f (r (r parent_info)))) my_value))
        (list OP_ASSERT_MY_ID (sha256 genesis_id (create_fullpuzhash mod_hash mod_hash_hash genesis_id my_innerpuzhash) my_value))
      )
      (x "my_amount_and_id fail")
    )
  )

  (defun check_outputs_value (outputs_loop flag)
    (if outputs_loop
      (if (= (f (f outputs_loop)) (q 51))
        (if (> (f (r (r (f outputs_loop)))) 0)
          (if flag
            (x "more than one output with value > 1")
            (check_outputs_value (r outputs_loop) 1)
          )
          (check_outputs_value (r outputs_loop) flag)
        )
        (check_outputs_value (r outputs_loop) flag)
      )
      1
    )
  )

  (defun check_id_and_check_outputs (mod_hash mod_hash_hash genesis_id parent_info innerpuzhash my_amount outputs)
    (if (check_outputs_value outputs 0)
      (c (check_my_amount_and_ID mod_hash mod_hash_hash genesis_id innerpuzhash parent_info my_amount) outputs)
      (x "check_id_and_check_outputs fail")
    )
  )

  ;tests
  ;(list OP_ASSERT_MY_ID (create_my_ID mod_hash (sha256tree1 mod_hash) genesis_id innerpuz ((f parent_info) (f (r parent_info)) (f (r (r parent_info)))) my_amount))
  ;(create_my_ID mod_hash (sha256tree1 mod_hash) genesis_id innerpuz ((f parent_info) (f (r parent_info)) (f (r (r parent_info)))) my_amount)


  ;main
  (check_id_and_check_outputs mod_hash (sha256tree1 mod_hash) genesis_id parent_info (sha256tree1 innerpuz) my_amount (create_outputs innerpuz solution))

)
