diff --git a/.flake8 b/.flake8
index 9c5194b95..b8e822672 100644
--- a/.flake8
+++ b/.flake8
@@ -7,3 +7,7 @@ per-file-ignores =
     tests/util/test_network_protocol_files.py:F405
     tests/util/test_network_protocol_json.py:F405
     tests/util/protocol_messages_json.py:E501
+    chia/wallet/dao_wallet/dao_utils.py:E501
+    chia/wallet/dao_wallet/dao_wallet.py:E501
+    chia/wallet/cat_wallet/dao_cat_wallet.py:E501
+    tests/wallet/dao_wallet/test_dao_clvm.py:E501
diff --git a/chia/cmds/chia.py b/chia/cmds/chia.py
index 8e3b96168..4758bdf77 100644
--- a/chia/cmds/chia.py
+++ b/chia/cmds/chia.py
@@ -9,6 +9,7 @@ from chia import __version__
 from chia.cmds.beta import beta_cmd
 from chia.cmds.completion import completion
 from chia.cmds.configure import configure_cmd
+from chia.cmds.dao import dao_cmd
 from chia.cmds.data import data_cmd
 from chia.cmds.db import db_cmd
 from chia.cmds.dev import dev_cmd
@@ -128,6 +129,7 @@ cli.add_command(data_cmd)
 cli.add_command(passphrase_cmd)
 cli.add_command(beta_cmd)
 cli.add_command(completion)
+cli.add_command(dao_cmd)
 cli.add_command(dev_cmd)
 
 
diff --git a/chia/cmds/dao.py b/chia/cmds/dao.py
new file mode 100644
index 000000000..0335222a3
--- /dev/null
+++ b/chia/cmds/dao.py
@@ -0,0 +1,940 @@
+from __future__ import annotations
+
+from typing import Optional
+
+import click
+
+from chia.cmds.cmds_util import execute_with_wallet
+from chia.cmds.plotnft import validate_fee
+
+
+@click.group("dao", short_help="Create, manage or show state of DAOs", no_args_is_help=True)
+@click.pass_context
+def dao_cmd(ctx: click.Context) -> None:
+    pass
+
+
+# ----------------------------------------------------------------------------------------
+# ADD
+
+
+@dao_cmd.command("add", short_help="Create a wallet for an existing DAO", no_args_is_help=True)
+@click.option(
+    "-wp",
+    "--wallet-rpc-port",
+    help="Set the port where the Wallet is hosting the RPC interface. See the rpc_port under wallet in config.yaml",
+    type=int,
+    default=None,
+)
+@click.option("-f", "--fingerprint", help="Set the fingerprint to specify which key to use", type=int)
+@click.option("-n", "--name", help="Set the DAO wallet name", type=str)
+@click.option(
+    "-t",
+    "--treasury-id",
+    help="The Treasury ID of the DAO you want to track",
+    type=str,
+    required=True,
+)
+@click.option(
+    "-fa",
+    "--filter-amount",
+    help="The minimum number of votes a proposal needs before the wallet will recognise it",
+    type=int,
+    default=1,
+    show_default=True,
+)
+def dao_add_cmd(
+    wallet_rpc_port: Optional[int],
+    fingerprint: int,
+    treasury_id: str,
+    filter_amount: int,
+    name: Optional[str],
+) -> None:
+    import asyncio
+
+    from .dao_funcs import add_dao_wallet
+
+    extra_params = {
+        "name": name,
+        "treasury_id": treasury_id,
+        "filter_amount": filter_amount,
+    }
+    asyncio.run(execute_with_wallet(wallet_rpc_port, fingerprint, extra_params, add_dao_wallet))
+
+
+# ----------------------------------------------------------------------------------------
+# CREATE
+
+
+@dao_cmd.command("create", short_help="Create a new DAO wallet and treasury", no_args_is_help=True)
+@click.option(
+    "-wp",
+    "--wallet-rpc-port",
+    help="Set the port where the Wallet is hosting the RPC interface. See the rpc_port under wallet in config.yaml",
+    type=int,
+    default=None,
+)
+@click.option("-f", "--fingerprint", help="Set the fingerprint to specify which key to use", type=int)
+@click.option("-n", "--name", help="Set the DAO wallet name", type=str)
+@click.option(
+    "-pt",
+    "--proposal-timelock",
+    help="The minimum number of blocks before a proposal can close",
+    type=int,
+    default=1000,
+    show_default=True,
+)
+@click.option(
+    "-sc",
+    "--soft-close",
+    help="The number of blocks a proposal must remain unspent before closing",
+    type=int,
+    default=20,
+    show_default=True,
+)
+@click.option(
+    "-ar",
+    "--attendance-required",
+    help="The minimum number of votes a proposal must receive to be accepted",
+    type=int,
+    required=True,
+)
+@click.option(
+    "-pp",
+    "--pass-percentage",
+    help="The percentage of 'yes' votes in basis points a proposal must receive to be accepted. 100% = 10000",
+    type=int,
+    default=5000,
+    show_default=True,
+)
+@click.option(
+    "-sd",
+    "--self-destruct",
+    help="The number of blocks required before a proposal can be automatically removed",
+    type=int,
+    default=10000,
+    show_default=True,
+)
+@click.option(
+    "-od",
+    "--oracle-delay",
+    help="The number of blocks required between oracle spends of the treasury",
+    type=int,
+    default=50,
+    show_default=True,
+)
+@click.option(
+    "-fa",
+    "--filter-amount",
+    help="The minimum number of votes a proposal needs before the wallet will recognise it",
+    type=int,
+    default=1,
+    show_default=True,
+)
+@click.option(
+    "-ca",
+    "--cat-amount",
+    help="The number of DAO CATs (in mojos) to create when initializing the DAO",
+    type=int,
+    required=True,
+)
+@click.option(
+    "-m",
+    "--fee",
+    help="Set the fees per transaction, in XCH.",
+    type=str,
+    default="0",
+    show_default=True,
+    callback=validate_fee,
+)
+@click.option(
+    "--reuse",
+    help="Reuse existing address for the change.",
+    is_flag=True,
+    default=False,
+)
+def dao_create_cmd(
+    wallet_rpc_port: Optional[int],
+    fingerprint: int,
+    proposal_timelock: int,
+    soft_close: int,
+    attendance_required: int,
+    pass_percentage: int,
+    self_destruct: int,
+    oracle_delay: int,
+    filter_amount: int,
+    cat_amount: int,
+    name: Optional[str],
+    fee: str,
+    reuse: bool,
+) -> None:
+    import asyncio
+
+    from .dao_funcs import create_dao_wallet
+
+    print("Creating new DAO")
+
+    extra_params = {
+        "fee": fee,
+        "name": name,
+        "proposal_timelock": proposal_timelock,
+        "soft_close_length": soft_close,
+        "attendance_required": attendance_required,
+        "pass_percentage": pass_percentage,
+        "self_destruct_length": self_destruct,
+        "oracle_spend_delay": oracle_delay,
+        "filter_amount": filter_amount,
+        "amount_of_cats": cat_amount,
+        "reuse_puzhash": True if reuse else None,
+    }
+    asyncio.run(execute_with_wallet(wallet_rpc_port, fingerprint, extra_params, create_dao_wallet))
+
+
+# ----------------------------------------------------------------------------------------
+# TREASURY FUNDS
+
+
+@dao_cmd.command("add-funds", short_help="Send funds to a DAO treasury", no_args_is_help=True)
+@click.option(
+    "-wp",
+    "--wallet-rpc-port",
+    help="Set the port where the Wallet is hosting the RPC interface. See the rpc_port under wallet in config.yaml",
+    type=int,
+    default=None,
+)
+@click.option("-f", "--fingerprint", help="Set the fingerprint to specify which key to use", type=int)
+@click.option("-i", "--wallet-id", help="Id of the wallet to use", type=int, required=True)
+@click.option(
+    "-f",
+    "--funding-wallet-id",
+    help="The ID of the wallet to send funds from",
+    type=int,
+    required=True,
+)
+@click.option(
+    "-a",
+    "--amount",
+    help="The amount of funds to send",
+    type=str,
+    required=True,
+)
+@click.option(
+    "-m",
+    "--fee",
+    help="Set the fees per transaction, in XCH.",
+    type=str,
+    default="0",
+    show_default=True,
+    callback=validate_fee,
+)
+@click.option(
+    "--reuse",
+    help="Reuse existing address for the change.",
+    is_flag=True,
+    default=False,
+)
+def dao_add_funds_cmd(
+    wallet_rpc_port: Optional[int],
+    fingerprint: int,
+    wallet_id: int,
+    funding_wallet_id: int,
+    amount: str,
+    fee: str,
+    reuse: bool,
+) -> None:
+    import asyncio
+
+    from .dao_funcs import add_funds_to_treasury
+
+    extra_params = {
+        "wallet_id": wallet_id,
+        "fee": fee,
+        "funding_wallet_id": funding_wallet_id,
+        "amount": amount,
+        "reuse_puzhash": True if reuse else None,
+    }
+    asyncio.run(execute_with_wallet(wallet_rpc_port, fingerprint, extra_params, add_funds_to_treasury))
+
+
+@dao_cmd.command("get-balance", short_help="Get the asset balances for a DAO treasury", no_args_is_help=True)
+@click.option(
+    "-wp",
+    "--wallet-rpc-port",
+    help="Set the port where the Wallet is hosting the RPC interface. See the rpc_port under wallet in config.yaml",
+    type=int,
+    default=None,
+)
+@click.option("-f", "--fingerprint", help="Set the fingerprint to specify which key to use", type=int)
+@click.option("-i", "--wallet-id", help="Id of the wallet to use", type=int, required=True)
+def dao_get_balance_cmd(
+    wallet_rpc_port: Optional[int],
+    fingerprint: int,
+    wallet_id: int,
+) -> None:
+    import asyncio
+
+    from .dao_funcs import get_treasury_balance
+
+    extra_params = {
+        "wallet_id": wallet_id,
+    }
+    asyncio.run(execute_with_wallet(wallet_rpc_port, fingerprint, extra_params, get_treasury_balance))
+
+
+# ----------------------------------------------------------------------------------------
+# LIST/SHOW PROPOSALS
+
+
+@dao_cmd.command("list-proposals", short_help="List proposals for the DAO", no_args_is_help=True)
+@click.option(
+    "-wp",
+    "--wallet-rpc-port",
+    help="Set the port where the Wallet is hosting the RPC interface. See the rpc_port under wallet in config.yaml",
+    type=int,
+    default=None,
+)
+@click.option("-f", "--fingerprint", help="Set the fingerprint to specify which key to use", type=int)
+@click.option("-i", "--wallet-id", help="Id of the wallet to use", type=int, required=True)
+@click.option(
+    "-c",
+    "--include-closed",
+    help="Include previously closed proposals",
+    is_flag=True,
+)
+def dao_list_proposals_cmd(
+    wallet_rpc_port: Optional[int],
+    fingerprint: int,
+    wallet_id: int,
+    include_closed: Optional[bool],
+) -> None:
+    import asyncio
+
+    from .dao_funcs import list_proposals
+
+    if not include_closed:
+        include_closed = False
+
+    extra_params = {
+        "wallet_id": wallet_id,
+        "include_closed": include_closed,
+    }
+    asyncio.run(execute_with_wallet(wallet_rpc_port, fingerprint, extra_params, list_proposals))
+
+
+@dao_cmd.command("show-proposal", short_help="Show the details of a specific proposal", no_args_is_help=True)
+@click.option(
+    "-wp",
+    "--wallet-rpc-port",
+    help="Set the port where the Wallet is hosting the RPC interface. See the rpc_port under wallet in config.yaml",
+    type=int,
+    default=None,
+)
+@click.option("-f", "--fingerprint", help="Set the fingerprint to specify which key to use", type=int)
+@click.option("-i", "--wallet-id", help="Id of the wallet to use", type=int, required=True)
+@click.option(
+    "-p",
+    "--proposal_id",
+    help="The ID of the proposal to fetch",
+    type=str,
+    required=True,
+)
+def dao_show_proposal_cmd(
+    wallet_rpc_port: Optional[int],
+    fingerprint: int,
+    wallet_id: int,
+    proposal_id: str,
+) -> None:
+    import asyncio
+
+    from .dao_funcs import show_proposal
+
+    extra_params = {
+        "wallet_id": wallet_id,
+        "proposal_id": proposal_id,
+    }
+    asyncio.run(execute_with_wallet(wallet_rpc_port, fingerprint, extra_params, show_proposal))
+
+
+# ----------------------------------------------------------------------------------------
+# VOTE
+
+
+@dao_cmd.command("vote", short_help="Vote on a DAO proposal", no_args_is_help=True)
+@click.option(
+    "-wp",
+    "--wallet-rpc-port",
+    help="Set the port where the Wallet is hosting the RPC interface. See the rpc_port under wallet in config.yaml",
+    type=int,
+    default=None,
+)
+@click.option("-f", "--fingerprint", help="Set the fingerprint to specify which key to use", type=int)
+@click.option("-i", "--wallet-id", help="Id of the wallet to use", type=int, required=True)
+@click.option(
+    "-p",
+    "--proposal-id",
+    help="The ID of the proposal you are voting on",
+    type=str,
+    required=True,
+)
+@click.option(
+    "-a",
+    "--vote-amount",
+    help="The number of votes you want to cast",
+    type=int,
+    required=True,
+)
+@click.option(
+    "-n",
+    "--vote-no",
+    help="Use this option to vote against a proposal. If not present then the vote is for the proposal",
+    is_flag=True,
+)
+@click.option(
+    "-m",
+    "--fee",
+    help="Set the fees per transaction, in XCH.",
+    type=str,
+    default="0",
+    show_default=True,
+    callback=validate_fee,
+)
+@click.option(
+    "--reuse",
+    help="Reuse existing address for the change.",
+    is_flag=True,
+    default=False,
+)
+def dao_vote_cmd(
+    wallet_rpc_port: Optional[int],
+    fingerprint: int,
+    wallet_id: int,
+    proposal_id: str,
+    vote_amount: int,
+    vote_no: Optional[bool],
+    fee: str,
+    reuse: bool,
+) -> None:
+    import asyncio
+
+    from .dao_funcs import vote_on_proposal
+
+    is_yes_vote = False if vote_no else True
+
+    extra_params = {
+        "wallet_id": wallet_id,
+        "fee": fee,
+        "proposal_id": proposal_id,
+        "vote_amount": vote_amount,
+        "is_yes_vote": is_yes_vote,
+        "reuse_puzhash": True if reuse else None,
+    }
+    asyncio.run(execute_with_wallet(wallet_rpc_port, fingerprint, extra_params, vote_on_proposal))
+
+
+# ----------------------------------------------------------------------------------------
+# CLOSE PROPOSALS
+
+
+@dao_cmd.command("close-proposal", short_help="Close a DAO proposal", no_args_is_help=True)
+@click.option(
+    "-wp",
+    "--wallet-rpc-port",
+    help="Set the port where the Wallet is hosting the RPC interface. See the rpc_port under wallet in config.yaml",
+    type=int,
+    default=None,
+)
+@click.option("-f", "--fingerprint", help="Set the fingerprint to specify which key to use", type=int)
+@click.option("-i", "--wallet-id", help="Id of the wallet to use", type=int, required=True)
+@click.option(
+    "-p",
+    "--proposal-id",
+    help="The ID of the proposal you are voting on",
+    type=str,
+    required=True,
+)
+@click.option(
+    "-m",
+    "--fee",
+    help="Set the fees per transaction, in XCH.",
+    type=str,
+    default="0",
+    show_default=True,
+    callback=validate_fee,
+)
+@click.option(
+    "--reuse",
+    help="Reuse existing address for the change.",
+    is_flag=True,
+    default=False,
+)
+def dao_close_proposal_cmd(
+    wallet_rpc_port: Optional[int],
+    fingerprint: int,
+    wallet_id: int,
+    proposal_id: str,
+    fee: str,
+    reuse: bool,
+) -> None:
+    import asyncio
+
+    from .dao_funcs import close_proposal
+
+    extra_params = {
+        "wallet_id": wallet_id,
+        "fee": fee,
+        "proposal_id": proposal_id,
+        "reuse_puzhash": True if reuse else None,
+    }
+    asyncio.run(execute_with_wallet(wallet_rpc_port, fingerprint, extra_params, close_proposal))
+
+
+# ----------------------------------------------------------------------------------------
+# LOCKUP COINS
+
+
+@dao_cmd.command("lockup-coins", short_help="Lock DAO CATs for voting", no_args_is_help=True)
+@click.option(
+    "-wp",
+    "--wallet-rpc-port",
+    help="Set the port where the Wallet is hosting the RPC interface. See the rpc_port under wallet in config.yaml",
+    type=int,
+    default=None,
+)
+@click.option("-f", "--fingerprint", help="Set the fingerprint to specify which key to use", type=int)
+@click.option("-i", "--wallet-id", help="Id of the wallet to use", type=int, required=True)
+@click.option(
+    "-a",
+    "--amount",
+    help="The amount of new cats the proposal will mint",
+    type=str,
+    required=True,
+)
+@click.option(
+    "-m",
+    "--fee",
+    help="Set the fees per transaction, in XCH.",
+    type=str,
+    default="0",
+    show_default=True,
+    callback=validate_fee,
+)
+@click.option(
+    "--reuse",
+    help="Reuse existing address for the change.",
+    is_flag=True,
+    default=False,
+)
+def dao_lockup_coins_cmd(
+    wallet_rpc_port: Optional[int],
+    fingerprint: int,
+    wallet_id: int,
+    amount: str,
+    fee: str,
+    reuse: bool,
+) -> None:
+    import asyncio
+
+    from .dao_funcs import lockup_coins
+
+    extra_params = {
+        "wallet_id": wallet_id,
+        "fee": fee,
+        "amount": amount,
+        "reuse_puzhash": True if reuse else None,
+    }
+    asyncio.run(execute_with_wallet(wallet_rpc_port, fingerprint, extra_params, lockup_coins))
+
+
+@dao_cmd.command("release-coins", short_help="Release closed proposals from DAO CATs", no_args_is_help=True)
+@click.option(
+    "-wp",
+    "--wallet-rpc-port",
+    help="Set the port where the Wallet is hosting the RPC interface. See the rpc_port under wallet in config.yaml",
+    type=int,
+    default=None,
+)
+@click.option("-f", "--fingerprint", help="Set the fingerprint to specify which key to use", type=int)
+@click.option("-i", "--wallet-id", help="Id of the wallet to use", type=int, required=True)
+@click.option(
+    "-m",
+    "--fee",
+    help="Set the fees per transaction, in XCH.",
+    type=str,
+    default="0",
+    show_default=True,
+    callback=validate_fee,
+)
+@click.option(
+    "--reuse",
+    help="Reuse existing address for the change.",
+    is_flag=True,
+    default=False,
+)
+def dao_release_coins_cmd(
+    wallet_rpc_port: Optional[int],
+    fingerprint: int,
+    wallet_id: int,
+    fee: str,
+    reuse: bool,
+) -> None:
+    import asyncio
+
+    from .dao_funcs import release_coins
+
+    extra_params = {
+        "wallet_id": wallet_id,
+        "fee": fee,
+        "reuse_puzhash": True if reuse else None,
+    }
+    asyncio.run(execute_with_wallet(wallet_rpc_port, fingerprint, extra_params, release_coins))
+
+
+@dao_cmd.command("exit-lockup", short_help="Release DAO CATs from voting mode", no_args_is_help=True)
+@click.option(
+    "-wp",
+    "--wallet-rpc-port",
+    help="Set the port where the Wallet is hosting the RPC interface. See the rpc_port under wallet in config.yaml",
+    type=int,
+    default=None,
+)
+@click.option("-f", "--fingerprint", help="Set the fingerprint to specify which key to use", type=int)
+@click.option("-i", "--wallet-id", help="Id of the wallet to use", type=int, required=True)
+@click.option(
+    "-m",
+    "--fee",
+    help="Set the fees per transaction, in XCH.",
+    type=str,
+    default="0",
+    show_default=True,
+    callback=validate_fee,
+)
+@click.option(
+    "--reuse",
+    help="Reuse existing address for the change.",
+    is_flag=True,
+    default=False,
+)
+def dao_exit_lockup_cmd(
+    wallet_rpc_port: Optional[int],
+    fingerprint: int,
+    wallet_id: int,
+    fee: str,
+    reuse: bool,
+) -> None:
+    import asyncio
+
+    from .dao_funcs import exit_lockup
+
+    extra_params = {
+        "wallet_id": wallet_id,
+        "fee": fee,
+        "reuse_puzhash": True if reuse else None,
+    }
+    asyncio.run(execute_with_wallet(wallet_rpc_port, fingerprint, extra_params, exit_lockup))
+
+
+# ----------------------------------------------------------------------------------------
+# CREATE PROPOSALS
+
+
+@dao_cmd.group("create-proposal", short_help="Create and add a proposal to a DAO", no_args_is_help=True)
+@click.pass_context
+def dao_proposal(ctx: click.Context) -> None:
+    pass
+
+
+@dao_proposal.command("spend", short_help="Create a proposal to spend DAO funds", no_args_is_help=True)
+@click.option(
+    "-wp",
+    "--wallet-rpc-port",
+    help="Set the port where the Wallet is hosting the RPC interface. See the rpc_port under wallet in config.yaml",
+    type=int,
+    default=None,
+)
+@click.option("-f", "--fingerprint", help="Set the fingerprint to specify which key to use", type=int)
+@click.option("-i", "--wallet-id", help="Id of the wallet to use", type=int, required=True)
+@click.option(
+    "-t",
+    "--to-address",
+    help="The address the proposal will send funds to",
+    type=str,
+    required=False,
+    default=None,
+)
+@click.option(
+    "-a",
+    "--amount",
+    help="The amount of funds the proposal will send (in mojos)",
+    type=float,
+    required=False,
+    default=None,
+)
+@click.option(
+    "-v",
+    "--vote-amount",
+    help="The number of votes to add",
+    type=int,
+    required=True,
+)
+@click.option(
+    "-id",
+    "--asset-id",
+    help="The asset id of the funds the proposal will send. Leave blank for xch",
+    type=str,
+    required=False,
+    default=None,
+)
+@click.option(
+    "-j",
+    "--from-json",
+    help="Path to a json file containing a list of additions, for use in proposals with multiple spends",
+    type=str,
+    required=False,
+    default=None,
+)
+@click.option(
+    "-m",
+    "--fee",
+    help="Set the fees per transaction, in XCH.",
+    type=str,
+    default="0",
+    show_default=True,
+    callback=validate_fee,
+)
+@click.option(
+    "--reuse",
+    help="Reuse existing address for the change.",
+    is_flag=True,
+    default=False,
+)
+def dao_create_spend_proposal_cmd(
+    wallet_rpc_port: Optional[int],
+    fingerprint: int,
+    wallet_id: int,
+    vote_amount: int,
+    to_address: Optional[str],
+    amount: Optional[float],
+    asset_id: Optional[str],
+    from_json: Optional[str],
+    fee: str,
+    reuse: bool,
+) -> None:
+    import asyncio
+
+    from .dao_funcs import create_spend_proposal
+
+    extra_params = {
+        "wallet_id": wallet_id,
+        "fee": fee,
+        "vote_amount": vote_amount,
+        "to_address": to_address,
+        "amount": amount,
+        "asset_id": asset_id,
+        "from_json": from_json,
+        "reuse_puzhash": True if reuse else None,
+    }
+    asyncio.run(execute_with_wallet(wallet_rpc_port, fingerprint, extra_params, create_spend_proposal))
+
+
+@dao_proposal.command("update", short_help="Create a proposal to change the DAO rules", no_args_is_help=True)
+@click.option(
+    "-wp",
+    "--wallet-rpc-port",
+    help="Set the port where the Wallet is hosting the RPC interface. See the rpc_port under wallet in config.yaml",
+    type=int,
+    default=None,
+)
+@click.option("-f", "--fingerprint", help="Set the fingerprint to specify which key to use", type=int)
+@click.option("-i", "--wallet-id", help="Id of the wallet to use", type=int, required=True)
+@click.option(
+    "-v",
+    "--vote-amount",
+    help="The number of votes to add",
+    type=int,
+    required=True,
+)
+@click.option(
+    "-pt",
+    "--proposal-timelock",
+    help="The new minimum number of blocks before a proposal can close",
+    type=int,
+    default=None,
+    required=False,
+)
+@click.option(
+    "-sc",
+    "--soft-close",
+    help="The number of blocks a proposal must remain unspent before closing",
+    type=int,
+    default=None,
+    required=False,
+)
+@click.option(
+    "-ar",
+    "--attendance-required",
+    help="The minimum number of votes a proposal must receive to be accepted",
+    type=int,
+    default=None,
+    required=False,
+)
+@click.option(
+    "-pp",
+    "--pass-percentage",
+    help="The percentage of 'yes' votes in basis points a proposal must receive to be accepted. 100% = 10000",
+    type=int,
+    default=None,
+    required=False,
+)
+@click.option(
+    "-sd",
+    "--self-destruct",
+    help="The number of blocks required before a proposal can be automatically removed",
+    type=int,
+    default=None,
+    required=False,
+)
+@click.option(
+    "-od",
+    "--oracle-delay",
+    help="The number of blocks required between oracle spends of the treasury",
+    type=int,
+    default=None,
+    required=False,
+)
+@click.option(
+    "-m",
+    "--fee",
+    help="Set the fees per transaction, in XCH.",
+    type=str,
+    default="0",
+    show_default=True,
+    callback=validate_fee,
+)
+@click.option(
+    "--reuse",
+    help="Reuse existing address for the change.",
+    is_flag=True,
+    default=False,
+)
+def dao_create_update_proposal_cmd(
+    wallet_rpc_port: Optional[int],
+    fingerprint: int,
+    wallet_id: int,
+    vote_amount: int,
+    proposal_timelock: Optional[int],
+    soft_close: Optional[int],
+    attendance_required: Optional[int],
+    pass_percentage: Optional[int],
+    self_destruct: Optional[int],
+    oracle_delay: Optional[int],
+    fee: str,
+    reuse: bool,
+) -> None:
+    import asyncio
+
+    from .dao_funcs import create_update_proposal
+
+    extra_params = {
+        "wallet_id": wallet_id,
+        "fee": fee,
+        "vote_amount": vote_amount,
+        "proposal_timelock": proposal_timelock,
+        "soft_close_length": soft_close,
+        "attendance_required": attendance_required,
+        "pass_percentage": pass_percentage,
+        "self_destruct_length": self_destruct,
+        "oracle_spend_delay": oracle_delay,
+        "reuse_puzhash": True if reuse else None,
+    }
+    asyncio.run(execute_with_wallet(wallet_rpc_port, fingerprint, extra_params, create_update_proposal))
+
+
+@dao_proposal.command("mint", short_help="Create a proposal to mint new DAO CATs", no_args_is_help=True)
+@click.option(
+    "-wp",
+    "--wallet-rpc-port",
+    help="Set the port where the Wallet is hosting the RPC interface. See the rpc_port under wallet in config.yaml",
+    type=int,
+    default=None,
+)
+@click.option("-f", "--fingerprint", help="Set the fingerprint to specify which key to use", type=int)
+@click.option("-i", "--wallet-id", help="Id of the wallet to use", type=int, required=True)
+@click.option(
+    "-a",
+    "--amount",
+    help="The amount of new cats the proposal will mint (in mojos)",
+    type=int,
+    required=True,
+)
+@click.option(
+    "-t",
+    "--to-address",
+    help="The address new cats will be minted to",
+    type=str,
+    required=True,
+    default=None,
+)
+@click.option(
+    "-v",
+    "--vote-amount",
+    help="The number of votes to add",
+    type=int,
+    required=True,
+)
+@click.option(
+    "-m",
+    "--fee",
+    help="Set the fees per transaction, in XCH.",
+    type=str,
+    default="0",
+    show_default=True,
+    callback=validate_fee,
+)
+@click.option(
+    "--reuse",
+    help="Reuse existing address for the change.",
+    is_flag=True,
+    default=False,
+)
+def dao_create_mint_proposal_cmd(
+    wallet_rpc_port: Optional[int],
+    fingerprint: int,
+    wallet_id: int,
+    amount: int,
+    to_address: int,
+    vote_amount: int,
+    fee: str,
+    reuse: bool,
+) -> None:
+    import asyncio
+
+    from .dao_funcs import create_mint_proposal
+
+    extra_params = {
+        "wallet_id": wallet_id,
+        "fee": fee,
+        "amount": amount,
+        "cat_target_address": to_address,
+        "vote_amount": vote_amount,
+        "reuse_puzhash": True if reuse else None,
+    }
+    asyncio.run(execute_with_wallet(wallet_rpc_port, fingerprint, extra_params, create_mint_proposal))
+
+
+# ----------------------------------------------------------------------------------------
+
+dao_cmd.add_command(dao_add_cmd)
+dao_cmd.add_command(dao_create_cmd)
+dao_cmd.add_command(dao_add_funds_cmd)
+dao_cmd.add_command(dao_get_balance_cmd)
+dao_cmd.add_command(dao_list_proposals_cmd)
+dao_cmd.add_command(dao_show_proposal_cmd)
+dao_cmd.add_command(dao_vote_cmd)
+dao_cmd.add_command(dao_close_proposal_cmd)
+dao_cmd.add_command(dao_lockup_coins_cmd)
+dao_cmd.add_command(dao_exit_lockup_cmd)
+dao_cmd.add_command(dao_release_coins_cmd)
+dao_cmd.add_command(dao_proposal)
+
+
+# TODO: status: how many of your voting coins are locked away vs. spendable, etc.
diff --git a/chia/cmds/dao_funcs.py b/chia/cmds/dao_funcs.py
new file mode 100644
index 000000000..3a9144a5d
--- /dev/null
+++ b/chia/cmds/dao_funcs.py
@@ -0,0 +1,442 @@
+from __future__ import annotations
+
+import asyncio
+import time
+from decimal import Decimal
+from typing import Any, Dict
+
+from chia.cmds.cmds_util import transaction_status_msg, transaction_submitted_msg
+from chia.cmds.units import units
+from chia.cmds.wallet_funcs import get_mojo_per_unit, get_wallet_type
+from chia.rpc.wallet_rpc_client import WalletRpcClient
+from chia.server.start_wallet import SERVICE_NAME
+from chia.types.blockchain_format.sized_bytes import bytes32
+from chia.util.bech32m import encode_puzzle_hash
+from chia.util.config import load_config, selected_network_address_prefix
+from chia.util.default_root import DEFAULT_ROOT_PATH
+from chia.util.ints import uint64
+
+
+async def add_dao_wallet(args: Dict[str, Any], wallet_client: WalletRpcClient, fingerprint: int) -> None:
+    treasury_id = args["treasury_id"]
+    filter_amount = args["filter_amount"]
+    name = args["name"]
+
+    print(f"Adding wallet for DAO: {treasury_id}")
+    print("This may take awhile.")
+
+    res = await wallet_client.create_new_dao_wallet(
+        mode="existing",
+        dao_rules=None,
+        amount_of_cats=None,
+        treasury_id=treasury_id,
+        filter_amount=filter_amount,
+        name=name,
+    )
+
+    print("Successfully created DAO Wallet")
+    print("DAO Treasury ID: {treasury_id}".format(**res))
+    print("DAO Wallet ID: {wallet_id}".format(**res))
+    print("CAT Wallet ID: {cat_wallet_id}".format(**res))
+    print("DAOCAT Wallet ID: {dao_cat_wallet_id}".format(**res))
+
+
+async def create_dao_wallet(args: Dict[str, Any], wallet_client: WalletRpcClient, fingerprint: int) -> None:
+    dao_rules = {
+        "proposal_timelock": args["proposal_timelock"],
+        "soft_close_length": args["soft_close_length"],
+        "attendance_required": args["attendance_required"],
+        "pass_percentage": args["pass_percentage"],
+        "self_destruct_length": args["self_destruct_length"],
+        "oracle_spend_delay": args["oracle_spend_delay"],
+    }
+    amount_of_cats = args["amount_of_cats"]
+    filter_amount = args["filter_amount"]
+    name = args["name"]
+    reuse_puzhash = args["reuse_puzhash"]
+
+    fee = Decimal(args["fee"])
+    final_fee: uint64 = uint64(int(fee * units["chia"]))
+
+    res = await wallet_client.create_new_dao_wallet(
+        mode="new",
+        dao_rules=dao_rules,
+        amount_of_cats=amount_of_cats,
+        treasury_id=None,
+        filter_amount=filter_amount,
+        name=name,
+        fee=final_fee,
+        reuse_puzhash=reuse_puzhash,
+    )
+
+    print("Successfully created DAO Wallet")
+    print("DAO Treasury ID: {treasury_id}".format(**res))
+    print("DAO Wallet ID: {wallet_id}".format(**res))
+    print("CAT Wallet ID: {cat_wallet_id}".format(**res))
+    print("DAOCAT Wallet ID: {dao_cat_wallet_id}".format(**res))
+
+
+async def add_funds_to_treasury(args: Dict[str, Any], wallet_client: WalletRpcClient, fingerprint: int) -> None:
+    wallet_id = args["wallet_id"]
+    funding_wallet_id = args["funding_wallet_id"]
+    amount = Decimal(args["amount"])
+    reuse_puzhash = args["reuse_puzhash"]
+
+    try:
+        typ = await get_wallet_type(wallet_id=funding_wallet_id, wallet_client=wallet_client)
+        mojo_per_unit = get_mojo_per_unit(typ)
+    except LookupError:
+        print(f"Wallet id: {wallet_id} not found.")
+        return
+
+    fee = Decimal(args["fee"])
+    final_fee: uint64 = uint64(int(fee * units["chia"]))
+    final_amount: uint64 = uint64(int(amount * mojo_per_unit))
+
+    res = await wallet_client.dao_add_funds_to_treasury(
+        wallet_id=wallet_id,
+        funding_wallet_id=funding_wallet_id,
+        amount=final_amount,
+        fee=final_fee,
+        reuse_puzhash=reuse_puzhash,
+    )
+
+    tx_id = res["tx_id"]
+    start = time.time()
+    while time.time() - start < 10:
+        await asyncio.sleep(0.1)
+        tx = await wallet_client.get_transaction(wallet_id, bytes32.from_hexstr(tx_id))
+        if len(tx.sent_to) > 0:
+            print(transaction_submitted_msg(tx))
+            print(transaction_status_msg(fingerprint, tx_id))
+            return None
+
+    print("Transaction not yet submitted to nodes")
+    print(f"To get status, use command: chia wallet get_transaction -f {fingerprint} -tx 0x{tx_id}")
+
+
+async def get_treasury_balance(args: Dict[str, Any], wallet_client: WalletRpcClient, fingerprint: int) -> None:
+    wallet_id = args["wallet_id"]
+
+    res = await wallet_client.dao_get_treasury_balance(wallet_id=wallet_id)
+    balances = res["balances"]
+
+    if not balances:
+        print("The DAO treasury currently has no funds")
+        return None
+
+    for asset_id, balance in balances.items():
+        if asset_id == "null":
+            print(f"XCH: {balance}")
+        else:
+            print(f"{asset_id}: {balance}")
+
+
+async def list_proposals(args: Dict[str, Any], wallet_client: WalletRpcClient, fingerprint: int) -> None:
+    wallet_id = args["wallet_id"]
+
+    res = await wallet_client.dao_get_proposals(wallet_id=wallet_id)
+    proposals = res["proposals"]
+    lockup_time = res["lockup_time"]
+    soft_close_length = res["soft_close_length"]
+    print("############################")
+    for prop in proposals:
+        print("Proposal ID: {proposal_id}".format(**prop))
+        prop_status = "CLOSED" if prop["closed"] else "OPEN"
+        print(f"Status: {prop_status}")
+        print("Votes for: {yes_votes}".format(**prop))
+        votes_against = prop["amount_voted"] - prop["yes_votes"]
+        print(f"Votes against: {votes_against}")
+        close_height = prop["singleton_block_height"] - lockup_time
+        print(f"Closable at block height: {close_height}")
+        print("------------------------")
+    print(f"Proposals have {soft_close_length} blocks of soft close time.")
+    print("############################")
+
+
+async def show_proposal(args: Dict[str, Any], wallet_client: WalletRpcClient, fingerprint: int) -> None:
+    wallet_id = args["wallet_id"]
+    proposal_id = args["proposal_id"]
+    res = await wallet_client.dao_parse_proposal(wallet_id, proposal_id)
+    pd = res["proposal_dictionary"]
+
+    blocks_needed = pd["state"]["blocks_needed"]
+    passed = pd["state"]["passed"]
+    closable = pd["state"]["closable"]
+    status = "CLOSED" if pd["state"]["closed"] else "OPEN"
+    votes_needed = pd["state"]["total_votes_needed"]
+    yes_needed = pd["state"]["yes_votes_needed"]
+
+    ptype = pd["proposal_type"]
+    if (ptype == "spend") and ("mint_amount" in pd):
+        ptype = "mint"
+
+    print("")
+    print(f"Details of Proposal: {proposal_id}")
+    print("---------------------------")
+    print("")
+    print(f"Type: {ptype.upper()}")
+    print(f"Status: {status}")
+    print(f"Passed: {passed}")
+    if not passed:
+        print(f"Yes votes needed: {yes_needed}")
+
+    if not pd["state"]["closed"]:
+        print(f"Closable: {closable}")
+        if not closable:
+            print(f"Total votes needed: {votes_needed}")
+            print(f"Blocks remaining: {blocks_needed}")
+
+    if ptype == "spend":
+        xch_conds = pd["xch_conditions"]
+        asset_conds = pd["asset_conditions"]
+        print("")
+        if xch_conds:
+            print("Proposal XCH Conditions")
+            for pmt in xch_conds:
+                print("{puzzle_hash} {amount}".format(**pmt))
+        if asset_conds:
+            print("Proposal asset Conditions")
+            for asset_id, conds in asset_conds:
+                print(f"Asset ID: {asset_id}")
+                for pmt in conds:
+                    print("{puzzle_hash} {amount}".format(**pmt))
+
+    elif ptype == "update":
+        print("")
+        print("Proposed Rules:")
+        for key, val in pd["dao_rules"].items():
+            print(f"{key}: {val}")
+
+    elif ptype == "mint":
+        mint_amount = pd["mint_amount"]
+        config = load_config(DEFAULT_ROOT_PATH, "config.yaml", SERVICE_NAME)
+        prefix = selected_network_address_prefix(config)
+        address = encode_puzzle_hash(bytes32.from_hexstr(pd["new_cat_puzhash"]), prefix)
+        print("")
+        print(f"Amount of CAT to mint: {mint_amount}")
+        print(f"Address: {address}")
+
+
+async def vote_on_proposal(args: Dict[str, Any], wallet_client: WalletRpcClient, fingerprint: int) -> None:
+    wallet_id = args["wallet_id"]
+    vote_amount = args["vote_amount"]
+    fee = args["fee"]
+    final_fee: uint64 = uint64(int(Decimal(fee) * units["chia"]))
+    proposal_id = args["proposal_id"]
+    is_yes_vote = args["is_yes_vote"]
+    reuse_puzhash = args["reuse_puzhash"]
+    # wallet_id: int, proposal_id: str, vote_amount: uint64, is_yes_vote: bool = True, fee: uint64 = uint64(0)
+    res = await wallet_client.dao_vote_on_proposal(
+        wallet_id=wallet_id,
+        proposal_id=proposal_id,
+        vote_amount=vote_amount,
+        is_yes_vote=is_yes_vote,
+        fee=final_fee,
+        reuse_puzhash=reuse_puzhash,
+    )
+    spend_bundle = res["spend_bundle"]
+    if res["success"]:
+        print(f"Submitted spend bundle with name: {spend_bundle.name()}")
+    else:
+        print("Unable to generate vote transaction.")
+
+
+async def close_proposal(args: Dict[str, Any], wallet_client: WalletRpcClient, fingerprint: int) -> None:
+    wallet_id = args["wallet_id"]
+    fee = args["fee"]
+    final_fee: uint64 = uint64(int(Decimal(fee) * units["chia"]))
+    proposal_id = args["proposal_id"]
+    reuse_puzhash = args["reuse_puzhash"]
+    res = await wallet_client.dao_close_proposal(
+        wallet_id=wallet_id,
+        proposal_id=proposal_id,
+        fee=final_fee,
+        reuse_puzhash=reuse_puzhash,
+    )
+    # dao_close_proposal(self, wallet_id: int, proposal_id: str, fee: uint64 = uint64(0))
+    if res["success"]:
+        name = res["tx_id"]
+        print(f"Submitted proposal close transaction with name: {name}")
+    else:
+        print("Unable to generate close transaction.")
+
+
+async def lockup_coins(args: Dict[str, Any], wallet_client: WalletRpcClient, fingerprint: int) -> None:
+    wallet_id = args["wallet_id"]
+    amount = args["amount"]
+    final_amount: uint64 = uint64(int(Decimal(amount) * units["cat"]))
+    fee = args["fee"]
+    final_fee: uint64 = uint64(int(Decimal(fee) * units["chia"]))
+    reuse_puzhash = args["reuse_puzhash"]
+    # typ = await get_wallet_type(wallet_id=wallet_id, wallet_client=wallet_client)
+    res = await wallet_client.dao_send_to_lockup(
+        wallet_id=wallet_id,
+        amount=final_amount,
+        fee=final_fee,
+        reuse_puzhash=reuse_puzhash,
+    )
+    tx_id = res["tx_id"]
+    start = time.time()
+    while time.time() - start < 10:
+        await asyncio.sleep(0.1)
+        tx = await wallet_client.get_transaction(wallet_id, bytes32.from_hexstr(tx_id))
+        if len(tx.sent_to) > 0:
+            print(transaction_submitted_msg(tx))
+            print(transaction_status_msg(fingerprint, tx_id))
+            return None
+
+    print("Transaction not yet submitted to nodes")
+
+
+async def release_coins(args: Dict[str, Any], wallet_client: WalletRpcClient, fingerprint: int) -> None:
+    wallet_id = args["wallet_id"]
+    fee = args["fee"]
+    final_fee: uint64 = uint64(int(Decimal(fee) * units["chia"]))
+    reuse_puzhash = args["reuse_puzhash"]
+    res = await wallet_client.dao_free_coins_from_finished_proposals(
+        wallet_id=wallet_id,
+        fee=final_fee,
+        reuse_puzhash=reuse_puzhash,
+    )
+    if res["success"]:
+        print("Transaction submitted.")
+    else:
+        print("Transaction failed.")
+
+
+async def exit_lockup(args: Dict[str, Any], wallet_client: WalletRpcClient, fingerprint: int) -> None:
+    wallet_id = args["wallet_id"]
+    fee = args["fee"]
+    final_fee: uint64 = uint64(int(Decimal(fee) * units["chia"]))
+    reuse_puzhash = args["reuse_puzhash"]
+    res = await wallet_client.dao_exit_lockup(
+        wallet_id=wallet_id,
+        coins=[],
+        fee=final_fee,
+        reuse_puzhash=reuse_puzhash,
+    )
+    if res["success"]:
+        print("Transaction submitted.")
+    else:
+        print("Transaction failed.")
+
+
+async def create_spend_proposal(args: Dict[str, Any], wallet_client: WalletRpcClient, fingerprint: int) -> None:
+    wallet_id = args["wallet_id"]
+    fee = args["fee"]
+    final_fee: uint64 = uint64(int(Decimal(fee) * units["chia"]))
+    reuse_puzhash = args["reuse_puzhash"]
+
+    if "to_address" in args:
+        address = args["to_address"]
+    else:
+        address = None
+    if "amount" in args:
+        amount = args["amount"]
+    else:
+        amount = None
+    if "from_json" in args:
+        additions = args["from_json"]
+    else:
+        additions = None
+    if additions is None and (address is None or amount is None):
+        print("ERROR: Must include a json specification or an address / amount pair.")
+    if "vote_amount" in args:
+        vote_amount = args["vote_amount"]
+    else:
+        vote_amount = None
+    res = await wallet_client.dao_create_proposal(
+        wallet_id=wallet_id,
+        proposal_type="spend",
+        additions=additions,
+        amount=amount,
+        inner_address=address,
+        vote_amount=vote_amount,
+        fee=final_fee,
+        reuse_puzhash=reuse_puzhash,
+    )
+    if res["success"]:
+        print("Successfully created proposal.")
+    else:
+        print("Failed to create proposal.")
+
+
+async def create_update_proposal(args: Dict[str, Any], wallet_client: WalletRpcClient, fingerprint: int) -> None:
+    wallet_id = args["wallet_id"]
+    fee = Decimal(args["fee"])
+    final_fee: uint64 = uint64(int(fee * units["chia"]))
+    reuse_puzhash = args["reuse_puzhash"]
+    if "proposal_timelock" in args:
+        proposal_timelock = args["proposal_timelock"]
+    else:
+        proposal_timelock = None
+    if "soft_close_length" in args:
+        soft_close_length = args["soft_close_length"]
+    else:
+        soft_close_length = None
+    if "attendance_required" in args:
+        attendance_required = args["attendance_required"]
+    else:
+        attendance_required = None
+    if "pass_percentage" in args:
+        pass_percentage = args["pass_percentage"]
+    else:
+        pass_percentage = None
+    if "self_destruct_length" in args:
+        self_destruct_length = args["self_destruct_length"]
+    else:
+        self_destruct_length = None
+    if "oracle_spend_delay" in args:
+        oracle_spend_delay = args["oracle_spend_delay"]
+    else:
+        oracle_spend_delay = None
+    if "vote_amount" in args:
+        vote_amount = args["vote_amount"]
+    else:
+        vote_amount = None
+    new_dao_rules = {
+        "proposal_timelock": proposal_timelock,
+        "soft_close_length": soft_close_length,
+        "attendance_required": attendance_required,
+        "pass_percentage": pass_percentage,
+        "self_destruct_length": self_destruct_length,
+        "oracle_spend_delay": oracle_spend_delay,
+    }
+    res = await wallet_client.dao_create_proposal(
+        wallet_id=wallet_id,
+        proposal_type="update",
+        new_dao_rules=new_dao_rules,
+        vote_amount=vote_amount,
+        fee=final_fee,
+        reuse_puzhash=reuse_puzhash,
+    )
+    if res["success"]:
+        print("Successfully created proposal.")
+    else:
+        print("Failed to create proposal.")
+
+
+async def create_mint_proposal(args: Dict[str, Any], wallet_client: WalletRpcClient, fingerprint: int) -> None:
+    wallet_id = args["wallet_id"]
+    fee = args["fee"]
+    final_fee: uint64 = uint64(int(Decimal(fee) * units["chia"]))
+    reuse_puzhash = args["reuse_puzhash"]
+    cat_target_address = args["cat_target_address"]
+    amount = args["amount"]
+    vote_amount = None
+    if "vote_amount" in args:
+        vote_amount = args["vote_amount"]
+    res = await wallet_client.dao_create_proposal(
+        wallet_id=wallet_id,
+        proposal_type="mint",
+        cat_target_address=cat_target_address,
+        amount=amount,
+        vote_amount=vote_amount,
+        fee=final_fee,
+        reuse_puzhash=reuse_puzhash,
+    )
+    if res["success"]:
+        print("Successfully created proposal.")
+    else:
+        print("Failed to create proposal.")
diff --git a/chia/full_node/coin_store.py b/chia/full_node/coin_store.py
index f90b8578d..751bec9e4 100644
--- a/chia/full_node/coin_store.py
+++ b/chia/full_node/coin_store.py
@@ -432,7 +432,6 @@ class CoinStore:
         coin_ids: Set[bytes32],
         min_height: uint32 = uint32(0),
         *,
-        max_height: uint32 = uint32(uint32.MAXIMUM_EXCLUSIVE - 1),
         max_items: int = 50000,
     ) -> List[CoinState]:
         if len(coin_ids) == 0:
@@ -446,15 +445,10 @@ class CoinStore:
                     coin_ids_db = tuple(batch.entries)
                 else:
                     coin_ids_db = tuple([pid.hex() for pid in batch.entries])
-
-                max_height_sql = ""
-                if max_height != uint32.MAXIMUM_EXCLUSIVE - 1:
-                    max_height_sql = f"AND confirmed_index<={max_height} AND spent_index<={max_height}"
-
                 async with conn.execute(
                     f"SELECT confirmed_index, spent_index, coinbase, puzzle_hash, coin_parent, amount, timestamp "
                     f'FROM coin_record WHERE coin_name in ({"?," * (len(batch.entries) - 1)}?) '
-                    f"AND (confirmed_index>=? OR spent_index>=?) {max_height_sql}"
+                    f"AND (confirmed_index>=? OR spent_index>=?)"
                     f"{'' if include_spent_coins else 'AND spent_index=0'}"
                     " LIMIT ?",
                     coin_ids_db + (min_height, min_height, max_items - len(coins)),
diff --git a/chia/pools/pool_puzzles.py b/chia/pools/pool_puzzles.py
index 6d5705ddc..94876a0f7 100644
--- a/chia/pools/pool_puzzles.py
+++ b/chia/pools/pool_puzzles.py
@@ -14,10 +14,11 @@ from chia.types.blockchain_format.coin import Coin
 from chia.types.blockchain_format.program import Program
 from chia.types.blockchain_format.serialized_program import SerializedProgram
 from chia.types.blockchain_format.sized_bytes import bytes32
-from chia.types.coin_spend import CoinSpend, compute_additions
+from chia.types.coin_spend import CoinSpend
 from chia.util.ints import uint32, uint64
 from chia.wallet.puzzles.load_clvm import load_clvm_maybe_recompile
 from chia.wallet.puzzles.singleton_top_layer import puzzle_for_singleton
+from chia.wallet.singleton import get_most_recent_singleton_coin_from_coin_spend
 
 log = logging.getLogger(__name__)
 # "Full" is the outer singleton, with the inner puzzle filled in
@@ -282,14 +283,6 @@ def create_absorb_spend(
     return coin_spends
 
 
-def get_most_recent_singleton_coin_from_coin_spend(coin_sol: CoinSpend) -> Optional[Coin]:
-    additions: List[Coin] = compute_additions(coin_sol)
-    for coin in additions:
-        if coin.amount % 2 == 1:
-            return coin
-    return None
-
-
 def get_pubkey_from_member_inner_puzzle(inner_puzzle: Program) -> G1Element:
     args = uncurry_pool_member_inner_puzzle(inner_puzzle)
     if args is not None:
diff --git a/chia/pools/pool_wallet.py b/chia/pools/pool_wallet.py
index 052fd2291..1ae412f46 100644
--- a/chia/pools/pool_wallet.py
+++ b/chia/pools/pool_wallet.py
@@ -17,7 +17,6 @@ from chia.pools.pool_puzzles import (
     create_travel_spend,
     create_waiting_room_inner_puzzle,
     get_delayed_puz_info_from_launcher_spend,
-    get_most_recent_singleton_coin_from_coin_spend,
     is_pool_member_inner_puzzle,
     is_pool_waitingroom_inner_puzzle,
     launcher_id_to_p2_puzzle_hash,
@@ -48,6 +47,7 @@ from chia.types.spend_bundle import SpendBundle
 from chia.util.ints import uint32, uint64, uint128
 from chia.wallet.derive_keys import find_owner_sk
 from chia.wallet.sign_coin_spends import sign_coin_spends
+from chia.wallet.singleton import get_most_recent_singleton_coin_from_coin_spend
 from chia.wallet.transaction_record import TransactionRecord
 from chia.wallet.util.transaction_type import TransactionType
 from chia.wallet.util.wallet_types import WalletType
@@ -263,8 +263,8 @@ class PoolWallet:
     async def apply_state_transition(self, new_state: CoinSpend, block_height: uint32) -> bool:
         """
         Updates the Pool state (including DB) with new singleton spends.
-        The DB must be committed after calling this method. All validation should be done here. Returns True iff
-        the spend is a valid transition spend for the singleton, False otherwise.
+        The DB must be committed after calling this method. All validation should be done here.
+        Returns True iff the spend is a valid transition spend for the singleton, False otherwise.
         """
         tip: Tuple[uint32, CoinSpend] = await self.get_tip()
         tip_spend = tip[1]
diff --git a/chia/rpc/wallet_rpc_api.py b/chia/rpc/wallet_rpc_api.py
index 5e82fe3a4..557752b45 100644
--- a/chia/rpc/wallet_rpc_api.py
+++ b/chia/rpc/wallet_rpc_api.py
@@ -39,6 +39,11 @@ from chia.util.streamable import Streamable, streamable
 from chia.util.ws_message import WsRpcMessage, create_payload_dict
 from chia.wallet.cat_wallet.cat_constants import DEFAULT_CATS
 from chia.wallet.cat_wallet.cat_wallet import CATWallet
+from chia.wallet.cat_wallet.dao_cat_info import LockedCoinInfo
+from chia.wallet.cat_wallet.dao_cat_wallet import DAOCATWallet
+from chia.wallet.dao_wallet.dao_info import DAORules
+from chia.wallet.dao_wallet.dao_utils import get_treasury_rules_from_puzzle
+from chia.wallet.dao_wallet.dao_wallet import DAOWallet
 from chia.wallet.derive_keys import (
     MAX_POOL_WALLETS,
     master_sk_to_farmer_sk,
@@ -51,9 +56,9 @@ from chia.wallet.did_wallet.did_info import DIDInfo
 from chia.wallet.did_wallet.did_wallet import DIDWallet
 from chia.wallet.did_wallet.did_wallet_puzzles import (
     DID_INNERPUZ_MOD,
+    did_program_to_metadata,
     match_did_puzzle,
     metadata_to_program,
-    program_to_metadata,
 )
 from chia.wallet.nft_wallet import nft_puzzles
 from chia.wallet.nft_wallet.nft_info import NFTCoinInfo, NFTInfo
@@ -194,6 +199,19 @@ class WalletRpcApi:
             "/did_message_spend": self.did_message_spend,
             "/did_get_info": self.did_get_info,
             "/did_find_lost_did": self.did_find_lost_did,
+            # DAO Wallets
+            "/dao_get_proposals": self.dao_get_proposals,
+            "/dao_create_proposal": self.dao_create_proposal,
+            "/dao_parse_proposal": self.dao_parse_proposal,
+            "/dao_vote_on_proposal": self.dao_vote_on_proposal,
+            "/dao_get_treasury_balance": self.dao_get_treasury_balance,
+            "/dao_close_proposal": self.dao_close_proposal,
+            "/dao_exit_lockup": self.dao_exit_lockup,
+            "/dao_adjust_filter_level": self.dao_adjust_filter_level,
+            "/dao_add_funds_to_treasury": self.dao_add_funds_to_treasury,
+            "/dao_send_to_lockup": self.dao_send_to_lockup,
+            "/dao_get_proposal_state": self.dao_get_proposal_state,
+            "/dao_free_coins_from_finished_proposals": self.dao_free_coins_from_finished_proposals,
             # NFT Wallet
             "/nft_mint_nft": self.nft_mint_nft,
             "/nft_count_nfts": self.nft_count_nfts,
@@ -713,6 +731,42 @@ class WalletRpcApi:
                 }
             else:  # undefined did_type
                 pass
+        elif request["wallet_type"] == "dao_wallet":
+            name = None
+            if request["name"]:
+                name = request["name"]
+            if request["mode"] == "new":
+                if request["dao_rules"]:
+                    dao_rules = DAORules.from_json_dict(request["dao_rules"])
+                else:
+                    raise ValueError("DAO rules must be specified for wallet creation")
+                async with self.service.wallet_state_manager.lock:
+                    dao_wallet = await DAOWallet.create_new_dao_and_wallet(
+                        wallet_state_manager,
+                        main_wallet,
+                        uint64(request["amount_of_cats"]),
+                        dao_rules,
+                        uint64(request["filter_amount"]),
+                        name,
+                        uint64(request.get("fee", 0)),
+                    )
+            elif request["mode"] == "existing":
+                # async with self.service.wallet_state_manager.lock:
+                dao_wallet = await DAOWallet.create_new_dao_wallet_for_existing_dao(
+                    wallet_state_manager,
+                    main_wallet,
+                    bytes32.from_hexstr(request["treasury_id"]),
+                    uint64(request["filter_amount"]),
+                    name,
+                )
+            return {
+                "success": True,
+                "type": dao_wallet.type(),
+                "wallet_id": dao_wallet.id(),
+                "treasury_id": dao_wallet.dao_info.treasury_id,
+                "cat_wallet_id": dao_wallet.dao_info.cat_wallet_id,
+                "dao_cat_wallet_id": dao_wallet.dao_info.dao_cat_wallet_id,
+            }
         elif request["wallet_type"] == "nft_wallet":
             for wallet in self.service.wallet_state_manager.wallets.values():
                 did_id: Optional[bytes32] = None
@@ -904,7 +958,7 @@ class WalletRpcApi:
             try:
                 tx = (await self._convert_tx_puzzle_hash(tr)).to_json_dict_convenience(self.service.config)
                 tx_list.append(tx)
-                if tx["type"] not in clawback_types:
+                if tx["type"] not in clawback_types or tx["spend_bundle"] is None:
                     continue
                 coin: Coin = tr.additions[0]
                 record: Optional[WalletCoinRecord] = await self.service.wallet_state_manager.coin_store.get_coin_record(
@@ -1561,7 +1615,7 @@ class WalletRpcApi:
                 )
         if hold_lock:
             async with self.service.wallet_state_manager.lock:
-                txs: List[TransactionRecord] = await wallet.generate_signed_transaction(
+                txs: List[TransactionRecord] = await wallet.generate_signed_transactions(
                     amounts,
                     puzzle_hashes,
                     fee,
@@ -1577,7 +1631,7 @@ class WalletRpcApi:
                 for tx in txs:
                     await wallet.standard_wallet.push_transaction(tx)
         else:
-            txs = await wallet.generate_signed_transaction(
+            txs = await wallet.generate_signed_transactions(
                 amounts,
                 puzzle_hashes,
                 fee,
@@ -1945,7 +1999,7 @@ class WalletRpcApi:
             "public_key": public_key.atom.hex(),
             "recovery_list_hash": recovery_list_hash.atom.hex(),
             "num_verification": num_verification.as_int(),
-            "metadata": program_to_metadata(metadata),
+            "metadata": did_program_to_metadata(metadata),
             "launcher_id": singleton_struct.rest().first().atom.hex(),
             "full_puzzle": full_puzzle,
             "solution": Program.from_bytes(bytes(coin_spend.solution)).as_python(),
@@ -2116,7 +2170,7 @@ class WalletRpcApi:
                         None,
                         None,
                         False,
-                        json.dumps(did_wallet_puzzles.program_to_metadata(metadata)),
+                        json.dumps(did_wallet_puzzles.did_program_to_metadata(metadata)),
                     )
                     await did_wallet.save_info(did_info)
                     await self.service.wallet_state_manager.update_wallet_puzzle_hashes(did_wallet.wallet_info.id)
@@ -2322,6 +2376,241 @@ class WalletRpcApi:
             "transaction_id": txs.name,
         }
 
+    ##########################################################################################
+    # DAO Wallet
+    ##########################################################################################
+
+    async def dao_adjust_filter_level(self, request) -> EndpointResult:
+        wallet_id = uint32(request["wallet_id"])
+        dao_wallet = self.service.wallet_state_manager.get_wallet(id=wallet_id, required_type=DAOWallet)
+        await dao_wallet.adjust_filter_level(uint64(request["filter_level"]))
+        return {
+            "success": True,
+            "dao_info": dao_wallet.dao_info,
+        }
+
+    async def dao_add_funds_to_treasury(self, request) -> EndpointResult:
+        wallet_id = uint32(request["wallet_id"])
+        dao_wallet = self.service.wallet_state_manager.get_wallet(id=wallet_id, required_type=DAOWallet)
+        funding_wallet_id = uint32(request["funding_wallet_id"])
+        wallet_type = self.service.wallet_state_manager.wallets[funding_wallet_id].type()
+        if wallet_type not in [WalletType.STANDARD_WALLET, WalletType.CAT]:
+            raise ValueError(f"Cannot fund a treasury with assets from a {wallet_type.name} wallet")
+        funding_tx = await dao_wallet.create_add_money_to_treasury_spend(
+            amount=uint64(request.get("amount")),
+            fee=uint64(request.get("fee", 0)),
+            funding_wallet_id=funding_wallet_id,
+            reuse_puzhash=request.get("reuse_puzhash", None),
+        )
+        return {"success": True, "tx_id": funding_tx.name}
+
+    async def dao_get_treasury_balance(self, request) -> EndpointResult:
+        wallet_id = uint32(request["wallet_id"])
+        dao_wallet = self.service.wallet_state_manager.get_wallet(id=wallet_id, required_type=DAOWallet)
+        assert dao_wallet is not None
+        asset_list = dao_wallet.dao_info.assets
+        balances = {}
+        for asset_id in asset_list:
+            balance = await dao_wallet.get_balance_by_asset_type(asset_id=asset_id)
+            balances[asset_id] = balance
+        return {"success": True, "balances": balances}
+
+    async def dao_send_to_lockup(self, request) -> EndpointResult:
+        wallet_id = uint32(request["wallet_id"])
+        dao_wallet = self.service.wallet_state_manager.get_wallet(id=wallet_id, required_type=DAOWallet)
+        dao_cat_wallet = self.service.wallet_state_manager.get_wallet(
+            id=dao_wallet.dao_info.dao_cat_wallet_id, required_type=DAOCATWallet
+        )
+        amount = uint64(request["amount"])
+        fee = uint64(request.get("fee", 0))
+        txs, _ = await dao_cat_wallet.create_new_dao_cats(
+            amount,
+            push=True,
+            fee=fee,
+            reuse_puzhash=request.get("reuse_puzhash", None),
+        )
+        return {
+            "success": True,
+            "tx_id": txs[0].name,
+        }
+
+    async def dao_get_proposals(self, request) -> EndpointResult:
+        wallet_id = uint32(request["wallet_id"])
+        dao_wallet = self.service.wallet_state_manager.get_wallet(id=wallet_id, required_type=DAOWallet)
+        assert dao_wallet is not None
+        proposal_list = dao_wallet.dao_info.proposals_list
+        dao_rules = get_treasury_rules_from_puzzle(dao_wallet.dao_info.current_treasury_innerpuz)
+        return {
+            "success": True,
+            "proposals": proposal_list,
+            "lockup_time": dao_rules.proposal_timelock,
+            "soft_close_length": dao_rules.soft_close_length,
+        }
+
+    async def dao_get_proposal_state(self, request) -> EndpointResult:
+        wallet_id = uint32(request["wallet_id"])
+        dao_wallet = self.service.wallet_state_manager.get_wallet(id=wallet_id, required_type=DAOWallet)
+        assert dao_wallet is not None
+        state = await dao_wallet.get_proposal_state(bytes32.from_hexstr(request["proposal_id"]))
+        return {"success": True, "state": state}
+
+    async def dao_exit_lockup(self, request) -> EndpointResult:
+        wallet_id = uint32(request["wallet_id"])
+        dao_wallet = self.service.wallet_state_manager.get_wallet(id=wallet_id, required_type=DAOWallet)
+        assert dao_wallet is not None
+        dao_cat_wallet = self.service.wallet_state_manager.get_wallet(
+            id=dao_wallet.dao_info.dao_cat_wallet_id, required_type=DAOCATWallet
+        )
+        assert dao_cat_wallet is not None
+        if request["coins"]:
+            coin_list = [Coin.from_json_dict(coin) for coin in request["coins"]]
+            coins: List[LockedCoinInfo] = []
+            for lci in dao_cat_wallet.dao_cat_info.locked_coins:
+                if lci.coin in coin_list:
+                    coins.append(lci)
+        else:
+            coins = []
+            for lci in dao_cat_wallet.dao_cat_info.locked_coins:
+                if lci.active_votes == []:
+                    coins.append(lci)
+        fee = uint64(request.get("fee", 0))
+        tx = await dao_cat_wallet.exit_vote_state(
+            coins,
+            fee=fee,
+            reuse_puzhash=request.get("reuse_puzhash", None),
+        )
+        return {"success": True, "tx_id": tx.name()}
+
+    async def dao_create_proposal(self, request) -> EndpointResult:
+        wallet_id = uint32(request["wallet_id"])
+        dao_wallet = self.service.wallet_state_manager.get_wallet(id=wallet_id, required_type=DAOWallet)
+        assert dao_wallet is not None
+
+        if request["proposal_type"] == "spend":
+            amounts: List[uint64] = []
+            puzzle_hashes: List[bytes32] = []
+            asset_types: List[Optional[bytes32]] = []
+            additions: Optional[List[Dict]] = request.get("additions")
+            if additions is not None:
+                for addition in additions:
+                    if "asset_id" in addition:
+                        asset_id = bytes32.from_hexstr(addition["asset_id"])
+                    else:
+                        asset_id = None
+                    receiver_ph = bytes32.from_hexstr(addition["puzzle_hash"])
+                    amount = uint64(addition["amount"])
+                    amounts.append(amount)
+                    puzzle_hashes.append(receiver_ph)
+                    asset_types.append(asset_id)
+            else:
+                amounts.append(uint64(request["amount"]))
+                puzzle_hashes.append(decode_puzzle_hash(request["inner_address"]))
+                if request["asset_id"] is not None:
+                    asset_types.append(bytes32.from_hexstr(request["asset_id"]))
+                else:
+                    asset_types.append(None)
+            proposed_puzzle = dao_wallet.generate_simple_proposal_innerpuz(puzzle_hashes, amounts, asset_types)
+
+        elif request["proposal_type"] == "update":
+            rules = dao_wallet.dao_rules
+            prop = request["new_dao_rules"]
+            new_rules = DAORules(
+                proposal_timelock=prop.get("proposal_timelock") or rules.proposal_timelock,
+                soft_close_length=prop.get("soft_close_length") or rules.soft_close_length,
+                attendance_required=prop.get("attendance_required") or rules.attendance_required,
+                pass_percentage=prop.get("pass_percentage") or rules.pass_percentage,
+                self_destruct_length=prop.get("self_destruct_length") or rules.self_destruct_length,
+                oracle_spend_delay=prop.get("oracle_spend_delay") or rules.oracle_spend_delay,
+            )
+
+            proposed_puzzle = await dao_wallet.generate_update_proposal_innerpuz(new_rules)
+        elif request["proposal_type"] == "mint":
+            amount_of_cats = uint64(request["amount"])
+            mint_address = decode_puzzle_hash(request["cat_target_address"])
+            # amount_of_cats_to_create: uint64,
+            # cats_new_innerpuzhash: bytes32,
+            proposed_puzzle = await dao_wallet.generate_mint_proposal_innerpuz(amount_of_cats, mint_address)
+        else:
+            return {"success": False, "error": "Unknown proposal type."}
+
+        if "vote_amount" in request:
+            vote_amount = uint64(request["vote_amount"])
+        else:
+            vote_amount = None
+        fee = uint64(request.get("fee", 0))
+        tx = await dao_wallet.generate_new_proposal(
+            proposed_puzzle,
+            vote_amount,
+            fee,
+            reuse_puzhash=request.get("reuse_puzhash", None),
+        )
+        assert tx is not None
+        return {
+            "success": True,
+            "tx_id": tx.name().hex(),
+        }
+
+    async def dao_vote_on_proposal(self, request) -> EndpointResult:
+        wallet_id = uint32(request["wallet_id"])
+        dao_wallet = self.service.wallet_state_manager.get_wallet(id=wallet_id, required_type=DAOWallet)
+        assert dao_wallet is not None
+        vote_amount = None
+        if "vote_amount" in request:
+            vote_amount = uint64(request["vote_amount"])
+        fee = uint64(request.get("fee", 0))
+        sb = await dao_wallet.generate_proposal_vote_spend(
+            bytes32.from_hexstr(request["proposal_id"]),
+            vote_amount,
+            request["is_yes_vote"],  # bool
+            fee,
+            push=True,
+            reuse_puzhash=request.get("reuse_puzhash", None),
+        )
+        assert sb is not None
+        return {"success": True, "spend_bundle": sb}
+
+    async def dao_parse_proposal(self, request) -> EndpointResult:
+        wallet_id = uint32(request["wallet_id"])
+        dao_wallet = self.service.wallet_state_manager.get_wallet(id=wallet_id, required_type=DAOWallet)
+        assert dao_wallet is not None
+        proposal_id = bytes32.from_hexstr(request["proposal_id"])
+        proposal_dictionary = await dao_wallet.parse_proposal(proposal_id)
+        assert proposal_dictionary is not None
+        return {"success": True, "proposal_dictionary": proposal_dictionary}
+
+    async def dao_close_proposal(self, request) -> EndpointResult:
+        wallet_id = uint32(request["wallet_id"])
+        dao_wallet = self.service.wallet_state_manager.get_wallet(id=wallet_id, required_type=DAOWallet)
+        assert dao_wallet is not None
+        fee = uint64(request.get("fee", 0))
+        if "genesis_id" in request:
+            genesis_id = bytes32.from_hexstr(request["genesis_id"])
+        else:
+            genesis_id = None
+        tx = await dao_wallet.create_proposal_close_spend(
+            bytes32.from_hexstr(request["proposal_id"]),
+            genesis_id,
+            fee,
+            # genesis_id,
+            push=True,
+            reuse_puzhash=request.get("reuse_puzhash", None),
+        )
+        assert tx is not None
+        return {"success": True, "tx_id": tx.name()}
+
+    async def dao_free_coins_from_finished_proposals(self, request) -> EndpointResult:
+        wallet_id = uint32(request["wallet_id"])
+        fee = uint64(request.get("fee", 0))
+        dao_wallet = self.service.wallet_state_manager.get_wallet(id=wallet_id, required_type=DAOWallet)
+        assert dao_wallet is not None
+        tx = await dao_wallet.free_coins_from_finished_proposals(
+            fee=fee,
+            reuse_puzhash=request.get("reuse_puzhash", None),
+        )
+        assert tx is not None
+
+        return {"success": True, "spend_name": tx.name()}
+
     ##########################################################################################
     # NFT Wallet
     ##########################################################################################
@@ -2926,7 +3215,10 @@ class WalletRpcApi:
     async def get_coin_records(self, request: Dict[str, Any]) -> EndpointResult:
         parsed_request = GetCoinRecords.from_json_dict(request)
 
-        if parsed_request.limit != uint32.MAXIMUM and parsed_request.limit > self.max_get_coin_records_limit:
+        if (
+            parsed_request.limit != uint32.MAXIMUM_EXCLUSIVE - 1
+            and parsed_request.limit > self.max_get_coin_records_limit
+        ):
             raise ValueError(f"limit of {self.max_get_coin_records_limit} exceeded: {parsed_request.limit}")
 
         for filter_name, filter in {
@@ -3114,7 +3406,7 @@ class WalletRpcApi:
             else:
                 assert isinstance(wallet, CATWallet)
 
-                txs = await wallet.generate_signed_transaction(
+                txs = await wallet.generate_signed_transactions(
                     [amount_0] + [output.amount for output in additional_outputs],
                     [bytes32(puzzle_hash_0)] + [output.puzzle_hash for output in additional_outputs],
                     fee,
diff --git a/chia/rpc/wallet_rpc_client.py b/chia/rpc/wallet_rpc_client.py
index ae4c7d526..967cf1239 100644
--- a/chia/rpc/wallet_rpc_client.py
+++ b/chia/rpc/wallet_rpc_client.py
@@ -1194,6 +1194,191 @@ class WalletRpcClient(RpcClient):
         response = await self.fetch("sign_message_by_id", {"id": id, "message": message})
         return response["pubkey"], response["signature"], response["signing_mode"]
 
+    # DAOs
+    async def create_new_dao_wallet(
+        self,
+        mode: str,
+        dao_rules: Optional[Dict[str, uint64]] = None,
+        amount_of_cats: Optional[uint64] = None,
+        treasury_id: Optional[bytes32] = None,
+        filter_amount: uint64 = uint64(1),
+        name: Optional[str] = None,
+        fee: uint64 = uint64(0),
+        reuse_puzhash: Optional[bool] = None,
+    ) -> Dict:
+        """
+        TODO: Rearrange argument list order
+        """
+        request: Dict[str, Any] = {
+            "wallet_type": "dao_wallet",
+            "mode": mode,
+            "treasury_id": treasury_id,
+            "dao_rules": dao_rules,
+            "amount_of_cats": amount_of_cats,
+            "filter_amount": filter_amount,
+            "name": name,
+            "fee": fee,
+            "reuse_puzhash": reuse_puzhash,
+        }
+        response = await self.fetch("create_new_wallet", request)
+        return response
+
+    async def dao_create_proposal(
+        self,
+        wallet_id: int,
+        proposal_type: str,
+        additions: Optional[List[Dict]] = None,
+        amount: Optional[uint64] = None,
+        inner_address: Optional[str] = None,
+        asset_id: Optional[str] = None,
+        cat_target_address: Optional[str] = None,
+        vote_amount: Optional[int] = None,
+        new_dao_rules: Optional[Dict[str, uint64]] = None,
+        fee: uint64 = uint64(0),
+        reuse_puzhash: Optional[bool] = None,
+    ) -> Dict:
+        request: Dict[str, Any] = {
+            "wallet_id": wallet_id,
+            "proposal_type": proposal_type,
+            "additions": additions,
+            "amount": amount,
+            "inner_address": inner_address,
+            "asset_id": asset_id,
+            "cat_target_address": cat_target_address,
+            "vote_amount": vote_amount,
+            "new_dao_rules": new_dao_rules,
+            "fee": fee,
+            "reuse_puzhash": reuse_puzhash,
+        }
+
+        response = await self.fetch("dao_create_proposal", request)
+        return response
+
+    async def dao_get_proposal_state(self, wallet_id: int, proposal_id: str):
+        request: Dict[str, Any] = {"wallet_id": wallet_id, "proposal_id": proposal_id}
+        response = await self.fetch("dao_get_proposal_state", request)
+        return response
+
+    async def dao_parse_proposal(self, wallet_id: int, proposal_id: str):
+        request: Dict[str, Any] = {"wallet_id": wallet_id, "proposal_id": proposal_id}
+        response = await self.fetch("dao_parse_proposal", request)
+        return response
+
+    async def dao_vote_on_proposal(
+        self,
+        wallet_id: int,
+        proposal_id: str,
+        vote_amount: uint64,
+        is_yes_vote: bool = True,
+        fee: uint64 = uint64(0),
+        reuse_puzhash: Optional[bool] = None,
+    ):
+        request: Dict[str, Any] = {
+            "wallet_id": wallet_id,
+            "proposal_id": proposal_id,
+            "vote_amount": vote_amount,
+            "is_yes_vote": is_yes_vote,
+            "fee": fee,
+            "reuse_puzhash": reuse_puzhash,
+        }
+        response = await self.fetch("dao_vote_on_proposal", request)
+        return response
+
+    async def dao_get_proposals(self, wallet_id: int):
+        request: Dict[str, Any] = {"wallet_id": wallet_id}
+        response = await self.fetch("dao_get_proposals", request)
+        return response
+
+    async def dao_close_proposal(
+        self,
+        wallet_id: int,
+        proposal_id: str,
+        fee: uint64 = uint64(0),
+        reuse_puzhash: Optional[bool] = None,
+    ):
+        request: Dict[str, Any] = {
+            "wallet_id": wallet_id,
+            "proposal_id": proposal_id,
+            "fee": fee,
+            "reuse_puzhash": reuse_puzhash,
+        }
+        response = await self.fetch("dao_close_proposal", request)
+        return response
+
+    async def dao_free_coins_from_finished_proposals(
+        self,
+        wallet_id: int,
+        fee: uint64 = uint64(0),
+        reuse_puzhash: Optional[bool] = None,
+    ):
+        request: Dict[str, Any] = {
+            "wallet_id": wallet_id,
+            "fee": fee,
+            "reuse_puzhash": reuse_puzhash,
+        }
+        response = await self.fetch("dao_free_coins_from_finished_proposals", request)
+        return response
+
+    async def dao_get_treasury_balance(self, wallet_id: int):
+        request: Dict[str, Any] = {"wallet_id": wallet_id}
+        response = await self.fetch("dao_get_treasury_balance", request)
+        return response
+
+    async def dao_add_funds_to_treasury(
+        self,
+        wallet_id: int,
+        funding_wallet_id: int,
+        amount: uint64,
+        fee: uint64 = uint64(0),
+        reuse_puzhash: Optional[bool] = None,
+    ):
+        request: Dict[str, Any] = {
+            "wallet_id": wallet_id,
+            "funding_wallet_id": funding_wallet_id,
+            "amount": amount,
+            "fee": fee,
+            "reuse_puzhash": reuse_puzhash,
+        }
+        response = await self.fetch("dao_add_funds_to_treasury", request)
+        return response
+
+    async def dao_send_to_lockup(
+        self,
+        wallet_id: int,
+        amount: uint64,
+        fee: uint64 = uint64(0),
+        reuse_puzhash: Optional[bool] = None,
+    ):
+        request: Dict[str, Any] = {
+            "wallet_id": wallet_id,
+            "amount": amount,
+            "fee": fee,
+            "reuse_puzhash": reuse_puzhash,
+        }
+        response = await self.fetch("dao_send_to_lockup", request)
+        return response
+
+    async def dao_exit_lockup(
+        self,
+        wallet_id: int,
+        coins: Optional[List[Dict]] = None,
+        fee: uint64 = uint64(0),
+        reuse_puzhash: Optional[bool] = None,
+    ):
+        request: Dict[str, Any] = {
+            "wallet_id": wallet_id,
+            "coins": coins,
+            "fee": fee,
+            "reuse_puzhash": reuse_puzhash,
+        }
+        response = await self.fetch("dao_exit_lockup", request)
+        return response
+
+    async def dao_adjust_filter_level(self, wallet_id: int, filter_level: int):
+        request: Dict[str, Any] = {"wallet_id": wallet_id, "filter_level": filter_level}
+        response = await self.fetch("dao_adjust_filter_level", request)
+        return response
+
     async def vc_mint(
         self, did_id: bytes32, target_address: Optional[bytes32] = None, fee: uint64 = uint64(0)
     ) -> Tuple[VCRecord, List[TransactionRecord]]:
diff --git a/chia/types/blockchain_format/proof_of_space.py b/chia/types/blockchain_format/proof_of_space.py
index 3068f1699..b080295d2 100644
--- a/chia/types/blockchain_format/proof_of_space.py
+++ b/chia/types/blockchain_format/proof_of_space.py
@@ -44,26 +44,26 @@ def verify_and_get_quality_string(
 ) -> Optional[bytes32]:
     # Exactly one of (pool_public_key, pool_contract_puzzle_hash) must not be None
     if (pos.pool_public_key is None) and (pos.pool_contract_puzzle_hash is None):
-        log.error("Expected pool public key or pool contract puzzle hash but got neither")
+        log.error("Fail 1")
         return None
     if (pos.pool_public_key is not None) and (pos.pool_contract_puzzle_hash is not None):
-        log.error("Expected pool public key or pool contract puzzle hash but got both")
+        log.error("Fail 2")
         return None
     if pos.size < constants.MIN_PLOT_SIZE:
-        log.error("Plot size is lower than the minimum")
+        log.error("Fail 3")
         return None
     if pos.size > constants.MAX_PLOT_SIZE:
-        log.error("Plot size is higher than the maximum")
+        log.error("Fail 4")
         return None
     plot_id: bytes32 = get_plot_id(pos)
     new_challenge: bytes32 = calculate_pos_challenge(plot_id, original_challenge_hash, signage_point)
 
     if new_challenge != pos.challenge:
-        log.error("Calculated pos challenge doesn't match the provided one")
+        log.error("New challenge is not challenge")
         return None
 
     if not passes_plot_filter(constants, plot_id, original_challenge_hash, signage_point):
-        log.error("Did not pass the plot filter")
+        log.error("Fail 5")
         return None
 
     return get_quality_string(pos, plot_id)
diff --git a/chia/util/ints.py b/chia/util/ints.py
index 629fe09d5..cbc1cd24c 100644
--- a/chia/util/ints.py
+++ b/chia/util/ints.py
@@ -1,62 +1,51 @@
 from __future__ import annotations
 
-from typing import ClassVar
-
 from chia.util.struct_stream import StructStream, parse_metadata_from_name
 
 
 @parse_metadata_from_name
 class int8(StructStream):
-    MINIMUM: ClassVar[int8]
-    MAXIMUM: ClassVar[int8]
+    pass
 
 
 @parse_metadata_from_name
 class uint8(StructStream):
-    MINIMUM: ClassVar[uint8]
-    MAXIMUM: ClassVar[uint8]
+    pass
 
 
 @parse_metadata_from_name
 class int16(StructStream):
-    MINIMUM: ClassVar[int16]
-    MAXIMUM: ClassVar[int16]
+    pass
 
 
 @parse_metadata_from_name
 class uint16(StructStream):
-    MINIMUM: ClassVar[uint16]
-    MAXIMUM: ClassVar[uint16]
+    pass
 
 
 @parse_metadata_from_name
 class int32(StructStream):
-    MINIMUM: ClassVar[int32]
-    MAXIMUM: ClassVar[int32]
+    pass
 
 
 @parse_metadata_from_name
 class uint32(StructStream):
-    MINIMUM: ClassVar[uint32]
-    MAXIMUM: ClassVar[uint32]
+    pass
 
 
 @parse_metadata_from_name
 class int64(StructStream):
-    MINIMUM: ClassVar[int64]
-    MAXIMUM: ClassVar[int64]
+    pass
 
 
 @parse_metadata_from_name
 class uint64(StructStream):
-    MINIMUM: ClassVar[uint64]
-    MAXIMUM: ClassVar[uint64]
+    pass
 
 
 @parse_metadata_from_name
 class uint128(StructStream):
-    MINIMUM: ClassVar[uint128]
-    MAXIMUM: ClassVar[uint128]
+    pass
 
 
 class int512(StructStream):
@@ -70,9 +59,5 @@ class int512(StructStream):
     # note that the boundaries for int512 is not what you might expect. We
     # encode these with one extra byte, but only allow a range of
     # [-INT512_MAX, INT512_MAX]
-    MINIMUM: ClassVar[int512] = -(2**BITS) + 1
-    MAXIMUM: ClassVar[int512] = (2**BITS) - 1
-
-
-int512.MINIMUM = int512(int512.MINIMUM)
-int512.MAXIMUM = int512(int512.MAXIMUM)
+    MAXIMUM_EXCLUSIVE = 2**BITS
+    MINIMUM = -(2**BITS) + 1
diff --git a/chia/util/misc.py b/chia/util/misc.py
index 27db586c1..0d192e9cd 100644
--- a/chia/util/misc.py
+++ b/chia/util/misc.py
@@ -124,14 +124,14 @@ else:
 @dataclasses.dataclass(frozen=True)
 class UInt32Range(Streamable):
     start: uint32 = uint32(0)
-    stop: uint32 = uint32.MAXIMUM
+    stop: uint32 = uint32(uint32.MAXIMUM_EXCLUSIVE - 1)
 
 
 @streamable
 @dataclasses.dataclass(frozen=True)
 class UInt64Range(Streamable):
     start: uint64 = uint64(0)
-    stop: uint64 = uint64.MAXIMUM
+    stop: uint64 = uint64(uint64.MAXIMUM_EXCLUSIVE - 1)
 
 
 @dataclass(frozen=True)
diff --git a/chia/util/struct_stream.py b/chia/util/struct_stream.py
index 365487223..dacda0a0e 100644
--- a/chia/util/struct_stream.py
+++ b/chia/util/struct_stream.py
@@ -1,6 +1,6 @@
 from __future__ import annotations
 
-from typing import BinaryIO, ClassVar, SupportsInt, Type, TypeVar, Union
+from typing import BinaryIO, SupportsInt, Type, TypeVar, Union
 
 from typing_extensions import Protocol, SupportsIndex
 
@@ -37,28 +37,24 @@ def parse_metadata_from_name(cls: Type[_T_StructStream]) -> Type[_T_StructStream
         raise ValueError(f"cls.BITS must be a multiple of 8: {cls.BITS}")
 
     if cls.SIGNED:
+        cls.MAXIMUM_EXCLUSIVE = 2 ** (cls.BITS - 1)
         cls.MINIMUM = -(2 ** (cls.BITS - 1))
-        cls.MAXIMUM = (2 ** (cls.BITS - 1)) - 1
     else:
+        cls.MAXIMUM_EXCLUSIVE = 2**cls.BITS
         cls.MINIMUM = 0
-        cls.MAXIMUM = (2**cls.BITS) - 1
-
-    cls.MINIMUM = cls(cls.MINIMUM)
-    cls.MAXIMUM = cls(cls.MAXIMUM)
 
     return cls
 
 
 class StructStream(int):
-    SIZE: ClassVar[int]
-    BITS: ClassVar[int]
-    SIGNED: ClassVar[bool]
-    MAXIMUM: ClassVar[int]
-    MINIMUM: ClassVar[int]
+    SIZE = 0
+    BITS = 0
+    SIGNED = False
+    MAXIMUM_EXCLUSIVE = 0
+    MINIMUM = 0
 
     """
-    Create a class that can parse and stream itself based on a struct.pack template string. This is only meant to be
-    a base class for further derivation and it's not recommended to instantiate it directly.
+    Create a class that can parse and stream itself based on a struct.pack template string.
     """
 
     # This is just a partial exposure of the underlying int constructor.  Liskov...
@@ -69,7 +65,7 @@ class StructStream(int):
         # additional special action to take here beyond verifying that the newly
         # created instance satisfies the bounds limitations of the particular subclass.
         super().__init__()
-        if not (self.MINIMUM <= self <= self.MAXIMUM):
+        if not (self.MINIMUM <= self < self.MAXIMUM_EXCLUSIVE):
             raise ValueError(f"Value {self} does not fit into {type(self).__name__}")
 
     @classmethod
diff --git a/chia/wallet/cat_wallet/cat_utils.py b/chia/wallet/cat_wallet/cat_utils.py
index f40fd4898..c23b55a2a 100644
--- a/chia/wallet/cat_wallet/cat_utils.py
+++ b/chia/wallet/cat_wallet/cat_utils.py
@@ -74,6 +74,10 @@ def construct_cat_puzzle(
     return mod_code.curry(mod_code_hash, limitations_program_hash, inner_puzzle)
 
 
+def construct_cat_puzzlehash_for_inner_puzzlehash(tail_hash: bytes32, inner_puzzle_hash: bytes32) -> bytes32:
+    return CAT_MOD.curry(CAT_MOD_HASH, tail_hash, inner_puzzle_hash).get_tree_hash_precalc(inner_puzzle_hash)
+
+
 def subtotals_for_deltas(deltas: List[int]) -> List[int]:
     """
     Given a list of deltas corresponding to input coins, create the "subtotals" list
diff --git a/chia/wallet/cat_wallet/cat_wallet.py b/chia/wallet/cat_wallet/cat_wallet.py
index 2468828d2..465c5ab42 100644
--- a/chia/wallet/cat_wallet/cat_wallet.py
+++ b/chia/wallet/cat_wallet/cat_wallet.py
@@ -176,6 +176,7 @@ class CATWallet:
         chia_tx = dataclasses.replace(chia_tx, spend_bundle=spend_bundle)
         await self.standard_wallet.push_transaction(chia_tx)
         await self.standard_wallet.push_transaction(cat_record)
+        # breakpoint()
         return self
 
     @staticmethod
@@ -304,7 +305,7 @@ class CATWallet:
         spendable.sort(reverse=True, key=lambda record: record.coin.amount)
         if self.cost_of_single_tx is None:
             coin = spendable[0].coin
-            txs = await self.generate_signed_transaction(
+            txs = await self.generate_signed_transactions(
                 [uint64(coin.amount)], [coin.puzzle_hash], coins={coin}, ignore_max_send_amount=True
             )
             assert txs[0].spend_bundle
@@ -806,7 +807,7 @@ class CATWallet:
             chia_tx,
         )
 
-    async def generate_signed_transaction(
+    async def generate_signed_transactions(
         self,
         amounts: List[uint64],
         puzzle_hashes: List[bytes32],
@@ -820,6 +821,7 @@ class CATWallet:
         max_coin_amount: Optional[uint64] = None,
         excluded_coin_amounts: Optional[List[uint64]] = None,
         reuse_puzhash: Optional[bool] = None,
+        override_memos: Optional[bool] = None,
         **kwargs: Unpack[GSTOptionalArgs],
     ) -> List[TransactionRecord]:
         excluded_cat_coins: Optional[Set[Coin]] = kwargs.get("excluded_cat_coins", None)
@@ -833,15 +835,18 @@ class CATWallet:
 
         payments = []
         for amount, puzhash, memo_list in zip(amounts, puzzle_hashes, memos):
-            memos_with_hint: List[bytes] = [puzhash]
-            memos_with_hint.extend(memo_list)
+            if override_memos:
+                memos_with_hint: List[bytes] = memo_list
+            else:
+                memos_with_hint = [puzhash]
+                memos_with_hint.extend(memo_list)
             payments.append(Payment(puzhash, amount, memos_with_hint))
 
         payment_sum = sum([p.amount for p in payments])
         if not ignore_max_send_amount:
             max_send = await self.get_max_send_amount()
             if payment_sum > max_send:
-                raise ValueError(f"Can't send more than {max_send} mojos in a single transaction")
+                raise ValueError(f" Insufficient funds. Your max amount is {max_send} mojos in a single transaction.")
         unsigned_spend_bundle, chia_tx = await self.generate_unsigned_spendbundle(
             payments,
             fee,
@@ -899,7 +904,6 @@ class CATWallet:
                     memos=[],
                 )
             )
-
         return tx_list
 
     async def add_lineage(self, name: bytes32, lineage: Optional[LineageProof]) -> None:
diff --git a/chia/wallet/cat_wallet/dao_cat_info.py b/chia/wallet/cat_wallet/dao_cat_info.py
new file mode 100644
index 000000000..a40a8cafa
--- /dev/null
+++ b/chia/wallet/cat_wallet/dao_cat_info.py
@@ -0,0 +1,28 @@
+from __future__ import annotations
+
+from dataclasses import dataclass
+from typing import List, Optional
+
+from chia.types.blockchain_format.coin import Coin
+from chia.types.blockchain_format.program import Program
+from chia.types.blockchain_format.sized_bytes import bytes32
+from chia.util.ints import uint64
+from chia.util.streamable import Streamable, streamable
+
+
+@streamable
+@dataclass(frozen=True)
+class LockedCoinInfo(Streamable):
+    coin: Coin
+    inner_puzzle: Program  # This is the lockup puzzle, not the lockup_puzzle's inner_puzzle
+    active_votes: List[Optional[bytes32]]
+
+
+@streamable
+@dataclass(frozen=True)
+class DAOCATInfo(Streamable):
+    dao_wallet_id: uint64
+    free_cat_wallet_id: uint64
+    limitations_program_hash: bytes32
+    my_tail: Optional[Program]  # this is the program
+    locked_coins: List[LockedCoinInfo]
diff --git a/chia/wallet/cat_wallet/dao_cat_wallet.py b/chia/wallet/cat_wallet/dao_cat_wallet.py
new file mode 100644
index 000000000..21ca77255
--- /dev/null
+++ b/chia/wallet/cat_wallet/dao_cat_wallet.py
@@ -0,0 +1,865 @@
+from __future__ import annotations
+
+import logging
+import time
+import traceback
+from secrets import token_bytes
+from typing import TYPE_CHECKING, Any, ClassVar, List, Optional, Set, Tuple, cast
+
+from blspy import AugSchemeMPL, G1Element, G2Element
+
+from chia.server.ws_connection import WSChiaConnection
+from chia.types.blockchain_format.coin import Coin
+from chia.types.blockchain_format.program import Program
+from chia.types.blockchain_format.sized_bytes import bytes32
+from chia.types.spend_bundle import SpendBundle
+from chia.util.byte_types import hexstr_to_bytes
+from chia.util.condition_tools import conditions_dict_for_solution, pkm_pairs_for_conditions_dict
+from chia.util.ints import uint32, uint64, uint128
+from chia.wallet.cat_wallet.cat_utils import (
+    CAT_MOD,
+    SpendableCAT,
+    construct_cat_puzzle,
+    match_cat_puzzle,
+    unsigned_spend_bundle_for_spendable_cats,
+)
+from chia.wallet.cat_wallet.cat_wallet import CATWallet
+from chia.wallet.cat_wallet.dao_cat_info import DAOCATInfo, LockedCoinInfo
+from chia.wallet.cat_wallet.lineage_store import CATLineageStore
+from chia.wallet.dao_wallet.dao_utils import (
+    DAO_FINISHED_STATE_HASH,
+    DAO_PROPOSAL_TIMER_MOD_HASH,
+    DAO_TREASURY_MOD_HASH,
+    add_proposal_to_active_list,
+    get_active_votes_from_lockup_puzzle,
+    get_innerpuz_from_lockup_puzzle,
+    get_lockup_puzzle,
+)
+from chia.wallet.derivation_record import DerivationRecord
+from chia.wallet.lineage_proof import LineageProof
+from chia.wallet.payment import Payment
+from chia.wallet.cat_wallet.cat_utils import CAT_MOD
+from chia.wallet.puzzles.p2_delegated_puzzle_or_hidden_puzzle import (
+    DEFAULT_HIDDEN_PUZZLE_HASH,
+    calculate_synthetic_secret_key,
+)
+from chia.wallet.transaction_record import TransactionRecord
+from chia.wallet.uncurried_puzzle import uncurry_puzzle
+from chia.wallet.util.curry_and_treehash import calculate_hash_of_quoted_mod_hash
+from chia.wallet.util.transaction_type import TransactionType
+from chia.wallet.util.wallet_sync_utils import fetch_coin_spend
+from chia.wallet.util.wallet_types import WalletType
+from chia.wallet.wallet import Wallet
+from chia.wallet.wallet_coin_record import WalletCoinRecord
+from chia.wallet.wallet_info import WalletInfo
+
+if TYPE_CHECKING:
+    from chia.wallet.wallet_state_manager import WalletStateManager
+
+CAT_MOD_HASH = CAT_MOD.get_tree_hash()
+CAT_MOD_HASH_HASH = Program.to(CAT_MOD_HASH).get_tree_hash()
+QUOTED_MOD_HASH = calculate_hash_of_quoted_mod_hash(CAT_MOD_HASH)
+
+
+class DAOCATWallet:
+    if TYPE_CHECKING:
+        from chia.wallet.wallet_protocol import WalletProtocol
+
+        _protocol_check: ClassVar[WalletProtocol] = cast("DAOCATWallet", None)
+
+    wallet_state_manager: Any
+    log: logging.Logger
+    wallet_info: WalletInfo
+    dao_cat_info: DAOCATInfo
+    standard_wallet: Wallet
+    cost_of_single_tx: Optional[int]
+    lineage_store: CATLineageStore
+
+    @classmethod
+    def type(cls) -> WalletType:
+        return WalletType.DAO_CAT
+
+    @staticmethod
+    async def create(
+        wallet_state_manager: WalletStateManager,
+        wallet: Wallet,
+        wallet_info: WalletInfo,
+    ) -> DAOCATWallet:
+        self = DAOCATWallet()
+
+        self.log = logging.getLogger(__name__)
+
+        self.cost_of_single_tx = None
+        self.wallet_state_manager = wallet_state_manager
+        self.wallet_info = wallet_info
+        self.standard_wallet = wallet
+        try:
+            self.dao_cat_info = DAOCATInfo.from_bytes(hexstr_to_bytes(self.wallet_info.data))
+            self.lineage_store = await CATLineageStore.create(self.wallet_state_manager.db_wrapper, self.get_asset_id())
+        except AssertionError as e:
+            self.log.error(f"Error creating DAO CAT wallet: {e}")
+            # Do a migration of the lineage proofs
+            # cat_info = LegacyCATInfo.from_bytes(hexstr_to_bytes(self.wallet_info.data))
+            # self.cat_info = DAOCATInfo(cat_info.limitations_program_hash, cat_info.my_tail)
+            # self.lineage_store = await CATLineageStore.create(self.wallet_state_manager.db_wrapper, self.get_asset_id())
+            # for coin_id, lineage in cat_info.lineage_proofs:
+            #     await self.add_lineage(coin_id, lineage)
+            # await self.save_info(self.cat_info)
+
+        return self
+
+    @staticmethod
+    async def get_or_create_wallet_for_cat(
+        wallet_state_manager: Any,
+        wallet: Wallet,
+        limitations_program_hash_hex: str,
+        name: Optional[str] = None,
+    ) -> DAOCATWallet:
+        self = DAOCATWallet()
+        self.cost_of_single_tx = None
+        self.standard_wallet = wallet
+        self.log = logging.getLogger(__name__)
+
+        limitations_program_hash_hex = bytes32.from_hexstr(limitations_program_hash_hex).hex()  # Normalize the format
+
+        dao_wallet_id = None
+        free_cat_wallet_id = None
+        for id, w in wallet_state_manager.wallets.items():
+            if w.type() == DAOCATWallet.type():
+                assert isinstance(w, DAOCATWallet)
+                if w.get_asset_id() == limitations_program_hash_hex:
+                    self.log.warning("Not creating wallet for already existing DAO CAT wallet")
+                    return w
+            elif w.type() == CATWallet.type():
+                assert isinstance(w, CATWallet)
+                if w.get_asset_id() == limitations_program_hash_hex:
+                    free_cat_wallet_id = w.id()
+        assert free_cat_wallet_id is not None
+        for id, w in wallet_state_manager.wallets.items():
+            if w.type() == WalletType.DAO:
+                self.log.info(f"FOUND DAO WALLET: {w}")
+                self.log.info(f"ALL WALLETS: {wallet_state_manager.wallets}")
+                if w.get_cat_wallet_id() == free_cat_wallet_id:
+                    dao_wallet_id = w.id()
+        assert dao_wallet_id is not None
+        self.wallet_state_manager = wallet_state_manager
+        if name is None:
+            name = CATWallet.default_wallet_name_for_unknown_cat(limitations_program_hash_hex)
+
+        limitations_program_hash = bytes32(hexstr_to_bytes(limitations_program_hash_hex))
+
+        self.dao_cat_info = DAOCATInfo(
+            dao_wallet_id,
+            uint64(free_cat_wallet_id),
+            limitations_program_hash,
+            None,
+            [],
+        )
+        info_as_string = bytes(self.dao_cat_info).hex()
+        self.wallet_info = await wallet_state_manager.user_store.create_wallet(name, WalletType.DAO_CAT, info_as_string)
+
+        self.lineage_store = await CATLineageStore.create(self.wallet_state_manager.db_wrapper, self.get_asset_id())
+        await self.wallet_state_manager.add_new_wallet(self)
+        return self
+
+    async def inner_puzzle_for_cat_puzhash(self, cat_hash: bytes32) -> Program:
+        record: Optional[
+            DerivationRecord
+        ] = await self.wallet_state_manager.puzzle_store.get_derivation_record_for_puzzle_hash(cat_hash)
+        if record is None:
+            raise RuntimeError(f"Missing Derivation Record for CAT puzzle_hash {cat_hash}")
+        inner_puzzle: Program = self.standard_wallet.puzzle_for_pk(record.pubkey)
+        return inner_puzzle
+
+    async def coin_added(self, coin: Coin, height: uint32, peer: WSChiaConnection) -> None:
+        """Notification from wallet state manager that wallet has been received."""
+        self.log.info(f"DAO CAT wallet has been notified that {coin} was added")
+        # We can't get the inner puzzle for this coin's puzhash because it has the lockup layer.
+        # So look for it's parent coin, and get the inner puzzle for it, which should be the same as
+        # the one contained in the lockup.
+        wallet_node: Any = self.wallet_state_manager.wallet_node
+        parent_coin = (await wallet_node.get_coin_state([coin.parent_coin_info], peer, height))[0]
+        parent_spend = await fetch_coin_spend(height, parent_coin.coin, peer)
+        uncurried = parent_spend.puzzle_reveal.uncurry()
+        cat_inner = uncurried[1].at("rrf")
+        lockup_puz, lockup_args = cat_inner.uncurry()
+        active_votes_list: List[Optional[bytes32]] = []
+
+        record = await self.wallet_state_manager.puzzle_store.get_derivation_record_for_puzzle_hash(coin.puzzle_hash)
+        if record:
+            inner_puzzle: Program = self.standard_wallet.puzzle_for_pk(record.pubkey)
+        else:
+            inner_puzzle = cat_inner.uncurry()[1].at("rrrrrrrf")
+            active_votes_list = [bytes32(prop.as_atom()) for prop in lockup_args.at("rrrrrrf").as_iter()]
+
+        if parent_spend.coin.puzzle_hash == coin.puzzle_hash:
+            # shortcut, works for change
+            lockup_puz = cat_inner
+        else:
+            # TODO: Move this section to dao_utils once we've got the close spend sorted
+            solution = parent_spend.solution.to_program().first()
+            if solution.first() == Program.to(0):
+                # No vote is being added so inner puz stays the same
+                # TODO: If the proposal is closed/coins are freed then what do we do here?
+                pass
+            else:
+                new_vote = solution.at("rrrf")
+                active_votes_list.insert(0, bytes32(new_vote.as_atom()))
+
+            lockup_puz = get_lockup_puzzle(
+                self.dao_cat_info.limitations_program_hash,
+                active_votes_list,
+                inner_puzzle,
+            )
+
+        new_cat_puzhash = construct_cat_puzzle(
+            CAT_MOD, self.dao_cat_info.limitations_program_hash, lockup_puz
+        ).get_tree_hash()
+
+        if new_cat_puzhash != coin.puzzle_hash:
+            raise ValueError(f"Cannot add coin - incorrect lockup puzzle: {coin}")
+
+        lineage_proof = LineageProof(coin.parent_coin_info, lockup_puz.get_tree_hash(), uint64(coin.amount))
+
+        await self.add_lineage(coin.name(), lineage_proof)
+
+        lineage = await self.get_lineage_proof_for_coin(coin)
+
+        if lineage is None:
+            try:
+                coin_state = await self.wallet_state_manager.wallet_node.get_coin_state(
+                    [coin.parent_coin_info], peer=peer
+                )
+                assert coin_state[0].coin.name() == coin.parent_coin_info
+                coin_spend = await fetch_coin_spend(coin_state[0].spent_height, coin_state[0].coin, peer)
+                # TODO: process this coin
+                self.log.info("coin_added coin_spend: %s", coin_spend)
+                # await self.puzzle_solution_received(coin_spend, parent_coin=coin_state[0].coin)
+            except Exception as e:
+                self.log.debug(f"Exception: {e}, traceback: {traceback.format_exc()}")
+
+        # add the new coin to the list of locked coins and remove the spent coin
+        locked_coins = [x for x in self.dao_cat_info.locked_coins if x.coin != parent_spend.coin]
+        new_info = LockedCoinInfo(coin, lockup_puz, active_votes_list)
+        if new_info not in locked_coins:
+            locked_coins.append(LockedCoinInfo(coin, lockup_puz, active_votes_list))
+        dao_cat_info: DAOCATInfo = DAOCATInfo(
+            self.dao_cat_info.dao_wallet_id,
+            self.dao_cat_info.free_cat_wallet_id,
+            self.dao_cat_info.limitations_program_hash,
+            self.dao_cat_info.my_tail,
+            locked_coins,
+        )
+        await self.save_info(dao_cat_info)
+
+    async def add_lineage(self, name: bytes32, lineage: Optional[LineageProof]) -> None:
+        """
+        Lineage proofs are stored as a list of parent coins and the lineage proof you will need if they are the
+        parent of the coin you are trying to spend. 'If I'm your parent, here's the info you need to spend yourself'
+        """
+        self.log.info(f"Adding parent {name.hex()}: {lineage}")
+        if lineage is not None:
+            await self.lineage_store.add_lineage_proof(name, lineage)
+
+    async def get_lineage_proof_for_coin(self, coin: Coin) -> Optional[LineageProof]:
+        return await self.lineage_store.get_lineage_proof(coin.parent_coin_info)
+
+    async def remove_lineage(self, name: bytes32) -> None:
+        self.log.info(f"Removing parent {name} (probably had a non-CAT parent)")
+        await self.lineage_store.remove_lineage_proof(name)
+
+    async def advanced_select_coins(
+        self, amount: uint64, proposal_id: bytes32
+    ) -> List[LockedCoinInfo]:
+        coins = []
+        s = 0
+        for coin in self.dao_cat_info.locked_coins:
+            compatible = True
+            for active_vote in coin.active_votes:
+                if active_vote == proposal_id:
+                    compatible = False
+                    break
+            if compatible:
+                coins.append(coin)
+                s += coin.coin.amount
+                if s >= amount:
+                    break
+        if s < amount:
+            raise ValueError(
+                "We do not have enough CATs in Voting Mode right now. "
+                "Please convert some more or try again with permission to convert."
+            )
+        return coins
+
+    def id(self) -> uint32:
+        return self.wallet_info.id
+
+    async def create_vote_spend(
+        self,
+        amount: uint64,
+        proposal_id: bytes32,
+        is_yes_vote: bool,
+        curry_vals: Optional[Tuple[Program, Program, Program]] = None,
+    ) -> SpendBundle:
+        coins: List[LockedCoinInfo] = await self.advanced_select_coins(amount, proposal_id)
+        running_sum = 0  # this will be used for change calculation
+        change = sum(c.coin.amount for c in coins) - amount
+        extra_delta, limitations_solution = 0, Program.to([])
+        limitations_program_reveal = Program.to([])
+        spendable_cat_list = []
+        dao_wallet = self.wallet_state_manager.wallets[self.dao_cat_info.dao_wallet_id]
+        treasury_id = dao_wallet.dao_info.treasury_id
+        if curry_vals is None:
+            YES_VOTES, TOTAL_VOTES, INNERPUZHASH = dao_wallet.get_proposal_curry_values(proposal_id)
+        else:
+            YES_VOTES, TOTAL_VOTES, INNERPUZHASH = curry_vals
+        # proposal_curry_vals = [YES_VOTES, TOTAL_VOTES, INNERPUZ]
+        for lci in coins:
+            # my_id  ; if my_id is 0 we do the return to return_address (exit voting mode) spend case
+            # inner_solution
+            # my_amount
+            # new_proposal_vote_id_or_removal_id  ; if we're exiting fully, set this to 0
+            # proposal_curry_vals
+            # vote_info
+            # vote_amount
+            # my_puzhash
+            # new_innerpuzhash  ; only include this if we're changing owners
+            coin = lci.coin
+
+            vote_info = 0
+            new_innerpuzzle = add_proposal_to_active_list(lci.inner_puzzle, proposal_id)
+            standard_inner_puz = get_innerpuz_from_lockup_puzzle(new_innerpuzzle)
+            # add_proposal_to_active_list also verifies that the lci.inner_puzzle is accurate
+            # We must create either: one coin with the new puzzle and all our value
+            # OR
+            # a coin with the new puzzle and part of our amount AND a coin with our current puzzle and the change
+
+            # We must also create a puzzle announcement which announces the following:
+            # message = (sha256tree (list new_proposal_vote_id_or_removal_id vote_amount vote_info my_id))
+            message = Program.to([proposal_id, amount, is_yes_vote, coin.name()]).get_tree_hash()
+            # We also collect 4 pieces of data for the DAOWallet in order to spend the Proposal properly
+
+            # vote_amount_or_solution  ; The qty of "votes" to add or subtract. ALWAYS POSITIVE.
+            # vote_info_or_p2_singleton_mod_hash ; vote_info is whether we are voting YES or NO. XXX rename vote_type?
+            # vote_coin_id_or_current_cat_issuance  ; this is either the coin ID we're taking a vote from OR...
+            #                                     ; the total number of CATs in circulation according to the treasury
+            # previous_votes_or_pass_margin  ; this is the active votes of the lockup we're communicating with
+            #                              ; OR this is what percentage of the total votes must be YES - represented as an integer from 0 to 10,000 - typically this is set at 5100 (51%)
+            # lockup_innerpuzhash_or_attendance_required  ; this is either the innerpuz of the locked up CAT we're taking a vote from OR
+            #                                           ; the attendance required - the percentage of the current issuance which must have voted represented as 0 to 10,000 - this is announced by the treasury
+            vote_amounts_list = []
+            voting_coin_id_list = []
+            previous_votes_list = []
+            lockup_innerpuz_list = []
+            if running_sum + coin.amount <= amount:
+                vote_amount = coin.amount
+                running_sum = running_sum + coin.amount
+                # CREATE_COIN new_puzzle coin.amount
+                # CREATE_PUZZLE_ANNOUNCEMENT (sha256tree (list new_proposal_vote_id_or_removal_id my_amount vote_info my_id))
+                # Payment(change_puzhash, uint64(change), [change_puzhash])
+                primaries = [
+                    Payment(
+                        new_innerpuzzle.get_tree_hash(),
+                        uint64(vote_amount),
+                        [standard_inner_puz.get_tree_hash()],
+                    )
+                ]
+                puzzle_announcements = set([message])
+                inner_solution = self.standard_wallet.make_solution(
+                    primaries=primaries, puzzle_announcements=puzzle_announcements
+                )
+            else:
+                vote_amount = amount - running_sum
+                # CREATE_COIN new_puzzle vote_amount
+                # CREATE_COIN old_puzzle change
+                # CREATE_PUZZLE_ANNOUNCEMENT (sha256tree (list new_proposal_vote_id_or_removal_id my_amount vote_info my_id))
+                primaries = [
+                    Payment(
+                        new_innerpuzzle.get_tree_hash(),
+                        uint64(vote_amount),
+                        [new_innerpuzzle.get_tree_hash()],
+                    ),
+                ]
+                if change > 0:
+                    primaries.append(
+                        Payment(
+                            lci.inner_puzzle.get_tree_hash(),
+                            uint64(change),
+                            [lci.inner_puzzle.get_tree_hash()],
+                        )
+                    )
+                puzzle_announcements = set([message])
+                inner_solution = self.standard_wallet.make_solution(
+                    primaries=primaries, puzzle_announcements=puzzle_announcements
+                )
+            if is_yes_vote:
+                vote_info = 1
+            vote_amounts_list.append(vote_amount)
+            voting_coin_id_list.append(coin.name())
+            previous_votes_list.append(get_active_votes_from_lockup_puzzle(lci.inner_puzzle))
+            lockup_innerpuz_list.append(get_innerpuz_from_lockup_puzzle(lci.inner_puzzle))
+            # my_id  ; if my_id is 0 we do the return to return_address (exit voting mode) spend case
+            # inner_solution
+            # my_amount
+            # new_proposal_vote_id_or_removal_id  ; if we're exiting fully, set this to 0
+            # proposal_curry_vals
+            # vote_info
+            # vote_amount
+            # my_inner_puzhash
+            # new_innerpuzhash  ; only include this if we're changing owners
+
+            # proposal_curry_vals is:
+            # (
+            #   TREASURY_MOD_HASH
+            #   PROPOSAL_TIMER_MOD_HASH
+            #   TREASURY_ID
+            #   YES_VOTES
+            #   TOTAL_VOTES
+            #   INNERPUZHASH
+            # )
+            solution = Program.to(
+                [
+                    coin.name(),
+                    inner_solution,
+                    coin.amount,
+                    proposal_id,
+                    [
+                        DAO_TREASURY_MOD_HASH,
+                        DAO_PROPOSAL_TIMER_MOD_HASH,
+                        treasury_id,
+                        YES_VOTES,
+                        TOTAL_VOTES,
+                        INNERPUZHASH,
+                    ],
+                    vote_info,
+                    vote_amount,
+                    lci.inner_puzzle.get_tree_hash(),
+                    0,
+                ]
+            )
+            # breakpoint()
+            lineage_proof = await self.get_lineage_proof_for_coin(coin)
+            assert lineage_proof is not None
+            new_spendable_cat = SpendableCAT(
+                coin,
+                self.dao_cat_info.limitations_program_hash,
+                lci.inner_puzzle,
+                solution,
+                limitations_solution=limitations_solution,
+                extra_delta=extra_delta,
+                lineage_proof=lineage_proof,
+                limitations_program_reveal=limitations_program_reveal,
+            )
+            spendable_cat_list.append(new_spendable_cat)
+            running_sum += coin.amount
+
+        cat_spend_bundle = unsigned_spend_bundle_for_spendable_cats(CAT_MOD, spendable_cat_list)
+        spend_bundle = await self.sign(cat_spend_bundle)
+
+        # breakpoint()
+        return spend_bundle
+
+    async def get_new_vote_state_puzzle(self, coins: Optional[List[Coin]] = None) -> Program:
+        innerpuz = await self.get_new_inner_puzzle()
+        puzzle = get_lockup_puzzle(
+            self.dao_cat_info.limitations_program_hash,
+            [],
+            innerpuz,
+        )
+        cat_puzzle: Program = construct_cat_puzzle(CAT_MOD, self.dao_cat_info.limitations_program_hash, puzzle)
+        # breakpoint()
+        await self.wallet_state_manager.add_interested_puzzle_hashes([puzzle.get_tree_hash()], [self.id()])
+        await self.wallet_state_manager.add_interested_puzzle_hashes([cat_puzzle.get_tree_hash()], [self.id()])
+        return puzzle
+
+    async def create_new_dao_cats(
+        self,
+        amount: uint64,
+        push: bool = False,
+        fee: uint64 = uint64(0),
+        reuse_puzhash: Optional[bool] = None,
+    ) -> Tuple[List[TransactionRecord], Optional[List[Coin]]]:
+        # check there are enough cats to convert
+        cat_wallet = self.wallet_state_manager.wallets[self.dao_cat_info.free_cat_wallet_id]
+        cat_balance = await cat_wallet.get_spendable_balance()
+        if cat_balance < amount:
+            raise ValueError(f"Insufficient CAT balance. Requested: {amount} Available: {cat_balance}")
+        # get the lockup puzzle hash
+        lockup_puzzle = await self.get_new_puzzle()
+        # create the cat spend
+        txs = await cat_wallet.generate_signed_transactions(
+            [amount], [lockup_puzzle.get_tree_hash()], fee=fee, reuse_puzhash=reuse_puzhash
+        )
+        new_cats = []
+        cat_puzzle_hash: bytes32 = construct_cat_puzzle(
+            CAT_MOD, self.dao_cat_info.limitations_program_hash, lockup_puzzle
+        ).get_tree_hash()
+        if push:
+            for tx in txs:
+                await self.wallet_state_manager.add_pending_transaction(tx)
+                for coin in tx.spend_bundle.additions():
+                    if coin.puzzle_hash == cat_puzzle_hash:
+                        new_cats.append(coin)
+        await self.wallet_state_manager.add_interested_puzzle_hashes([cat_puzzle_hash], [self.id()])
+
+        return txs, new_cats
+
+    async def exit_vote_state(
+        self,
+        coins: List[LockedCoinInfo],
+        fee: uint64 = uint64(0),
+        push: bool = True,
+        reuse_puzhash: Optional[bool] = None,
+    ) -> SpendBundle:
+        extra_delta, limitations_solution = 0, Program.to([])
+        limitations_program_reveal = Program.to([])
+        spendable_cat_list = []
+        total_amt = 0
+        spent_coins = []
+        for lci in coins:
+            coin = lci.coin
+            if reuse_puzhash:
+                new_inner_puzhash = await self.standard_wallet.get_puzzle_hash(new=False)
+            else:
+                new_inner_puzhash = await self.standard_wallet.get_puzzle_hash(new=True)
+
+            # CREATE_COIN new_puzzle coin.amount
+            primaries = [
+                Payment(
+                    new_inner_puzhash,
+                    uint64(coin.amount),
+                    [new_inner_puzhash],
+                ),
+            ]
+            total_amt += coin.amount
+            inner_solution = self.standard_wallet.make_solution(
+                primaries=primaries,
+            )
+            # my_id  ; if my_id is 0 we do the return to return_address (exit voting mode) spend case
+            # inner_solution
+            # my_amount
+            # new_proposal_vote_id_or_removal_id  ; if we're exiting fully, set this to 0
+            # proposal_curry_vals
+            # vote_info
+            # vote_amount
+            # my_puzhash
+            solution = Program.to(
+                [
+                    0,
+                    inner_solution,
+                    coin.amount,
+                    0,
+                    0,
+                    0,
+                    0,
+                    0,
+                ]
+            )
+            lineage_proof = await self.get_lineage_proof_for_coin(coin)
+            assert lineage_proof is not None
+            new_spendable_cat = SpendableCAT(
+                coin,
+                self.dao_cat_info.limitations_program_hash,
+                lci.inner_puzzle,
+                solution,
+                limitations_solution=limitations_solution,
+                extra_delta=extra_delta,
+                lineage_proof=lineage_proof,
+                limitations_program_reveal=limitations_program_reveal,
+            )
+            spendable_cat_list.append(new_spendable_cat)
+            spent_coins.append(coin)
+
+        cat_spend_bundle = unsigned_spend_bundle_for_spendable_cats(CAT_MOD, spendable_cat_list)
+        spend_bundle = await self.sign(cat_spend_bundle)
+
+        if fee > 0:
+            dao_wallet = self.wallet_state_manager.wallets[self.dao_cat_info.dao_wallet_id]
+            chia_tx = await dao_wallet.create_tandem_xch_tx(fee, reuse_puzhash=reuse_puzhash)
+            assert chia_tx.spend_bundle is not None
+            full_spend = SpendBundle.aggregate([spend_bundle, chia_tx.spend_bundle])
+        else:
+            full_spend = spend_bundle
+
+        if push:
+            record = TransactionRecord(
+                confirmed_at_height=uint32(0),
+                created_at_time=uint64(int(time.time())),
+                to_puzzle_hash=new_inner_puzhash,
+                amount=uint64(total_amt),
+                fee_amount=fee,
+                confirmed=False,
+                sent=uint32(10),
+                spend_bundle=full_spend,
+                additions=full_spend.additions(),
+                removals=full_spend.removals(),
+                wallet_id=self.id(),
+                sent_to=[],
+                trade_id=None,
+                type=uint32(TransactionType.INCOMING_TX.value),
+                name=bytes32(token_bytes()),
+                memos=[],
+            )
+            await self.wallet_state_manager.add_pending_transaction(record)
+
+            # TODO: Hack to just drop coins from locked list. Need to catch this event in WSM to
+            # check if we're adding CATs from our DAO CAT wallet and update the locked coin list
+            # accordingly
+            new_locked_coins = [x for x in self.dao_cat_info.locked_coins if x.coin not in spent_coins]
+            dao_cat_info: DAOCATInfo = DAOCATInfo(
+                self.dao_cat_info.dao_wallet_id,
+                self.dao_cat_info.free_cat_wallet_id,
+                self.dao_cat_info.limitations_program_hash,
+                self.dao_cat_info.my_tail,
+                new_locked_coins,
+            )
+            await self.save_info(dao_cat_info)
+
+        return spend_bundle
+
+    async def remove_active_proposal(
+        self, proposal_id: bytes32, fee: uint64 = uint64(0), push: bool = True
+    ) -> SpendBundle:
+        locked_coins = []
+        for lci in self.dao_cat_info.locked_coins:
+            for active_vote in lci.active_votes:
+                if active_vote == proposal_id:
+                    locked_coins.append(lci)
+                    break
+        extra_delta, limitations_solution = 0, Program.to([])
+        limitations_program_reveal = Program.to([])
+        spendable_cat_list = []
+        # cat_wallet = await self.wallet_state_manager.user_store.get_wallet_by_id(self.dao_cat_info.free_cat_wallet_id)
+        dao_wallet = self.wallet_state_manager.wallets[self.dao_cat_info.dao_wallet_id]
+        YES_VOTES, TOTAL_VOTES, INNERPUZ = dao_wallet.get_proposal_curry_values(proposal_id)
+        proposal_curry_vals = [YES_VOTES, TOTAL_VOTES, INNERPUZ]
+        for lci in locked_coins:
+            coin = lci.coin
+            # new_innerpuzzle = await cat_wallet.get_new_inner_puzzle()
+
+            # CREATE_COIN new_puzzle coin.amount
+            # primaries = [
+            #     AmountWithPuzzlehash({
+            #         "puzzlehash": new_innerpuzzle.get_tree_hash(),
+            #         "amount": uint64(coin.amount),
+            #         "memos": [new_innerpuzzle.get_tree_hash()],
+            #     }),
+            # ]
+
+            # my_id  ; if my_id is 0 we do the return to return_address (exit voting mode) spend case
+            # inner_solution
+            # my_amount
+            # new_proposal_vote_id_or_removal_id  ; if we're exiting fully, set this to 0
+            # proposal_curry_vals
+            # vote_info
+            # vote_amount
+            # my_puzhash
+            solution = Program.to(
+                [
+                    0,
+                    0,
+                    coin.amount,
+                    proposal_id,
+                    proposal_curry_vals,
+                    0,
+                    0,
+                    0,
+                    0,
+                ]
+            )
+            lineage_proof = await self.get_lineage_proof_for_coin(coin)
+            assert lineage_proof is not None
+            new_spendable_cat = SpendableCAT(
+                coin,
+                self.dao_cat_info.limitations_program_hash,
+                lci.inner_puzzle,
+                solution,
+                limitations_solution=limitations_solution,
+                extra_delta=extra_delta,
+                lineage_proof=lineage_proof,
+                limitations_program_reveal=limitations_program_reveal,
+            )
+            spendable_cat_list.append(new_spendable_cat)
+
+        cat_spend_bundle = unsigned_spend_bundle_for_spendable_cats(CAT_MOD, spendable_cat_list)
+        spend_bundle = await self.sign(cat_spend_bundle)
+
+        if fee > 0:
+            dao_wallet = self.wallet_state_manager.wallets[self.dao_cat_info.dao_wallet_id]
+            chia_tx = await dao_wallet.create_tandem_xch_tx(fee)
+            assert chia_tx.spend_bundle is not None
+            full_spend = SpendBundle.aggregate([spend_bundle, chia_tx.spend_bundle])
+        else:
+            full_spend = spend_bundle
+
+        if push:
+            record = TransactionRecord(
+                confirmed_at_height=uint32(0),
+                created_at_time=uint64(int(time.time())),
+                to_puzzle_hash=DAO_FINISHED_STATE_HASH,
+                amount=uint64(1),
+                fee_amount=fee,
+                confirmed=False,
+                sent=uint32(10),
+                spend_bundle=full_spend,
+                additions=full_spend.additions(),
+                removals=full_spend.removals(),
+                wallet_id=self.id(),
+                sent_to=[],
+                trade_id=None,
+                type=uint32(TransactionType.INCOMING_TX.value),
+                name=bytes32(token_bytes()),
+                memos=[],
+            )
+            await self.wallet_state_manager.add_pending_transaction(record)
+
+        return full_spend
+
+    def get_asset_id(self) -> str:
+        return bytes(self.dao_cat_info.limitations_program_hash).hex()
+
+    async def get_new_inner_hash(self) -> bytes32:
+        puzzle = await self.get_new_inner_puzzle()
+        return puzzle.get_tree_hash()
+
+    async def get_new_inner_puzzle(self) -> Program:
+        return await self.standard_wallet.get_new_puzzle()
+
+    async def get_new_puzzle(self) -> Program:
+        record = await self.wallet_state_manager.get_unused_derivation_record(self.id())
+        inner_puzzle = self.standard_wallet.puzzle_for_pk(record.pubkey)
+        puzzle = get_lockup_puzzle(
+            self.dao_cat_info.limitations_program_hash,
+            [],
+            inner_puzzle,
+        )
+        cat_puzzle: Program = construct_cat_puzzle(CAT_MOD, self.dao_cat_info.limitations_program_hash, puzzle)
+        await self.wallet_state_manager.add_interested_puzzle_hashes([puzzle.get_tree_hash()], [self.id()])
+        await self.wallet_state_manager.add_interested_puzzle_hashes([cat_puzzle.get_tree_hash()], [self.id()])
+        return puzzle
+
+    async def get_new_puzzlehash(self) -> bytes32:
+        puzzle = await self.get_new_puzzle()
+        return puzzle.get_tree_hash()
+
+    def puzzle_for_pk(self, pubkey: G1Element) -> Program:
+        inner_puzzle = self.standard_wallet.puzzle_for_pk(pubkey)
+        puzzle = get_lockup_puzzle(
+            self.dao_cat_info.limitations_program_hash,
+            [],
+            inner_puzzle,
+        )
+        cat_puzzle: Program = construct_cat_puzzle(CAT_MOD, self.dao_cat_info.limitations_program_hash, puzzle)
+        return cat_puzzle
+
+    def puzzle_hash_for_pk(self, pubkey: G1Element) -> bytes32:
+        puzzle = self.puzzle_for_pk(pubkey)
+        return puzzle.get_tree_hash()
+
+    def require_derivation_paths(self) -> bool:
+        return True
+
+    async def get_cat_spendable_coins(self, records: Optional[Set[WalletCoinRecord]] = None) -> List[WalletCoinRecord]:
+        result: List[WalletCoinRecord] = []
+
+        record_list: Set[WalletCoinRecord] = await self.wallet_state_manager.get_spendable_coins_for_wallet(
+            self.id(), records
+        )
+
+        for record in record_list:
+            lineage = await self.get_lineage_proof_for_coin(record.coin)
+            if lineage is not None and not lineage.is_none():
+                result.append(record)
+
+        return result
+
+    async def get_spendable_balance(self, records: Optional[Set[WalletCoinRecord]] = None) -> uint128:
+        return uint128(0)
+
+    async def get_confirmed_balance(self, record_list: Optional[Set[WalletCoinRecord]] = None) -> uint128:
+        amount = 0
+        for coin in self.dao_cat_info.locked_coins:
+            amount += coin.coin.amount
+        return uint128(amount)
+
+    async def get_unconfirmed_balance(self, unspent_records: Optional[Set[WalletCoinRecord]] = None) -> uint128:
+        return uint128(0)
+
+    async def get_pending_change_balance(self) -> uint64:
+        return uint64(0)
+
+    async def select_coins(
+        self,
+        amount: uint64,
+        exclude: Optional[List[Coin]] = None,
+        min_coin_amount: Optional[uint64] = None,
+        max_coin_amount: Optional[uint64] = None,
+        excluded_coin_amounts: Optional[List[uint64]] = None,
+    ) -> Set[Coin]:
+        return set()
+
+    async def get_max_send_amount(self, unspent_records: Optional[Set[WalletCoinRecord]] = None) -> uint128:
+        return uint128(0)
+
+    async def get_votable_balance(
+        self,
+        proposal_id: Optional[bytes32] = None,
+        include_free_cats: bool = True,
+    ) -> uint64:
+        balance = 0
+        for coin in self.dao_cat_info.locked_coins:
+            if proposal_id is not None:
+                compatible = True
+                for active_vote in coin.active_votes:
+                    if active_vote == proposal_id:
+                        compatible = False
+                        break
+                if compatible:
+                    balance += coin.coin.amount
+            else:
+                balance += coin.coin.amount
+        if include_free_cats:
+            cat_wallet = self.wallet_state_manager.wallets[self.dao_cat_info.free_cat_wallet_id]
+            cat_balance = await cat_wallet.get_spendable_balance()
+            balance += cat_balance
+        return uint64(balance)
+
+    async def sign(self, spend_bundle: SpendBundle) -> SpendBundle:
+        sigs: List[G2Element] = []
+        for spend in spend_bundle.coin_spends:
+            args = match_cat_puzzle(uncurry_puzzle(spend.puzzle_reveal.to_program()))
+            if args is not None:
+                _, _, inner_puzzle = args
+                inner_puzzle = get_innerpuz_from_lockup_puzzle(inner_puzzle)
+                puzzle_hash = inner_puzzle.get_tree_hash()
+                private = await self.wallet_state_manager.get_private_key(puzzle_hash)
+                synthetic_secret_key = calculate_synthetic_secret_key(private, DEFAULT_HIDDEN_PUZZLE_HASH)
+                conditions = conditions_dict_for_solution(
+                    spend.puzzle_reveal.to_program(),
+                    spend.solution.to_program(),
+                    self.wallet_state_manager.constants.MAX_BLOCK_COST_CLVM,
+                )
+                if conditions is not None:
+                    synthetic_pk = synthetic_secret_key.get_g1()
+                    for pk, msg in pkm_pairs_for_conditions_dict(
+                        conditions, spend.coin.name(), self.wallet_state_manager.constants.AGG_SIG_ME_ADDITIONAL_DATA
+                    ):
+                        try:
+                            assert bytes(synthetic_pk) == pk
+                            sigs.append(AugSchemeMPL.sign(synthetic_secret_key, msg))
+                        except AssertionError:
+                            raise ValueError("This spend bundle cannot be signed by this DAO CAT wallet")
+
+        agg_sig = AugSchemeMPL.aggregate(sigs)
+        return SpendBundle.aggregate([spend_bundle, SpendBundle([], agg_sig)])
+
+    async def save_info(self, dao_cat_info: DAOCATInfo) -> None:
+        self.dao_cat_info = dao_cat_info
+        current_info = self.wallet_info
+        data_str = bytes(dao_cat_info).hex()
+        wallet_info = WalletInfo(current_info.id, current_info.name, current_info.type, data_str)
+        self.wallet_info = wallet_info
+        await self.wallet_state_manager.user_store.update_wallet(wallet_info)
+
+    def get_name(self) -> str:
+        return self.wallet_info.name
diff --git a/chia/wallet/dao_wallet/dao_info.py b/chia/wallet/dao_wallet/dao_info.py
new file mode 100644
index 000000000..cee71203b
--- /dev/null
+++ b/chia/wallet/dao_wallet/dao_info.py
@@ -0,0 +1,54 @@
+from __future__ import annotations
+
+from dataclasses import dataclass
+from typing import List, Optional, Tuple
+
+from chia.types.blockchain_format.coin import Coin
+from chia.types.blockchain_format.program import Program
+from chia.types.blockchain_format.sized_bytes import bytes32
+from chia.util.ints import uint32, uint64
+from chia.util.streamable import Streamable, streamable
+from chia.wallet.lineage_proof import LineageProof
+
+
+@streamable
+@dataclass(frozen=True)
+class ProposalInfo(Streamable):
+    proposal_id: bytes32  # this is launcher_id
+    inner_puzzle: Program
+    amount_voted: uint64
+    yes_votes: uint64
+    current_coin: Coin
+    current_innerpuz: Optional[Program]
+    timer_coin: Optional[Coin]  # if this is None then the proposal has finished
+    singleton_block_height: uint32  # Block height that current proposal singleton coin was created in
+    passed: Optional[bool]
+    closed: Optional[bool]
+
+
+@streamable
+@dataclass(frozen=True)
+class DAOInfo(Streamable):
+    treasury_id: bytes32
+    cat_wallet_id: uint32
+    dao_cat_wallet_id: uint32
+    proposals_list: List[ProposalInfo]
+    parent_info: List[Tuple[bytes32, Optional[LineageProof]]]  # {coin.name(): LineageProof}
+    current_treasury_coin: Optional[Coin]
+    current_treasury_innerpuz: Optional[Program]
+    singleton_block_height: uint32  # the block height that the current treasury singleton was created in
+    filter_below_vote_amount: uint64  # we ignore proposals with fewer votes than this - defaults to 1
+    assets: List[Optional[bytes32]]
+    current_height: uint64
+
+
+@streamable
+@dataclass(frozen=True)
+class DAORules(Streamable):
+    proposal_timelock: uint64
+    soft_close_length: uint64
+    attendance_required: uint64
+    pass_percentage: uint64
+    self_destruct_length: uint64
+    oracle_spend_delay: uint64
+    proposal_minimum_amount: uint64
diff --git a/chia/wallet/dao_wallet/dao_utils.py b/chia/wallet/dao_wallet/dao_utils.py
new file mode 100644
index 000000000..6621aeff0
--- /dev/null
+++ b/chia/wallet/dao_wallet/dao_utils.py
@@ -0,0 +1,742 @@
+from __future__ import annotations
+
+import logging
+from typing import Iterator, List, Optional, Tuple
+
+from clvm.casts import int_from_bytes
+from clvm.EvalError import EvalError
+
+from chia.types.blockchain_format.program import Program
+from chia.types.blockchain_format.sized_bytes import bytes32
+from chia.types.coin_spend import CoinSpend
+from chia.util.ints import uint64
+from chia.wallet.cat_wallet.cat_utils import CAT_MOD, CAT_MOD_HASH, match_cat_puzzle
+from chia.wallet.dao_wallet.dao_info import DAORules
+from chia.wallet.cat_wallet.cat_utils import CAT_MOD, CAT_MOD_HASH
+from chia.wallet.puzzles.load_clvm import load_clvm
+from chia.wallet.puzzles.p2_delegated_puzzle_or_hidden_puzzle import MOD
+from chia.wallet.singleton import create_singleton_puzzle, get_inner_puzzle_from_singleton
+from chia.wallet.uncurried_puzzle import UncurriedPuzzle
+
+SINGLETON_MOD: Program = load_clvm("singleton_top_layer_v1_1.clsp")
+SINGLETON_MOD_HASH: bytes32 = SINGLETON_MOD.get_tree_hash()
+SINGLETON_LAUNCHER: Program = load_clvm("singleton_launcher.clsp")
+SINGLETON_LAUNCHER_HASH: bytes32 = SINGLETON_LAUNCHER.get_tree_hash()
+DAO_LOCKUP_MOD: Program = load_clvm("dao_lockup.clsp")
+DAO_LOCKUP_MOD_HASH: bytes32 = DAO_LOCKUP_MOD.get_tree_hash()
+DAO_PROPOSAL_TIMER_MOD: Program = load_clvm("dao_proposal_timer.clsp")
+DAO_PROPOSAL_TIMER_MOD_HASH: bytes32 = DAO_PROPOSAL_TIMER_MOD.get_tree_hash()
+DAO_PROPOSAL_MOD: Program = load_clvm("dao_proposal.clsp")
+DAO_PROPOSAL_MOD_HASH: bytes32 = DAO_PROPOSAL_MOD.get_tree_hash()
+DAO_PROPOSAL_VALIDATOR_MOD: Program = load_clvm("dao_proposal_validator.clsp")
+DAO_PROPOSAL_VALIDATOR_MOD_HASH: bytes32 = DAO_PROPOSAL_VALIDATOR_MOD.get_tree_hash()
+DAO_TREASURY_MOD: Program = load_clvm("dao_treasury.clsp")
+DAO_TREASURY_MOD_HASH: bytes32 = DAO_TREASURY_MOD.get_tree_hash()
+SPEND_P2_SINGLETON_MOD: Program = load_clvm("dao_spend_p2_singleton_v2.clsp")
+SPEND_P2_SINGLETON_MOD_HASH: bytes32 = SPEND_P2_SINGLETON_MOD.get_tree_hash()
+DAO_FINISHED_STATE: Program = load_clvm("dao_finished_state.clsp")
+DAO_FINISHED_STATE_HASH: bytes32 = DAO_FINISHED_STATE.get_tree_hash()
+DAO_RESALE_PREVENTION: Program = load_clvm("dao_resale_prevention_layer.clsp")
+DAO_RESALE_PREVENTION_HASH: bytes32 = DAO_RESALE_PREVENTION.get_tree_hash()
+DAO_CAT_TAIL: Program = load_clvm("genesis_by_coin_id_or_singleton.clsp")
+DAO_CAT_TAIL_HASH: bytes32 = DAO_CAT_TAIL.get_tree_hash()
+DAO_CAT_LAUNCHER: Program = load_clvm("dao_cat_launcher.clsp")
+P2_CONDITIONS_MOD: Program = load_clvm("p2_conditions_curryable.clsp")
+P2_CONDITIONS_MOD_HASH: bytes32 = P2_CONDITIONS_MOD.get_tree_hash()
+DAO_SAFE_PAYMENT_MOD: Program = load_clvm("dao_safe_payment.clsp")
+DAO_SAFE_PAYMENT_MOD_HASH: bytes32 = DAO_SAFE_PAYMENT_MOD.get_tree_hash()
+P2_SINGLETON_MOD: Program = load_clvm("p2_singleton_via_delegated_puzzle.clsp")
+P2_SINGLETON_MOD_HASH: bytes32 = P2_SINGLETON_MOD.get_tree_hash()
+DAO_UPDATE_PROPOSAL_MOD: Program = load_clvm("dao_update_proposal.clsp")
+DAO_UPDATE_PROPOSAL_MOD_HASH: bytes32 = DAO_UPDATE_PROPOSAL_MOD.get_tree_hash()
+DAO_CAT_EVE: Program = load_clvm("dao_cat_eve.clsp")
+
+log = logging.Logger(__name__)
+
+
+def singleton_struct_for_id(id: bytes32) -> Program:
+    singleton_struct: Program = Program.to((SINGLETON_MOD_HASH, (id, SINGLETON_LAUNCHER_HASH)))
+    return singleton_struct
+
+
+def create_cat_launcher_for_singleton_id(id: bytes32) -> Program:
+    singleton_struct = singleton_struct_for_id(id)
+    return DAO_CAT_LAUNCHER.curry(singleton_struct)
+
+
+def curry_cat_eve(next_puzzle_hash: bytes32) -> Program:
+    return DAO_CAT_EVE.curry(next_puzzle_hash)
+
+
+def create_new_proposal_puzzle(
+    proposal_id: bytes32,
+    cat_tail_hash: bytes32,
+    treasury_id: bytes32,
+    proposed_puzzle_hash: bytes32,
+) -> Program:
+    singleton_struct: Program = Program.to((SINGLETON_MOD_HASH, (proposal_id, SINGLETON_LAUNCHER_HASH)))
+    puzzle: Program = DAO_PROPOSAL_MOD.curry(
+        singleton_struct,
+        DAO_PROPOSAL_MOD_HASH,
+        DAO_PROPOSAL_TIMER_MOD_HASH,
+        CAT_MOD_HASH,
+        DAO_TREASURY_MOD_HASH,
+        DAO_LOCKUP_MOD_HASH,
+        cat_tail_hash,
+        treasury_id,
+        0,
+        0,
+        "s",
+        proposed_puzzle_hash,
+    )
+    return puzzle
+
+
+def get_treasury_puzzle(dao_rules: DAORules, treasury_id: bytes32, cat_tail_hash: bytes32) -> Program:
+    # SINGLETON_STRUCT  ; (SINGLETON_MOD_HASH (SINGLETON_ID . LAUNCHER_PUZZLE_HASH))
+    # PROPOSAL_MOD_HASH
+    # PROPOSAL_TIMER_MOD_HASH
+    # CAT_MOD_HASH
+    # LOCKUP_MOD_HASH
+    # TREASURY_MOD_HASH
+    # CAT_TAIL_HASH
+    singleton_struct: Program = Program.to((SINGLETON_MOD_HASH, (treasury_id, SINGLETON_LAUNCHER_HASH)))
+    proposal_validator = DAO_PROPOSAL_VALIDATOR_MOD.curry(
+        singleton_struct,
+        DAO_PROPOSAL_MOD_HASH,
+        DAO_PROPOSAL_TIMER_MOD_HASH,
+        CAT_MOD_HASH,
+        DAO_LOCKUP_MOD_HASH,
+        DAO_TREASURY_MOD_HASH,
+        cat_tail_hash,
+        dao_rules.proposal_minimum_amount,
+        get_p2_singleton_puzzle(
+            treasury_id
+        ).get_tree_hash(),  # TODO: let people set this later - for now a hidden feature
+    )
+    # TREASURY_MOD_HASH
+    # PROPOSAL_VALIDATOR  ; this is the curryed proposal validator
+    # PROPOSAL_LENGTH
+    # PROPOSAL_SOFTCLOSE_LENGTH
+    # ATTENDANCE_REQUIRED
+    # PASS_MARGIN  ; this is a percentage 0 - 10,000 - 51% would be 5100
+    # PROPOSAL_SELF_DESTRUCT_TIME ; time in seconds after which proposals can be automatically closed
+    # ORACLE_SPEND_DELAY  ; timelock delay for oracle spend
+    puzzle = DAO_TREASURY_MOD.curry(
+        DAO_TREASURY_MOD_HASH,
+        proposal_validator,
+        dao_rules.proposal_timelock,
+        dao_rules.soft_close_length,
+        dao_rules.attendance_required,
+        dao_rules.pass_percentage,
+        dao_rules.self_destruct_length,
+        dao_rules.oracle_spend_delay,
+    )
+    return puzzle
+
+
+def get_proposal_validator(treasury_puz: Program) -> Program:
+    _, uncurried_args = treasury_puz.uncurry()
+    validator: Program = uncurried_args.rest().first()
+    return validator
+
+
+def create_announcement_condition_for_nft_spend(
+    # treasury_id: bytes32, TODO: is treasury_id needed here?
+    nft_id: bytes32,
+    target_address: bytes32,
+) -> Tuple[Program, Program]:
+    # TODO: this delegated puzzle does not actually work with NFTs - need to copy more of the code later
+    delegated_puzzle = Program.to([(1, [[51, target_address, 1]])])
+    announcement_condition = Program.to([62, Program.to([nft_id, delegated_puzzle.get_tree_hash()]).get_tree_hash()])
+    return announcement_condition, delegated_puzzle
+
+
+def get_update_proposal_puzzle(dao_rules: DAORules, proposal_validator: Program) -> Program:
+    update_proposal = DAO_UPDATE_PROPOSAL_MOD.curry(
+        DAO_TREASURY_MOD_HASH,
+        proposal_validator,
+        dao_rules.proposal_timelock,
+        dao_rules.soft_close_length,
+        dao_rules.attendance_required,
+        dao_rules.pass_percentage,
+        dao_rules.self_destruct_length,
+        dao_rules.oracle_spend_delay,
+    )
+    return update_proposal
+
+
+def get_dao_rules_from_update_proposal(puzzle: Program) -> DAORules:
+    mod, curried_args = puzzle.uncurry()
+    if mod != DAO_UPDATE_PROPOSAL_MOD:
+        raise ValueError("Not an update proposal.")
+    (
+        _,
+        proposal_validator,
+        proposal_timelock,
+        soft_close_length,
+        attendance_required,
+        pass_percentage,
+        self_destruct_length,
+        oracle_spend_delay,
+    ) = curried_args.as_iter()
+    # proposal_timelock: uint64
+    # soft_close_length: uint64
+    # attendance_required: uint64
+    # pass_percentage: uint64
+    # self_destruct_length: uint64
+    # oracle_spend_delay: uint64
+    curried_args = uncurry_proposal_validator(proposal_validator)
+    (
+        SINGLETON_STRUCT,
+        PROPOSAL_MOD_HASH,
+        PROPOSAL_TIMER_MOD_HASH,
+        CAT_MOD_HASH,
+        LOCKUP_MOD_HASH,
+        TREASURY_MOD_HASH,
+        CAT_TAIL_HASH,
+        PROPOSAL_MINIMUM_AMOUNT,
+        PAYOUT_PUZHASH,
+    ) = curried_args.as_iter()
+
+    dao_rules = DAORules(
+        proposal_timelock.as_int(),
+        soft_close_length.as_int(),
+        attendance_required.as_int(),
+        pass_percentage.as_int(),
+        self_destruct_length.as_int(),
+        oracle_spend_delay.as_int(),
+        PROPOSAL_MINIMUM_AMOUNT.as_int(),
+    )
+    return dao_rules
+
+
+def get_spend_p2_singleton_puzzle(
+    treasury_id: bytes32, xch_conditions: Optional[List], asset_conditions: Optional[List[Tuple]]  # type: ignore
+) -> Program:
+    # TODO: typecheck get_spend_p2_singleton_puzzle arguments
+    # TODO: add tests for get_spend_p2_singleton_puzzle: pass xch_conditions as Puzzle, List and ConditionWithArgs
+    #
+
+    # CAT_MOD_HASH
+    # CONDITIONS  ; XCH conditions, to be generated by the treasury
+    # LIST_OF_TAILHASH_CONDITIONS  ; the delegated puzzlehash must be curried in to the proposal.
+    #                        ; Puzzlehash is only run in the last coin for that asset
+    #                        ; ((TAIL_HASH CONDITIONS) (TAIL_HASH CONDITIONS)... )
+    # P2_SINGLETON_VIA_DELEGATED_PUZZLE_PUZHASH
+    treasury_struct = Program.to((SINGLETON_MOD_HASH, (treasury_id, SINGLETON_LAUNCHER_HASH)))
+    puzzle: Program = SPEND_P2_SINGLETON_MOD.curry(
+        treasury_struct,
+        CAT_MOD_HASH,
+        xch_conditions,
+        asset_conditions,
+        P2_SINGLETON_MOD.curry(treasury_struct).get_tree_hash(),
+    )
+    return puzzle
+
+
+def get_p2_singleton_puzzle(treasury_id: bytes32, asset_id: Optional[bytes32] = None) -> Program:
+    singleton_struct: Program = Program.to((SINGLETON_MOD_HASH, (treasury_id, SINGLETON_LAUNCHER_HASH)))
+    inner_puzzle = P2_SINGLETON_MOD.curry(singleton_struct)
+    if asset_id:
+        # CAT
+        puzzle = CAT_MOD.curry(CAT_MOD_HASH, asset_id, inner_puzzle)
+        return Program(puzzle)
+    else:
+        # XCH
+        return inner_puzzle
+
+
+def get_p2_singleton_puzhash(treasury_id: bytes32, asset_id: Optional[bytes32] = None) -> bytes32:
+    puz = get_p2_singleton_puzzle(treasury_id, asset_id)
+    assert puz is not None
+    return puz.get_tree_hash()
+
+
+def get_lockup_puzzle(
+    cat_tail_hash: bytes32, previous_votes_list: List[Optional[bytes32]], innerpuz: Program
+) -> Program:
+    puzzle: Program = DAO_LOCKUP_MOD.curry(
+        DAO_PROPOSAL_MOD_HASH,
+        SINGLETON_MOD_HASH,
+        SINGLETON_LAUNCHER_HASH,
+        DAO_LOCKUP_MOD_HASH,
+        CAT_MOD_HASH,
+        cat_tail_hash,
+        previous_votes_list,  # TODO: maybe format check this in this function
+        innerpuz,
+    )
+    return puzzle
+
+
+def get_latest_lockup_puzzle_for_coin_spend(parent_spend: CoinSpend, inner_puzzle: Optional[Program] = None) -> Program:
+    puzzle = get_inner_puzzle_from_singleton(parent_spend.puzzle_reveal)
+    assert isinstance(puzzle, Program)
+    solution = parent_spend.solution.to_program().rest().rest().first()
+    if solution.first() == Program.to(0):
+        return puzzle
+    new_proposal_id = solution.rest().rest().rest().first().as_atom()
+    return add_proposal_to_active_list(puzzle, new_proposal_id, inner_puzzle)
+
+
+def add_proposal_to_active_list(
+    lockup_puzzle: Program, proposal_id: bytes32, inner_puzzle: Optional[Program] = None
+) -> Program:
+    curried_args = uncurry_lockup(lockup_puzzle).as_iter()
+    (
+        PROPOSAL_MOD_HASH,
+        SINGLETON_MOD_HASH,
+        SINGLETON_LAUNCHER_PUZHASH,
+        LOCKUP_MOD_HASH,
+        CAT_MOD_HASH,
+        CAT_TAIL_HASH,
+        ACTIVE_VOTES,
+        INNERPUZ,
+    ) = curried_args
+    new_active_votes = Program.to(proposal_id).cons(ACTIVE_VOTES)  # (c proposal_id ACTIVE_VOTES)
+    if inner_puzzle is None:
+        inner_puzzle = INNERPUZ
+    return get_lockup_puzzle(CAT_TAIL_HASH, new_active_votes, inner_puzzle)
+
+
+def get_active_votes_from_lockup_puzzle(lockup_puzzle: Program) -> Program:
+    curried_args = uncurry_lockup(lockup_puzzle)
+    (
+        _PROPOSAL_MOD_HASH,
+        _SINGLETON_MOD_HASH,
+        _SINGLETON_LAUNCHER_HASH,
+        _LOCKUP_MOD_HASH,
+        _CAT_MOD_HASH,
+        _CAT_TAIL_HASH,
+        ACTIVE_VOTES,
+        _INNERPUZ,
+    ) = list(curried_args.as_iter())
+    return Program(ACTIVE_VOTES)
+
+
+def get_innerpuz_from_lockup_puzzle(lockup_puzzle: Program) -> Program:
+    curried_args = uncurry_lockup(lockup_puzzle)
+    (
+        _PROPOSAL_MOD_HASH,
+        _SINGLETON_MOD_HASH,
+        _SINGLETON_LAUNCHER_HASH,
+        _LOCKUP_MOD_HASH,
+        _CAT_MOD_HASH,
+        _CAT_TAIL_HASH,
+        _ACTIVE_VOTES,
+        INNERPUZ,
+    ) = list(curried_args.as_iter())
+    return Program(INNERPUZ)
+
+
+def get_proposal_puzzle(
+    *,
+    proposal_id: bytes32,
+    cat_tail_hash: bytes32,
+    treasury_id: bytes32,
+    votes_sum: uint64,
+    total_votes: uint64,
+    proposed_puzzle_hash: bytes32,
+) -> Program:
+    """
+    spend_or_update_flag can take on the following values, ranked from safest to most dangerous:
+    s for spend only
+    u for update only
+    d for dangerous (can do anything)
+    """
+    singleton_struct: Program = Program.to((SINGLETON_MOD_HASH, (proposal_id, SINGLETON_LAUNCHER_HASH)))
+    puzzle = DAO_PROPOSAL_MOD.curry(
+        singleton_struct,
+        DAO_PROPOSAL_MOD_HASH,
+        DAO_PROPOSAL_TIMER_MOD_HASH,
+        CAT_MOD_HASH,
+        DAO_TREASURY_MOD_HASH,
+        DAO_LOCKUP_MOD_HASH,
+        cat_tail_hash,
+        treasury_id,
+        votes_sum,
+        total_votes,
+        proposed_puzzle_hash,
+    )
+    return puzzle
+
+
+def get_proposal_timer_puzzle(
+    cat_tail_hash: bytes32,
+    proposal_id: bytes32,
+    treasury_id: bytes32,
+) -> Program:
+    parent_singleton_struct: Program = Program.to((SINGLETON_MOD_HASH, (proposal_id, SINGLETON_LAUNCHER_HASH)))
+    puzzle: Program = DAO_PROPOSAL_TIMER_MOD.curry(
+        DAO_PROPOSAL_MOD_HASH,
+        DAO_PROPOSAL_TIMER_MOD_HASH,
+        DAO_LOCKUP_MOD_HASH,
+        CAT_MOD_HASH,
+        cat_tail_hash,
+        parent_singleton_struct,
+        treasury_id,
+    )
+    return puzzle
+
+
+def get_treasury_rules_from_puzzle(puzzle_reveal: Optional[Program]) -> DAORules:
+    assert isinstance(puzzle_reveal, Program)
+    curried_args = uncurry_treasury(puzzle_reveal)
+    (
+        _DAO_TREASURY_MOD_HASH,
+        proposal_validator,
+        proposal_timelock,
+        soft_close_length,
+        attendance_required,
+        pass_percentage,
+        self_destruct_length,
+        oracle_spend_delay,
+    ) = curried_args
+    curried_args = uncurry_proposal_validator(proposal_validator)
+    (
+        SINGLETON_STRUCT,
+        PROPOSAL_MOD_HASH,
+        PROPOSAL_TIMER_MOD_HASH,
+        CAT_MOD_HASH,
+        LOCKUP_MOD_HASH,
+        TREASURY_MOD_HASH,
+        CAT_TAIL_HASH,
+        PROPOSAL_MINIMUM_AMOUNT,
+        PAYOUT_PUZHASH,
+    ) = curried_args.as_iter()
+    return DAORules(
+        uint64(int_from_bytes(proposal_timelock.as_atom())),
+        uint64(int_from_bytes(soft_close_length.as_atom())),
+        uint64(int_from_bytes(attendance_required.as_atom())),
+        uint64(int_from_bytes(pass_percentage.as_atom())),
+        uint64(int_from_bytes(self_destruct_length.as_atom())),
+        uint64(int_from_bytes(oracle_spend_delay.as_atom())),
+        uint64(PROPOSAL_MINIMUM_AMOUNT.as_int()),
+    )
+
+
+# This takes the treasury puzzle and treasury solution, not the full puzzle and full solution
+# This also returns the treasury puzzle and not the full puzzle
+def get_new_puzzle_from_treasury_solution(puzzle_reveal: Program, solution: Program) -> Optional[Program]:
+    # curried_args = uncurry_treasury(puzzle_reveal)
+    # (
+    #     DAO_TREASURY_MOD_HASH,
+    #     DAO_PROPOSAL_VALIDATOR_MOD,
+    #     proposal_timelock,
+    #     soft_close_length,
+    #     attendance_required_percentage,
+    #     proposal_pass_percentage,
+    #     proposal_self_destruct_length,
+    #     oracle_spend_delay,
+    # ) = curried_args
+    if solution.first() != Program.to(0):
+        # Proposal Spend
+        mod, curried_args = solution.at("rrrf").uncurry()
+        if mod == DAO_UPDATE_PROPOSAL_MOD:
+            (
+                DAO_TREASURY_MOD_HASH,
+                DAO_PROPOSAL_VALIDATOR,
+                proposal_timelock,
+                soft_close_length,
+                attendance_required,
+                pass_percentage,
+                self_destruct_length,
+                oracle_spend_delay,
+            ) = curried_args.as_iter()
+            return DAO_TREASURY_MOD.curry(
+                DAO_TREASURY_MOD_HASH,
+                DAO_PROPOSAL_VALIDATOR,
+                proposal_timelock,
+                soft_close_length,
+                attendance_required,
+                pass_percentage,
+                self_destruct_length,
+                oracle_spend_delay,
+            )
+        else:
+            return puzzle_reveal
+    else:
+        # Oracle Spend - treasury is unchanged
+        return puzzle_reveal
+
+
+# This takes the proposal puzzle and proposal solution, not the full puzzle and full solution
+# This also returns the proposal puzzle and not the full puzzle
+def get_new_puzzle_from_proposal_solution(puzzle_reveal: Program, solution: Program) -> Optional[Program]:
+    # Check if soft_close_length is in solution. If not, then add votes, otherwise close proposal
+    if solution.at("rrrrrrf") == Program.to(0):
+        curried_args = uncurry_proposal(puzzle_reveal)
+        (
+            SINGLETON_STRUCT,  # (SINGLETON_MOD_HASH, (SINGLETON_ID, LAUNCHER_PUZZLE_HASH))
+            PROPOSAL_MOD_HASH,
+            PROPOSAL_TIMER_MOD_HASH,
+            CAT_MOD_HASH,
+            TREASURY_MOD_HASH,
+            LOCKUP_MOD_HASH,
+            CAT_TAIL_HASH,
+            TREASURY_ID,
+            YES_VOTES,  # yes votes are +1, no votes don't tally - we compare yes_votes/total_votes at the end
+            TOTAL_VOTES,  # how many people responded
+            INNERPUZ_HASH,
+        ) = curried_args.as_iter()
+
+        added_votes = solution.at("ff").as_int()
+        new_total_votes = TOTAL_VOTES.as_int() + added_votes
+
+        if solution.at("rf") == Program.to(0):
+            # Vote Type: NO
+            new_yes_votes = YES_VOTES
+        else:
+            # Vote Type: YES
+            new_yes_votes = YES_VOTES.as_int() + added_votes
+        return DAO_PROPOSAL_MOD.curry(
+            SINGLETON_STRUCT,
+            DAO_PROPOSAL_MOD_HASH,
+            DAO_PROPOSAL_TIMER_MOD_HASH,
+            CAT_MOD_HASH,
+            DAO_TREASURY_MOD_HASH,
+            DAO_LOCKUP_MOD_HASH,
+            CAT_TAIL_HASH,
+            TREASURY_ID,
+            new_yes_votes,
+            new_total_votes,
+            INNERPUZ_HASH,
+        )
+    else:
+        return DAO_FINISHED_STATE
+
+
+def get_finished_state_puzzle(proposal_id: bytes32) -> Program:
+    singleton_struct: Program = Program.to((SINGLETON_MOD_HASH, (proposal_id, SINGLETON_LAUNCHER_HASH)))
+    finished_inner_puz: Program = DAO_FINISHED_STATE.curry(singleton_struct, DAO_FINISHED_STATE_HASH)
+    return create_singleton_puzzle(finished_inner_puz, proposal_id)
+
+
+def get_cat_tail_hash_from_treasury_puzzle(treasury_puzzle: Program) -> bytes32:
+    curried_args = uncurry_treasury(treasury_puzzle)
+    (
+        _DAO_TREASURY_MOD_HASH,
+        proposal_validator,
+        proposal_timelock,
+        soft_close_length,
+        attendance_required,
+        pass_percentage,
+        self_destruct_length,
+        oracle_spend_delay,
+    ) = curried_args
+
+    curried_args = uncurry_proposal_validator(proposal_validator)
+    (
+        SINGLETON_STRUCT,
+        PROPOSAL_MOD_HASH,
+        PROPOSAL_TIMER_MOD_HASH,
+        CAT_MOD_HASH,
+        LOCKUP_MOD_HASH,
+        TREASURY_MOD_HASH,
+        CAT_TAIL_HASH,
+        PROPOSAL_MINIMUM_AMOUNT,
+        PAYOUT_PUZHASH,
+    ) = curried_args.as_iter()
+    return bytes32(CAT_TAIL_HASH.as_atom())
+
+
+def get_proposed_puzzle_reveal_from_solution(solution: Program) -> Program:
+    prog = Program.from_bytes(bytes(solution))
+    return prog.at("rrfrrrrrf")
+
+
+def get_asset_id_from_puzzle(puzzle: Program) -> Optional[bytes32]:
+    mod, curried_args = puzzle.uncurry()
+    if mod == MOD:
+        return None
+    elif mod == CAT_MOD:
+        return bytes32(curried_args.at("rf").as_atom())
+    elif mod == SINGLETON_MOD:
+        return bytes32(curried_args.at("frf").as_atom())
+    else:
+        raise ValueError("DAO received coin with unknown puzzle")
+
+
+def uncurry_proposal_validator(proposal_validator_program: Program) -> Program:
+    try:
+        mod, curried_args = proposal_validator_program.uncurry()
+    except ValueError as e:
+        log.debug("Cannot uncurry treasury puzzle: error: %s", e)
+        raise e
+
+    if mod != DAO_PROPOSAL_VALIDATOR_MOD:
+        raise ValueError("Not a Treasury mod.")
+    return curried_args
+
+
+def uncurry_treasury(treasury_puzzle: Program) -> List[Program]:
+    try:
+        mod, curried_args = treasury_puzzle.uncurry()
+    except ValueError as e:
+        log.debug("Cannot uncurry treasury puzzle: error: %s", e)
+        raise e
+
+    if mod != DAO_TREASURY_MOD:
+        raise ValueError("Not a Treasury mod.")
+    return list(curried_args.as_iter())
+
+
+def uncurry_proposal(proposal_puzzle: Program) -> Program:
+    try:
+        mod, curried_args = proposal_puzzle.uncurry()
+    except ValueError as e:
+        log.debug("Cannot uncurry proposal puzzle: error: %s", e)
+        raise e
+
+    if mod != DAO_PROPOSAL_MOD:
+        raise ValueError("Not a dao proposal mod.")
+    return curried_args
+
+
+def uncurry_lockup(lockup_puzzle: Program) -> Program:
+    try:
+        mod, curried_args = lockup_puzzle.uncurry()
+    except ValueError as e:
+        log.debug("Cannot uncurry lockup puzzle: error: %s", e)
+        raise e
+
+    if mod != DAO_LOCKUP_MOD:
+        raise ValueError("Not a dao cat lockup mod.")
+    return curried_args
+
+
+def get_proposal_args(puzzle: Program) -> Tuple[str, Program]:
+    try:
+        mod, curried_args = puzzle.uncurry()
+    except ValueError as e:
+        log.debug("Cannot uncurry spend puzzle: error: %s", e)
+        raise e
+    if mod == SPEND_P2_SINGLETON_MOD:
+        return "spend", curried_args
+    elif mod == DAO_UPDATE_PROPOSAL_MOD:
+        return "update", curried_args
+    else:
+        raise ValueError("Unrecognised proposal type")
+
+
+def uncurry_spend_p2_singleton(spend_puzzle: Program) -> Program:
+    try:
+        mod, curried_args = spend_puzzle.uncurry()
+    except ValueError as e:
+        log.debug("Cannot uncurry spend puzzle: error: %s", e)
+        raise e
+
+    if mod != SPEND_P2_SINGLETON_MOD:
+        raise ValueError("Not a spend p2_singleton mod.")
+    return curried_args
+
+
+def generate_cat_tail(genesis_coin_id: bytes32, treasury_id: bytes32) -> Program:
+    dao_cat_launcher = create_cat_launcher_for_singleton_id(treasury_id).get_tree_hash()
+    puzzle = DAO_CAT_TAIL.curry(genesis_coin_id, dao_cat_launcher)
+    return puzzle
+
+
+# TODO: move curry_singleton to chia.wallet.singleton
+# TODO: Is this correct? See create_fullpuz
+# TODO: innerpuz type: is innerpuz a full reveal, or a hash?
+def curry_singleton(singleton_id: bytes32, innerpuz: Program) -> Program:
+    singleton_struct = Program.to((SINGLETON_MOD_HASH, (singleton_id, SINGLETON_LAUNCHER_HASH)))
+    return SINGLETON_MOD.curry(singleton_struct, innerpuz)
+
+
+def get_curry_vals_from_proposal_puzzle(proposal_puzzle: Program) -> Tuple[Program, Program, Program]:
+    curried_args = uncurry_proposal(proposal_puzzle)
+    (
+        SINGLETON_STRUCT,
+        PROPOSAL_MOD_HASH,
+        PROPOSAL_TIMER_MOD_HASH,
+        CAT_MOD_HASH,
+        TREASURY_MOD_HASH,
+        LOCKUP_MOD_HASH,
+        CAT_TAIL_HASH,
+        TREASURY_ID,
+        YES_VOTES,
+        TOTAL_VOTES,
+        PROPOSED_PUZ_HASH,
+    ) = curried_args.as_iter()
+    return YES_VOTES, TOTAL_VOTES, PROPOSED_PUZ_HASH
+
+
+# This is for use in the WalletStateManager to determine the type of coin received
+def match_treasury_puzzle(mod: Program, curried_args: Program) -> Optional[Iterator[Program]]:
+    """
+    Given a puzzle test if it's a Treasury, if it is, return the curried arguments
+    :param mod: Puzzle
+    :param curried_args: Puzzle
+    :return: Curried parameters
+    """
+    try:
+        if mod == SINGLETON_MOD:
+            mod, curried_args = curried_args.rest().first().uncurry()
+            if mod == DAO_TREASURY_MOD:
+                return curried_args.first().as_iter()  # type: ignore[no-any-return]
+    except ValueError:
+        import traceback
+
+        print(f"exception: {traceback.format_exc()}")
+
+    return None
+
+
+# This is for use in the WalletStateManager to determine the type of coin received
+def match_proposal_puzzle(mod: Program, curried_args: Program) -> Optional[Iterator[Program]]:
+    """
+    Given a puzzle test if it's a Proposal, if it is, return the curried arguments
+    :param curried_args: Puzzle
+    :return: Curried parameters
+    """
+    try:
+        if mod == SINGLETON_MOD:
+            mod, curried_args = curried_args.rest().first().uncurry()
+            if mod == DAO_PROPOSAL_MOD:
+                return curried_args.as_iter()  # type: ignore[no-any-return]
+    except ValueError:
+        import traceback
+
+        print(f"exception: {traceback.format_exc()}")
+    return None
+
+
+# This is used in WSM to determine whether we have a dao funding spend
+def match_funding_puzzle(uncurried: UncurriedPuzzle, solution: Program) -> Optional[bool]:
+    # TODO: handle case where solution is for existing p2_singleton
+    try:
+        if match_cat_puzzle(uncurried):
+            conditions = solution.at("frfr").as_iter()
+        elif uncurried.mod == MOD:
+            conditions = solution.at("rfr").as_iter()
+        else:
+            return None
+        for cond in conditions:
+            if (cond.list_len() == 4) and (cond.first().as_int() == 51):
+                maybe_treasury_id = cond.at("rrrff")
+                if cond.at("rf") == get_p2_singleton_puzhash(maybe_treasury_id):
+                    return True
+    except (ValueError, EvalError):
+        import traceback
+
+        print(f"exception: {traceback.format_exc()}")
+    return None
+
+
+def match_dao_cat_puzzle(uncurried: UncurriedPuzzle) -> Optional[Iterator[Program]]:
+    try:
+        if uncurried.mod == CAT_MOD:
+            arg_list = list(uncurried.args.as_iter())
+            maybe_dao_lockup = uncurried.args.at("rrf").uncurry()
+            if maybe_dao_lockup[0] == DAO_LOCKUP_MOD:
+                innerpuz = maybe_dao_lockup[1].at("rrrrrrrf").uncurry()[0]
+                arg_list[2] = innerpuz
+                dao_cat_args: Iterator[Program] = Program.to(arg_list).as_iter()
+                return dao_cat_args
+    except ValueError:
+        import traceback
+
+        print(f"exception: {traceback.format_exc()}")
+    return None
diff --git a/chia/wallet/dao_wallet/dao_wallet.py b/chia/wallet/dao_wallet/dao_wallet.py
new file mode 100644
index 000000000..cc0922a96
--- /dev/null
+++ b/chia/wallet/dao_wallet/dao_wallet.py
@@ -0,0 +1,2769 @@
+from __future__ import annotations
+
+import copy
+import dataclasses
+import json
+import logging
+import re
+import time
+from secrets import token_bytes
+from typing import TYPE_CHECKING, Any, ClassVar, Dict, List, Optional, Set, Tuple, Union, cast
+
+from blspy import AugSchemeMPL, G1Element, G2Element
+from clvm.casts import int_from_bytes
+
+import chia.wallet.singleton
+from chia.full_node.full_node_api import FullNodeAPI
+
+# from chia.protocols import wallet_protocol
+from chia.protocols.wallet_protocol import CoinState, RequestBlockHeader, RespondBlockHeader
+from chia.server.ws_connection import WSChiaConnection
+from chia.types.announcement import Announcement
+from chia.types.blockchain_format.coin import Coin
+from chia.types.blockchain_format.program import Program
+from chia.types.blockchain_format.sized_bytes import bytes32
+from chia.types.coin_spend import CoinSpend
+from chia.types.condition_opcodes import ConditionOpcode
+from chia.types.spend_bundle import SpendBundle
+from chia.util.ints import uint32, uint64, uint128
+from chia.wallet import singleton
+from chia.wallet.cat_wallet.cat_utils import CAT_MOD, SpendableCAT, construct_cat_puzzle
+from chia.wallet.cat_wallet.cat_utils import get_innerpuzzle_from_puzzle as get_innerpuzzle_from_cat_puzzle
+from chia.wallet.cat_wallet.cat_utils import unsigned_spend_bundle_for_spendable_cats
+from chia.wallet.cat_wallet.cat_wallet import CATWallet
+
+# from chia.wallet.cat_wallet.dao_cat_info import LockedCoinInfo
+from chia.wallet.cat_wallet.dao_cat_wallet import DAOCATWallet
+from chia.wallet.coin_selection import select_coins
+from chia.wallet.dao_wallet.dao_info import DAOInfo, DAORules, ProposalInfo
+from chia.wallet.dao_wallet.dao_utils import (
+    DAO_FINISHED_STATE,
+    DAO_PROPOSAL_MOD,
+    DAO_TREASURY_MOD,
+    DAO_TREASURY_MOD_HASH,
+    SINGLETON_LAUNCHER,
+    create_cat_launcher_for_singleton_id,
+    curry_cat_eve,
+    curry_singleton,
+    generate_cat_tail,
+    get_active_votes_from_lockup_puzzle,
+    get_asset_id_from_puzzle,
+    get_curry_vals_from_proposal_puzzle,
+    get_dao_rules_from_update_proposal,
+    get_finished_state_puzzle,
+    get_innerpuz_from_lockup_puzzle,
+    get_new_puzzle_from_proposal_solution,
+    get_new_puzzle_from_treasury_solution,
+    get_p2_singleton_puzhash,
+    get_p2_singleton_puzzle,
+    get_proposal_args,
+    get_proposal_puzzle,
+    get_proposal_timer_puzzle,
+    get_proposal_validator,
+    get_proposed_puzzle_reveal_from_solution,
+    get_spend_p2_singleton_puzzle,
+    get_treasury_puzzle,
+    get_treasury_rules_from_puzzle,
+    get_update_proposal_puzzle,
+    singleton_struct_for_id,
+    uncurry_proposal,
+    uncurry_proposal_validator,
+    uncurry_treasury,
+)
+
+# from chia.wallet.dao_wallet.dao_wallet_puzzles import get_dao_inner_puzhash_by_p2
+from chia.wallet.lineage_proof import LineageProof
+from chia.wallet.cat_wallet.cat_utils import CAT_MOD
+from chia.wallet.singleton import (  # get_singleton_id_from_puzzle,
+    get_inner_puzzle_from_singleton,
+    get_most_recent_singleton_coin_from_coin_spend,
+    get_singleton_id_from_puzzle,
+)
+from chia.wallet.singleton_record import SingletonRecord
+from chia.wallet.transaction_record import TransactionRecord
+from chia.wallet.util.transaction_type import TransactionType
+from chia.wallet.util.wallet_sync_utils import fetch_coin_spend
+from chia.wallet.util.wallet_types import WalletType
+from chia.wallet.wallet import Wallet
+from chia.wallet.wallet_coin_record import WalletCoinRecord
+from chia.wallet.wallet_info import WalletInfo
+from chia.wallet.wallet_protocol import WalletProtocol
+
+# from chia.wallet.wallet_state_manager import WalletStateManager
+
+# from chia.wallet.wallet_singleton_store import WalletSingletonStore
+
+
+class DAOWallet(WalletProtocol):
+    """
+    This is a wallet in the sense that it conforms to the interface needed by WalletStateManager.
+    It is not a user-facing wallet. A user cannot spend or receive XCH though a wallet of this type.
+
+    It is expected that a wallet of type DAOCATWallet will be the user-facing wallet, and use a
+    DAOWallet for state-tracking of the Treasury Singleton and its associated Proposals.
+
+    State change Spends (spends this user creates, either from DAOWallet or DAOCATWallet:
+      * Create a proposal
+      * Initial Vote on proposal
+      * Add more votes to a proposal
+      * Collect finished state of a Proposal - spend to read the oracle result and Get our (CAT) coins back
+      * Anyone can send money to the Treasury, whether in possession of a voting CAT or not
+
+    Incoming spends we listen for:
+      * Update Treasury state if treasury is spent
+      * Hear about a finished proposal
+      * Hear about a new proposal -- check interest threshold (how many votes)
+      * Get Updated Proposal Data
+    """
+
+    if TYPE_CHECKING:
+        from chia.wallet.wallet_protocol import WalletProtocol
+
+        _protocol_check: ClassVar[WalletProtocol] = cast("DAOWallet", None)
+
+    wallet_state_manager: Any
+    log: logging.Logger
+    wallet_info: WalletInfo
+    dao_info: DAOInfo
+    dao_rules: DAORules
+    standard_wallet: Wallet
+    wallet_id: uint32
+
+    @staticmethod
+    async def create_new_dao_and_wallet(
+        wallet_state_manager: Any,
+        wallet: Wallet,
+        amount_of_cats: uint64,
+        dao_rules: DAORules,
+        filter_amount: uint64 = uint64(1),
+        name: Optional[str] = None,
+        fee: uint64 = uint64(0),
+    ) -> DAOWallet:
+        """
+        Create a brand new DAO wallet
+        This must be called under the wallet state manager lock
+        :param wallet_state_manager: Wallet state manager
+        :param wallet: Standard wallet
+        :param amount_of_cats: Initial amount of voting CATs
+        :param name: Wallet name
+        :param fee: transaction fee
+        :return: DAO wallet
+        """
+
+        self = DAOWallet()
+        self.wallet_state_manager = wallet_state_manager
+        if name is None:
+            name = self.generate_wallet_name()
+
+        self.standard_wallet = wallet
+        self.log = logging.getLogger(name if name else __name__)
+        std_wallet_id = self.standard_wallet.wallet_id
+        bal = await wallet_state_manager.get_confirmed_balance_for_wallet(std_wallet_id)
+        if amount_of_cats > bal:
+            raise ValueError(f"Your balance of {bal} mojos is not enough to create {amount_of_cats} CATs")
+
+        self.dao_info = DAOInfo(
+            treasury_id=bytes32([0] * 32),
+            cat_wallet_id=uint32(0),
+            dao_cat_wallet_id=uint32(0),
+            proposals_list=[],
+            parent_info=[],
+            current_treasury_coin=None,
+            current_treasury_innerpuz=None,
+            singleton_block_height=uint32(0),
+            filter_below_vote_amount=filter_amount,
+            assets=[],
+            current_height=uint64(0),
+        )
+        self.dao_rules = dao_rules
+        info_as_string = json.dumps(self.dao_info.to_json_dict())
+        self.wallet_info = await wallet_state_manager.user_store.create_wallet(
+            name, WalletType.DAO.value, info_as_string
+        )
+        self.wallet_id = self.wallet_info.id
+        std_wallet_id = self.standard_wallet.wallet_id
+        bal = await wallet_state_manager.get_confirmed_balance_for_wallet(std_wallet_id)
+
+        try:
+            await self.generate_new_dao(
+                amount_of_cats,
+                fee=fee,
+            )
+        except Exception as e_info:
+            await wallet_state_manager.user_store.delete_wallet(self.id())
+            self.log.error(f"Failed to create dao wallet: {e_info}")
+            raise
+
+        await self.wallet_state_manager.add_new_wallet(self)
+
+        # Now the dao wallet is created we can create the dao_cat wallet
+        cat_wallet: CATWallet = self.wallet_state_manager.wallets[self.dao_info.cat_wallet_id]
+        cat_tail = cat_wallet.cat_info.limitations_program_hash
+        new_dao_cat_wallet = await DAOCATWallet.get_or_create_wallet_for_cat(
+            self.wallet_state_manager, self.standard_wallet, cat_tail.hex()
+        )
+        dao_cat_wallet_id = new_dao_cat_wallet.wallet_info.id
+        dao_info = DAOInfo(
+            self.dao_info.treasury_id,
+            self.dao_info.cat_wallet_id,
+            dao_cat_wallet_id,
+            self.dao_info.proposals_list,
+            self.dao_info.parent_info,
+            self.dao_info.current_treasury_coin,
+            self.dao_info.current_treasury_innerpuz,
+            self.dao_info.singleton_block_height,
+            self.dao_info.filter_below_vote_amount,
+            self.dao_info.assets,
+            self.dao_info.current_height,
+        )
+        await self.save_info(dao_info)
+
+        return self
+
+    @staticmethod
+    async def create_new_dao_wallet_for_existing_dao(
+        wallet_state_manager: Any,
+        main_wallet: Wallet,
+        treasury_id: bytes32,
+        filter_amount: uint64 = uint64(1),
+        name: Optional[str] = None,
+    ) -> DAOWallet:
+        """
+        Create a DAO wallet for existing DAO
+        :param wallet_state_manager: Wallet state manager
+        :param main_wallet: Standard wallet
+        :param name: Wallet name
+        :return: DAO wallet
+        """
+        self = DAOWallet()
+        self.wallet_state_manager = wallet_state_manager
+        if name is None:
+            name = self.generate_wallet_name()
+
+        self.standard_wallet = main_wallet
+        self.log = logging.getLogger(name if name else __name__)
+        self.log.info("Creating DAO wallet for existent DAO ...")
+        self.dao_info = DAOInfo(
+            treasury_id,  # treasury_id: bytes32
+            uint32(0),  # cat_wallet_id: uint64
+            uint32(0),  # dao_cat_wallet_id: uint64
+            [],  # proposals_list: List[ProposalInfo]
+            [],  # treasury_id: bytes32
+            None,  # current_coin
+            None,  # current innerpuz
+            uint32(0),
+            filter_amount,
+            [],
+            uint64(0),
+        )
+        info_as_string = json.dumps(self.dao_info.to_json_dict())
+        self.wallet_info = await wallet_state_manager.user_store.create_wallet(
+            name, WalletType.DAO.value, info_as_string
+        )
+        await self.resync_treasury_state()
+        await self.wallet_state_manager.add_new_wallet(self)
+        await self.save_info(self.dao_info)
+        if self.wallet_info is None:
+            raise ValueError("Internal Error")
+        self.wallet_id = self.wallet_info.id
+
+        # Now the dao wallet is created we can create the dao_cat wallet
+        cat_wallet: CATWallet = self.wallet_state_manager.wallets[self.dao_info.cat_wallet_id]
+        cat_tail = cat_wallet.cat_info.limitations_program_hash
+        new_dao_cat_wallet = await DAOCATWallet.get_or_create_wallet_for_cat(
+            self.wallet_state_manager, self.standard_wallet, cat_tail.hex()
+        )
+        dao_cat_wallet_id = new_dao_cat_wallet.wallet_info.id
+        dao_info = DAOInfo(
+            self.dao_info.treasury_id,
+            self.dao_info.cat_wallet_id,
+            dao_cat_wallet_id,
+            self.dao_info.proposals_list,
+            self.dao_info.parent_info,
+            self.dao_info.current_treasury_coin,
+            self.dao_info.current_treasury_innerpuz,
+            self.dao_info.singleton_block_height,
+            self.dao_info.filter_below_vote_amount,
+            self.dao_info.assets,
+            self.dao_info.current_height,
+        )
+        await self.save_info(dao_info)
+
+        # add interested puzzle hash so we can folllow treasury funds
+        await self.wallet_state_manager.add_interested_puzzle_hashes([self.dao_info.treasury_id], [self.id()])
+        return self
+
+    @staticmethod
+    async def create_new_dao_wallet_from_coin_spend(
+        wallet_state_manager: Any,
+        wallet: Wallet,
+        launch_coin: Coin,
+        inner_puzzle: Program,
+        coin_spend: CoinSpend,
+        block_height: Optional[int],  # this is included in CoinState, pass it in from WSM
+        name: Optional[str] = None,
+    ) -> DAOWallet:
+        """
+        Create a DID wallet from a transfer
+        :param wallet_state_manager: Wallet state manager
+        :param wallet: Main wallet
+        :param launch_coin: The launch coin of the DID
+        :param inner_puzzle: DID inner puzzle
+        :param coin_spend: DID transfer spend
+        :param name: Wallet name
+        :return: DID wallet
+        """
+
+        self = DAOWallet()
+        self.wallet_state_manager = wallet_state_manager
+        if name is None:
+            name = self.generate_wallet_name()
+        self.standard_wallet = wallet
+        self.log = logging.getLogger(name if name else __name__)
+
+        self.log.info(f"Creating DAO wallet from a coin spend {launch_coin.name()}  ...")
+        # Create did info from the coin spend
+        curried_args = uncurry_treasury(inner_puzzle)
+        if curried_args is None:
+            raise ValueError("Cannot uncurry the DAO puzzle.")
+        (
+            _DAO_TREASURY_MOD_HASH,
+            proposal_validator,
+            proposal_timelock,
+            soft_close_length,
+            attendance_required,
+            pass_percentage,
+            self_destruct_length,
+            oracle_spend_delay,
+        ) = curried_args
+        # full_solution: Program = Program.from_bytes(bytes(coin_spend.solution))
+        # inner_solution: Program = full_solution.rest().rest().first()
+        # recovery_list: List[bytes32] = []
+        curried_args = uncurry_proposal_validator(proposal_validator)
+        (
+            SINGLETON_STRUCT,
+            PROPOSAL_MOD_HASH,
+            PROPOSAL_TIMER_MOD_HASH,
+            CAT_MOD_HASH,
+            LOCKUP_MOD_HASH,
+            TREASURY_MOD_HASH,
+            CAT_TAIL_HASH,
+            PROPOSAL_MINIMUM_AMOUNT,
+            PAYOUT_PUZHASH,
+        ) = curried_args.as_iter()
+
+        # TODO: how is this working with our system about receiving CATs you haven't subscribed to?
+        cat_wallet = await CATWallet.get_or_create_wallet_for_cat(
+            wallet_state_manager,
+            wallet,
+            CAT_TAIL_HASH.as_atom().hex(),
+        )
+
+        dao_cat_wallet = await DAOCATWallet.get_or_create_wallet_for_cat(
+            wallet_state_manager,
+            wallet,
+            CAT_TAIL_HASH.as_atom().hex(),
+        )
+
+        current_coin = get_most_recent_singleton_coin_from_coin_spend(coin_spend)
+        self.dao_rules = get_treasury_rules_from_puzzle(inner_puzzle)
+        assert isinstance(block_height, int)
+        dao_info = DAOInfo(
+            launch_coin.name(),
+            cat_wallet.id(),
+            dao_cat_wallet.id(),
+            [],
+            [],
+            current_coin,
+            inner_puzzle,
+            uint32(block_height),
+            uint64(1),  # TODO: how should we deal with filter integer? Just update it later?
+            [],
+            uint64(0),
+        )
+
+        info_as_string = json.dumps(dao_info.to_json_dict())
+
+        self.wallet_info = await wallet_state_manager.user_store.create_wallet(
+            name, WalletType.DAO.value, info_as_string
+        )
+
+        await self.wallet_state_manager.add_new_wallet(self)
+        await self.wallet_state_manager.update_wallet_puzzle_hashes(self.wallet_info.id)
+
+        self.log.info(f"New DAO wallet created {info_as_string}.")
+        if self.wallet_info is None:
+            raise ValueError("Internal Error")
+        self.wallet_id = self.wallet_info.id
+        return self
+
+    @staticmethod
+    async def create_new_dao_for_existing_cat(
+        wallet_state_manager: Any,
+        wallet: Wallet,
+        tail_hash: bytes32,
+        dao_rules: DAORules,
+        filter_amount: uint64 = uint64(1),
+        name: Optional[str] = None,
+        fee: uint64 = uint64(0),
+    ) -> DAOWallet:
+        """
+        Create a brand new DAO wallet
+        This must be called under the wallet state manager lock
+        :param wallet_state_manager: Wallet state manager
+        :param wallet: Standard wallet
+        :param name: Wallet name
+        :param fee: transaction fee
+        :return: DAO wallet
+        """
+
+        self = DAOWallet()
+        self.wallet_state_manager = wallet_state_manager
+        if name is None:
+            name = self.generate_wallet_name()
+
+        self.standard_wallet = wallet
+        self.log = logging.getLogger(name if name else __name__)
+
+        self.dao_info = DAOInfo(
+            bytes32([0] * 32),
+            uint32(0),
+            uint32(0),
+            [],
+            [],
+            None,
+            None,
+            uint32(0),
+            filter_amount,
+            [],
+            uint64(0),
+        )
+        self.dao_rules = dao_rules
+        info_as_string = json.dumps(self.dao_info.to_json_dict())
+        self.wallet_info = await wallet_state_manager.user_store.create_wallet(
+            name, WalletType.DAO.value, info_as_string
+        )
+        self.wallet_id = self.wallet_info.id
+
+        try:
+            launcher_spend = await self.generate_new_dao(
+                None,
+                cat_tail_hash=tail_hash,
+                fee=fee,
+            )
+        except Exception:
+            await wallet_state_manager.user_store.delete_wallet(self.id())
+            raise
+
+        if launcher_spend is None:
+            await wallet_state_manager.user_store.delete_wallet(self.id())
+            raise ValueError("Failed to create spend.")
+        await self.wallet_state_manager.add_new_wallet(self)
+
+        # Now that the dao wallet is created we can create the dao_cat wallet
+        cat_wallet: CATWallet = self.wallet_state_manager.wallets[self.dao_info.cat_wallet_id]
+        cat_tail = cat_wallet.cat_info.limitations_program_hash
+        new_dao_cat_wallet = await DAOCATWallet.get_or_create_wallet_for_cat(
+            self.wallet_state_manager, self.standard_wallet, cat_tail.hex()
+        )
+        dao_cat_wallet_id = new_dao_cat_wallet.wallet_info.id
+        dao_info = DAOInfo(
+            self.dao_info.treasury_id,
+            self.dao_info.cat_wallet_id,
+            dao_cat_wallet_id,
+            self.dao_info.proposals_list,
+            self.dao_info.parent_info,
+            self.dao_info.current_treasury_coin,
+            self.dao_info.current_treasury_innerpuz,
+            self.dao_info.singleton_block_height,
+            self.dao_info.filter_below_vote_amount,
+            self.dao_info.assets,
+            self.dao_info.current_height,
+        )
+        await self.save_info(dao_info)
+        # breakpoint()
+        # add interested puzzle hash so we can folllow treasury funds and proposals
+        await self.wallet_state_manager.add_interested_puzzle_hashes([self.dao_info.treasury_id], [self.id()])
+
+        return self
+
+    @staticmethod
+    async def create(
+        wallet_state_manager: Any,
+        wallet: Wallet,
+        wallet_info: WalletInfo,
+        name: Optional[str] = None,
+    ) -> DAOWallet:
+        """
+        Create a DID wallet based on the local database
+        :param wallet_state_manager: Wallet state manager
+        :param wallet: Standard wallet
+        :param wallet_info: Serialized WalletInfo
+        :param name: Wallet name
+        :return:
+        """
+        self = DAOWallet()
+        self.log = logging.getLogger(name if name else __name__)
+        self.wallet_state_manager = wallet_state_manager
+        self.wallet_info = wallet_info
+        self.wallet_id = wallet_info.id
+        self.standard_wallet = wallet
+        self.wallet_info = wallet_info
+        self.dao_info = DAOInfo.from_json_dict(json.loads(wallet_info.data))
+        self.dao_rules = get_treasury_rules_from_puzzle(self.dao_info.current_treasury_innerpuz)
+        return self
+
+    @classmethod
+    def type(cls) -> WalletType:
+        return WalletType.DAO
+
+    def id(self) -> uint32:
+        return self.wallet_info.id
+
+    async def get_confirmed_balance(self, record_list: Optional[Set[WalletCoinRecord]] = None) -> uint128:
+        if record_list is None:
+            record_list = await self.wallet_state_manager.coin_store.get_unspent_coins_for_wallet(self.id())
+
+        amount: uint128 = uint128(0)
+        for record in record_list:
+            parent = self.get_parent_for_coin(record.coin)
+            if parent is not None:
+                amount = uint128(amount + record.coin.amount)
+
+        self.log.info(f"Confirmed balance for dao wallet is {amount}")
+        return uint128(amount)
+
+    async def get_pending_change_balance(self) -> uint64:
+        # No spendable or receivable value
+        return uint64(0)
+
+    async def get_unconfirmed_balance(self, record_list: Optional[Set[WalletCoinRecord]] = None) -> uint128:
+        unc_bal = await self.wallet_state_manager.get_unconfirmed_balance(self.id(), record_list)
+        return uint128(unc_bal)
+
+    async def select_coins(
+        self,
+        amount: uint64,
+        exclude: Optional[List[Coin]] = None,
+        min_coin_amount: Optional[uint64] = None,
+        max_coin_amount: Optional[uint64] = None,
+        excluded_coin_amounts: Optional[List[uint64]] = None,
+    ) -> Set[Coin]:
+        """
+        Returns a set of coins that can be used for generating a new transaction.
+        Note: Must be called under wallet state manager lock
+        There is no need for max/min coin amount or excluded amount becuase the dao treasury should
+        always be a single coin with amount 1
+        """
+
+        spendable_amount: uint128 = await self.get_spendable_balance()
+
+        # Only DID Wallet will return none when this happens, so we do it before select_coins would throw an error.
+        if amount > spendable_amount:
+            self.log.warning(f"Can't select {amount}, from spendable {spendable_amount} for wallet id {self.id()}")
+            return set()
+
+        spendable_coins: List[WalletCoinRecord] = list(
+            await self.wallet_state_manager.get_spendable_coins_for_wallet(self.wallet_info.id)
+        )
+
+        # Try to use coins from the store, if there isn't enough of "unused"
+        # coins use change coins that are not confirmed yet
+        unconfirmed_removals: Dict[bytes32, Coin] = await self.wallet_state_manager.unconfirmed_removals_for_wallet(
+            self.wallet_info.id
+        )
+        if max_coin_amount is None:
+            max_coin_amount = uint64(self.wallet_state_manager.constants.MAX_COIN_AMOUNT)
+        coins = await select_coins(
+            spendable_amount,
+            max_coin_amount,
+            spendable_coins,
+            unconfirmed_removals,
+            self.log,
+            uint128(amount),
+            exclude,
+            min_coin_amount,
+        )
+        assert sum(c.amount for c in coins) >= amount
+        return coins
+
+    async def coin_added(self, coin: Coin, height: uint32, peer: WSChiaConnection) -> None:
+        """Notification from wallet state manager that wallet has been received."""
+        self.log.info(f"DAOWallet.coin_added() called with the coin: {coin.name()}:{coin}.")
+        wallet_node: Any = self.wallet_state_manager.wallet_node
+        peer = wallet_node.get_full_node_peer()
+        if peer is None:
+            raise ValueError("Could not find any peers to request puzzle and solution from")
+        # Get the parent coin spend
+        cs = (await wallet_node.get_coin_state([coin.parent_coin_info], peer, height))[0]
+        parent_spend = await fetch_coin_spend(cs.spent_height, cs.coin, peer)
+
+        # check if it's a singleton and add to singleton_store
+        singleton_id = get_singleton_id_from_puzzle(parent_spend.puzzle_reveal)
+        if singleton_id:
+            await self.wallet_state_manager.singleton_store.add_spend(self.id(), parent_spend, height)
+        else:
+            # funding coin
+            asset_id = get_asset_id_from_puzzle(parent_spend.puzzle_reveal.to_program())
+            if asset_id not in self.dao_info.assets:
+                new_asset_list = self.dao_info.assets.copy()
+                new_asset_list.append(asset_id)
+                dao_info = dataclasses.replace(self.dao_info, assets=new_asset_list)
+                await self.save_info(dao_info)
+        return
+
+    async def is_spend_retrievable(self, coin_id: bytes32) -> bool:
+        wallet_node = self.wallet_state_manager.wallet_node
+        peer: WSChiaConnection = wallet_node.get_full_node_peer()
+        children = await wallet_node.fetch_children(coin_id, peer)
+        return len(children) > 0
+
+    def get_cat_tail_hash(self) -> bytes32:
+        cat_wallet: CATWallet = self.wallet_state_manager.wallets[self.dao_info.cat_wallet_id]
+        cat_tail_hash: bytes32 = cat_wallet.cat_info.limitations_program_hash
+        return cat_tail_hash
+
+    async def adjust_filter_level(self, new_filter_level: uint64) -> None:
+        dao_info = DAOInfo(
+            self.dao_info.treasury_id,
+            self.dao_info.cat_wallet_id,
+            self.dao_info.dao_cat_wallet_id,
+            self.dao_info.proposals_list,
+            self.dao_info.parent_info,
+            self.dao_info.current_treasury_coin,
+            self.dao_info.current_treasury_innerpuz,
+            self.dao_info.singleton_block_height,
+            new_filter_level,
+            self.dao_info.assets,
+            self.dao_info.current_height,
+        )
+        await self.save_info(dao_info)
+
+    async def resync_treasury_state(self) -> None:
+        parent_coin_id: bytes32 = self.dao_info.treasury_id
+        wallet_node: Any = self.wallet_state_manager.wallet_node
+        peer: WSChiaConnection = wallet_node.get_full_node_peer()
+        if peer is None:
+            raise ValueError("Could not find any peers to request puzzle and solution from")
+
+        children = await wallet_node.fetch_children(parent_coin_id, peer)
+        parent_coin = None
+        parent_parent_coin = None
+        assert len(children) > 0
+        while len(children) > 0:
+            children = await wallet_node.fetch_children(parent_coin_id, peer)
+            if len(children) == 0:
+                break
+
+            children_state_list: List[CoinState] = [child for child in children if child.coin.amount % 2 == 1]
+            if len(children_state_list) == 0:
+                raise RuntimeError("Could not retrieve child_state")
+            children_state = children_state_list[0]
+            assert children_state is not None
+            child_coin = children_state.coin
+            if parent_coin is not None:
+                parent_parent_coin = parent_coin
+            parent_coin = child_coin
+            parent_coin_id = child_coin.name()
+
+        if parent_parent_coin is None:
+            raise RuntimeError("could not get parent_parent_coin of %s", children)
+
+        # get lineage proof of parent spend, and also current innerpuz
+        assert children_state.created_height
+        parent_spend = await fetch_coin_spend(children_state.created_height, parent_parent_coin, peer)
+        assert parent_spend is not None
+        parent_inner_puz = chia.wallet.singleton.get_inner_puzzle_from_singleton(
+            parent_spend.puzzle_reveal.to_program()
+        )
+        if parent_inner_puz is None:
+            raise ValueError("get_innerpuzzle_from_puzzle failed")
+
+        if parent_spend.puzzle_reveal.get_tree_hash() == child_coin.puzzle_hash:
+            current_inner_puz = parent_inner_puz
+        else:
+            # extract the treasury solution from the full singleton solution
+            inner_solution = parent_spend.solution.to_program().rest().rest().first()
+            # reconstruct the treasury puzzle
+            current_inner_puz = get_new_puzzle_from_treasury_solution(parent_inner_puz, inner_solution)
+        # set the treasury rules
+        self.dao_rules = get_treasury_rules_from_puzzle(current_inner_puz)
+
+        current_lineage_proof = LineageProof(
+            parent_parent_coin.parent_coin_info, parent_inner_puz.get_tree_hash(), parent_parent_coin.amount
+        )
+        await self.add_parent(parent_parent_coin.name(), current_lineage_proof)
+
+        # Hack to find the cat tail hash from the memo of the genesis spend
+        launcher_state = await wallet_node.get_coin_state([self.dao_info.treasury_id], peer)
+        genesis_coin_id = launcher_state[0].coin.parent_coin_info
+        genesis_state = await wallet_node.get_coin_state([genesis_coin_id], peer)
+        genesis_spend = await fetch_coin_spend(genesis_state[0].spent_height, genesis_state[0].coin, peer)
+        cat_tail_hash = None
+        conds = genesis_spend.solution.to_program().at("rfr").as_iter()
+        for cond in conds:
+            if (cond.first().as_atom() == ConditionOpcode.CREATE_COIN) and (
+                int_from_bytes(cond.at("rrf").as_atom()) == 1
+            ):
+                cat_tail_hash = bytes32(cond.at("rrrff").as_atom())
+                break
+        assert cat_tail_hash
+
+        cat_wallet: Optional[CATWallet] = None
+
+        # Get or create a cat wallet
+        for wallet_id in self.wallet_state_manager.wallets:
+            wallet = self.wallet_state_manager.wallets[wallet_id]
+            if wallet.type() == WalletType.CAT:
+                assert isinstance(wallet, CATWallet)
+                if wallet.cat_info.limitations_program_hash == cat_tail_hash:
+                    cat_wallet = wallet
+                    break
+        else:
+            # Didn't find a cat wallet, so create one
+            cat_wallet = await CATWallet.get_or_create_wallet_for_cat(
+                self.wallet_state_manager, self.standard_wallet, cat_tail_hash.hex()
+            )
+
+        assert cat_wallet is not None
+        cat_wallet_id = cat_wallet.wallet_info.id
+
+        dao_info = DAOInfo(
+            self.dao_info.treasury_id,  # treasury_id: bytes32
+            uint32(cat_wallet_id),  # cat_wallet_id: int
+            uint32(0),  # dao_wallet_id: int
+            self.dao_info.proposals_list,  # proposals_list: List[ProposalInfo]
+            self.dao_info.parent_info,  # treasury_id: bytes32
+            child_coin,  # current_coin
+            current_inner_puz,  # current innerpuz
+            self.dao_info.singleton_block_height,
+            self.dao_info.filter_below_vote_amount,
+            self.dao_info.assets,
+            self.dao_info.current_height,
+        )
+
+        future_parent = LineageProof(
+            child_coin.parent_coin_info,
+            dao_info.current_treasury_innerpuz.get_tree_hash(),
+            uint64(child_coin.amount),
+        )
+        await self.add_parent(child_coin.name(), future_parent)
+
+        await self.save_info(dao_info)
+        assert self.dao_info.parent_info is not None
+
+        # get existing xch funds for treasury
+        await self.wallet_state_manager.add_interested_puzzle_hashes([self.dao_info.treasury_id], [self.id()])
+        await self.wallet_state_manager.add_interested_puzzle_hashes(
+            [self.dao_info.current_treasury_coin.puzzle_hash], [self.id()]
+        )
+
+        # Resync the wallet from when the treasury was created to get the existing funds
+        # TODO: Maybe split this out as an option for users since it may be slow?
+        if not wallet_node.is_trusted(peer):
+            request = RequestBlockHeader(children_state.created_height)
+            response: Optional[RespondBlockHeader] = await peer.call_api(FullNodeAPI.request_block_header, request)
+            await wallet_node.sync_from_untrusted_close_to_peak(response.header_block, peer)
+
+        return
+
+    async def create_tandem_xch_tx(
+        self,
+        fee: uint64,
+        announcement_to_assert: Optional[Announcement] = None,
+        reuse_puzhash: Optional[bool] = None,
+    ) -> TransactionRecord:
+        chia_coins = await self.standard_wallet.select_coins(fee)
+        if reuse_puzhash is None:
+            reuse_puzhash_config = self.wallet_state_manager.config.get("reuse_public_key_for_change", None)
+            if reuse_puzhash_config is None:
+                reuse_puzhash = False
+            else:
+                reuse_puzhash = reuse_puzhash_config.get(
+                    str(self.wallet_state_manager.wallet_node.logged_in_fingerprint), False
+                )
+        chia_tx = await self.standard_wallet.generate_signed_transaction(
+            uint64(0),
+            (await self.standard_wallet.get_puzzle_hash(not reuse_puzhash)),
+            fee=fee,
+            coins=chia_coins,
+            coin_announcements_to_consume={announcement_to_assert} if announcement_to_assert is not None else None,
+            reuse_puzhash=reuse_puzhash,
+        )
+        assert chia_tx.spend_bundle is not None
+        return chia_tx
+
+    def puzzle_for_pk(self, pubkey: G1Element) -> Program:
+        puz: Program = Program.to(0)
+        return puz
+
+    def puzzle_hash_for_pk(self, pubkey: G1Element) -> bytes32:
+        puz_hash: bytes32 = bytes32(Program.to(0).get_tree_hash())
+        return puz_hash
+
+    async def get_new_puzzle(self) -> Program:
+        puz: Program = Program.to(0)
+        return puz
+
+    async def set_name(self, new_name: str) -> None:
+        new_info = dataclasses.replace(self.wallet_info, name=new_name)
+        self.wallet_info = new_info
+        await self.wallet_state_manager.user_store.update_wallet(self.wallet_info)
+
+    def get_name(self) -> str:
+        return self.wallet_info.name
+
+    async def get_new_p2_inner_hash(self) -> bytes32:
+        puzzle = await self.get_new_p2_inner_puzzle()
+        return puzzle.get_tree_hash()
+
+    async def get_new_p2_inner_puzzle(self) -> Program:
+        return await self.standard_wallet.get_new_puzzle()
+
+    def get_parent_for_coin(self, coin: Coin) -> Optional[LineageProof]:
+        parent_info = None
+        for name, ccparent in self.dao_info.parent_info:
+            if name == coin.parent_coin_info:
+                parent_info = ccparent
+
+        return parent_info
+
+    @staticmethod
+    async def generate_new_dao_spend(
+        wallet_state_manager: Any,
+        standard_wallet: Wallet,
+        dao_rules: DAORules,
+        amount_of_cats_to_create: Optional[uint64],
+        cat_tail_hash: Optional[bytes32] = None,
+        fee: uint64 = uint64(0),
+    ) -> Optional[SpendBundle]:
+        """
+        Create a new DAO treasury using the dao_rules object. This does the first spend to create the launcher
+        and eve coins.
+        The eve spend has to be completed in a separate tx using 'submit_eve_spend' once the number of blocks required
+        by dao_rules.oracle_spend_delay has passed.
+        This must be called under the wallet state manager lock
+        """
+
+        if amount_of_cats_to_create is not None and amount_of_cats_to_create < 0:
+            raise ValueError("amount_of_cats must be >= 0, or None")
+        if (amount_of_cats_to_create is None or amount_of_cats_to_create == 0) and cat_tail_hash is None:
+            raise ValueError("amount_of_cats must be > 0 or cat_tail_hash must be specified")
+        if amount_of_cats_to_create is not None and amount_of_cats_to_create > 0 and cat_tail_hash is not None:
+            raise ValueError("cannot create voting cats and use existing cat_tail_hash")
+
+        if amount_of_cats_to_create is not None and amount_of_cats_to_create > 0:
+            coins = await standard_wallet.select_coins(uint64(amount_of_cats_to_create + fee + 1))
+        else:
+            coins = await standard_wallet.select_coins(uint64(fee + 1))
+
+        if coins is None:
+            return None
+        # origin is normal coin which creates launcher coin
+        origin = coins.copy().pop()
+
+        genesis_launcher_puz = SINGLETON_LAUNCHER
+        # launcher coin contains singleton launcher, launcher coin ID == singleton_id == treasury_id
+        launcher_coin = Coin(origin.name(), genesis_launcher_puz.get_tree_hash(), 1)
+
+        if cat_tail_hash is None:
+            assert amount_of_cats_to_create is not None
+            different_coins = await standard_wallet.select_coins(uint64(amount_of_cats_to_create), exclude=[origin])
+            cat_origin = different_coins.copy().pop()
+            assert origin.name() != cat_origin.name()
+            cat_tail_hash = generate_cat_tail(cat_origin.name(), launcher_coin.name()).get_tree_hash()
+
+        assert cat_tail_hash is not None
+
+        new_cat_wallet = None
+        # This will also mint the coins
+        if amount_of_cats_to_create is not None and different_coins is not None:
+            cat_tail_info = {
+                "identifier": "genesis_by_id_or_singleton",
+                "treasury_id": launcher_coin.name(),
+                "coins": different_coins,
+            }
+            new_cat_wallet = await CATWallet.create_new_cat_wallet(
+                wallet_state_manager,
+                standard_wallet,
+                cat_tail_info,
+                amount_of_cats_to_create,
+            )
+            assert new_cat_wallet is not None
+        else:
+            for wallet in wallet_state_manager.wallets:
+                if wallet_state_manager.wallets[wallet].type() == WalletType.CAT:
+                    if wallet_state_manager.wallets[wallet].cat_info.limitations_program_hash == cat_tail_hash:
+                        new_cat_wallet = wallet_state_manager.wallets[wallet]
+
+        assert new_cat_wallet is not None
+
+        assert cat_tail_hash == new_cat_wallet.cat_info.limitations_program_hash
+
+        dao_treasury_puzzle = get_treasury_puzzle(dao_rules, launcher_coin.name(), cat_tail_hash)
+        full_treasury_puzzle = curry_singleton(launcher_coin.name(), dao_treasury_puzzle)
+        full_treasury_puzzle_hash = full_treasury_puzzle.get_tree_hash()
+
+        announcement_set: Set[Announcement] = set()
+        announcement_message = Program.to([full_treasury_puzzle_hash, 1, bytes(0x80)]).get_tree_hash()
+        announcement_set.add(Announcement(launcher_coin.name(), announcement_message))
+
+        tx_record: Optional[TransactionRecord] = await standard_wallet.generate_signed_transaction(
+            uint64(1),
+            genesis_launcher_puz.get_tree_hash(),
+            fee,
+            origin_id=origin.name(),
+            coins=coins,
+            coin_announcements_to_consume=announcement_set,
+            memos=[new_cat_wallet.cat_info.limitations_program_hash],
+        )
+
+        genesis_launcher_solution = Program.to([full_treasury_puzzle_hash, 1, bytes(0x80)])
+
+        launcher_cs = CoinSpend(launcher_coin, genesis_launcher_puz, genesis_launcher_solution)
+        launcher_sb = SpendBundle([launcher_cs], AugSchemeMPL.aggregate([]))
+
+        launcher_proof = LineageProof(
+            bytes32(launcher_coin.parent_coin_info),
+            None,
+            uint64(launcher_coin.amount),
+        )
+        if tx_record is None or tx_record.spend_bundle is None:
+            return None
+        eve_coin = Coin(launcher_coin.name(), full_treasury_puzzle_hash, uint64(1))
+
+        inner_sol = Program.to([0, 0, 0, 0, 0, singleton_struct_for_id(launcher_coin.name())])
+        fullsol = Program.to(
+            [
+                launcher_proof.to_program(),
+                eve_coin.amount,
+                inner_sol,
+            ]
+        )
+        eve_coin_spend = CoinSpend(eve_coin, full_treasury_puzzle, fullsol)
+        eve_spend_bundle = SpendBundle([eve_coin_spend], G2Element())
+        full_spend = SpendBundle.aggregate([tx_record.spend_bundle, launcher_sb, eve_spend_bundle])
+
+        treasury_record = TransactionRecord(
+            confirmed_at_height=uint32(0),
+            created_at_time=uint64(int(time.time())),
+            to_puzzle_hash=dao_treasury_puzzle.get_tree_hash(),
+            amount=uint64(1),
+            fee_amount=fee,
+            confirmed=False,
+            sent=uint32(10),
+            spend_bundle=full_spend,
+            additions=full_spend.additions(),
+            removals=full_spend.removals(),
+            wallet_id=standard_wallet.id(),
+            sent_to=[],
+            trade_id=None,
+            type=uint32(TransactionType.INCOMING_TX.value),
+            name=bytes32(token_bytes()),
+            memos=[],
+        )
+        regular_record = dataclasses.replace(tx_record, spend_bundle=None)
+        await wallet_state_manager.add_pending_transaction(regular_record)
+        await wallet_state_manager.add_pending_transaction(treasury_record)
+
+        await wallet_state_manager.add_interested_coin_ids([eve_coin.name(), launcher_coin.name()])
+        return full_spend
+
+    async def generate_new_dao(
+        self,
+        amount_of_cats_to_create: Optional[uint64],
+        cat_tail_hash: Optional[bytes32] = None,
+        fee: uint64 = uint64(0),
+    ) -> Optional[SpendBundle]:
+        """
+        Create a new DAO treasury using the dao_rules object. This does the first spend to create the launcher
+        and eve coins.
+        The eve spend has to be completed in a separate tx using 'submit_eve_spend' once the number of blocks required
+        by dao_rules.oracle_spend_delay has passed.
+        This must be called under the wallet state manager lock
+        """
+
+        if amount_of_cats_to_create is not None and amount_of_cats_to_create < 0:
+            raise ValueError("amount_of_cats must be >= 0, or None")
+        if (amount_of_cats_to_create is None or amount_of_cats_to_create == 0) and cat_tail_hash is None:
+            raise ValueError("amount_of_cats must be > 0 or cat_tail_hash must be specified")
+        if amount_of_cats_to_create is not None and amount_of_cats_to_create > 0 and cat_tail_hash is not None:
+            raise ValueError("cannot create voting cats and use existing cat_tail_hash")
+        if self.dao_rules.pass_percentage > 10000 or self.dao_rules.pass_percentage < 0:
+            raise ValueError("proposal pass percentage must be between 0 and 10000")
+
+        if amount_of_cats_to_create is not None and amount_of_cats_to_create > 0:
+            coins = await self.standard_wallet.select_coins(uint64(amount_of_cats_to_create + fee + 1))
+        else:
+            coins = await self.standard_wallet.select_coins(uint64(fee + 1))
+
+        if coins is None:
+            return None
+        # origin is normal coin which creates launcher coin
+        origin = coins.copy().pop()
+
+        genesis_launcher_puz = SINGLETON_LAUNCHER
+        # launcher coin contains singleton launcher, launcher coin ID == singleton_id == treasury_id
+        launcher_coin = Coin(origin.name(), genesis_launcher_puz.get_tree_hash(), 1)
+
+        if cat_tail_hash is None:
+            assert amount_of_cats_to_create is not None
+            different_coins = await self.standard_wallet.select_coins(
+                uint64(amount_of_cats_to_create), exclude=[origin]
+            )
+            cat_origin = different_coins.copy().pop()
+            assert origin.name() != cat_origin.name()
+            cat_tail = generate_cat_tail(cat_origin.name(), launcher_coin.name())
+            cat_tail_hash = cat_tail.get_tree_hash()
+
+        assert cat_tail_hash is not None
+
+        dao_info: DAOInfo = DAOInfo(
+            launcher_coin.name(),
+            self.dao_info.cat_wallet_id,
+            self.dao_info.dao_cat_wallet_id,
+            self.dao_info.proposals_list,
+            self.dao_info.parent_info,
+            None,
+            None,
+            uint32(0),
+            self.dao_info.filter_below_vote_amount,
+            self.dao_info.assets,
+            self.dao_info.current_height,
+        )
+        await self.save_info(dao_info)
+        new_cat_wallet = None
+        # This will also mint the coins
+        if amount_of_cats_to_create is not None and different_coins is not None:
+            cat_tail_info = {
+                "identifier": "genesis_by_id_or_singleton",
+                "treasury_id": launcher_coin.name(),
+                "coins": different_coins,
+            }
+            new_cat_wallet = await CATWallet.create_new_cat_wallet(
+                self.wallet_state_manager,
+                self.standard_wallet,
+                cat_tail_info,
+                amount_of_cats_to_create,
+            )
+            assert new_cat_wallet is not None
+        else:
+            for wallet in self.wallet_state_manager.wallets:
+                if self.wallet_state_manager.wallets[wallet].type() == WalletType.CAT:
+                    if self.wallet_state_manager.wallets[wallet].cat_info.limitations_program_hash == cat_tail_hash:
+                        new_cat_wallet = self.wallet_state_manager.wallets[wallet]
+
+        assert new_cat_wallet is not None
+        cat_wallet_id = new_cat_wallet.wallet_info.id
+
+        assert cat_tail_hash == new_cat_wallet.cat_info.limitations_program_hash
+        await new_cat_wallet.set_tail_program(bytes(cat_tail).hex())
+        dao_info = DAOInfo(
+            self.dao_info.treasury_id,
+            cat_wallet_id,
+            self.dao_info.dao_cat_wallet_id,
+            self.dao_info.proposals_list,
+            self.dao_info.parent_info,
+            None,
+            None,
+            uint32(0),
+            self.dao_info.filter_below_vote_amount,
+            self.dao_info.assets,
+            self.dao_info.current_height,
+        )
+
+        await self.save_info(dao_info)
+
+        dao_treasury_puzzle = get_treasury_puzzle(self.dao_rules, launcher_coin.name(), cat_tail_hash)
+        full_treasury_puzzle = curry_singleton(launcher_coin.name(), dao_treasury_puzzle)
+        full_treasury_puzzle_hash = full_treasury_puzzle.get_tree_hash()
+
+        announcement_set: Set[Announcement] = set()
+        announcement_message = Program.to([full_treasury_puzzle_hash, 1, bytes(0x80)]).get_tree_hash()
+        announcement_set.add(Announcement(launcher_coin.name(), announcement_message))
+        tx_record: Optional[TransactionRecord] = await self.standard_wallet.generate_signed_transaction(
+            uint64(1),
+            genesis_launcher_puz.get_tree_hash(),
+            fee,
+            origin_id=origin.name(),
+            coins=set(coins),
+            coin_announcements_to_consume=announcement_set,
+            memos=[new_cat_wallet.cat_info.limitations_program_hash],
+        )
+
+        genesis_launcher_solution = Program.to([full_treasury_puzzle_hash, 1, bytes(0x80)])
+
+        launcher_cs = CoinSpend(launcher_coin, genesis_launcher_puz, genesis_launcher_solution)
+        launcher_sb = SpendBundle([launcher_cs], AugSchemeMPL.aggregate([]))
+
+        launcher_proof = LineageProof(
+            bytes32(launcher_coin.parent_coin_info),
+            None,
+            uint64(launcher_coin.amount),
+        )
+        await self.add_parent(launcher_coin.name(), launcher_proof)
+
+        if tx_record is None or tx_record.spend_bundle is None:
+            return None
+
+        eve_coin = Coin(launcher_coin.name(), full_treasury_puzzle_hash, uint64(1))
+        dao_info = DAOInfo(
+            launcher_coin.name(),
+            cat_wallet_id,
+            self.dao_info.dao_cat_wallet_id,
+            self.dao_info.proposals_list,
+            self.dao_info.parent_info,
+            eve_coin,
+            dao_treasury_puzzle,
+            self.dao_info.singleton_block_height,
+            self.dao_info.filter_below_vote_amount,
+            self.dao_info.assets,
+            self.dao_info.current_height,
+        )
+        await self.save_info(dao_info)
+        eve_spend = await self.generate_treasury_eve_spend(dao_treasury_puzzle, eve_coin)
+
+        full_spend = SpendBundle.aggregate([tx_record.spend_bundle, launcher_sb, eve_spend])
+
+        treasury_record = TransactionRecord(
+            confirmed_at_height=uint32(0),
+            created_at_time=uint64(int(time.time())),
+            to_puzzle_hash=dao_treasury_puzzle.get_tree_hash(),
+            amount=uint64(1),
+            fee_amount=fee,
+            confirmed=False,
+            sent=uint32(10),
+            spend_bundle=full_spend,
+            additions=full_spend.additions(),
+            removals=full_spend.removals(),
+            wallet_id=self.id(),
+            sent_to=[],
+            trade_id=None,
+            type=uint32(TransactionType.INCOMING_TX.value),
+            name=bytes32(token_bytes()),
+            memos=[],
+        )
+        # breakpoint()
+        regular_record = dataclasses.replace(tx_record, spend_bundle=None)
+        await self.wallet_state_manager.add_pending_transaction(regular_record)
+        await self.wallet_state_manager.add_pending_transaction(treasury_record)
+        await self.wallet_state_manager.add_interested_puzzle_hashes([launcher_coin.name()], [self.id()])
+        await self.wallet_state_manager.add_interested_coin_ids([launcher_coin.name()], [self.wallet_id])
+
+        await self.wallet_state_manager.add_interested_coin_ids([eve_coin.name()], [self.wallet_id])
+        return full_spend
+
+    async def generate_treasury_eve_spend(
+        self, inner_puz: Program, eve_coin: Coin, fee: uint64 = uint64(0)
+    ) -> SpendBundle:
+        """
+        Create the eve spend of the treasury
+        This can only be completed after a number of blocks > oracle_spend_delay have been farmed
+        """
+        if self.dao_info.current_treasury_innerpuz is None:
+            raise ValueError("generate_treasury_eve_spend called with nil self.dao_info.current_treasury_innerpuz")
+        full_treasury_puzzle = curry_singleton(self.dao_info.treasury_id, inner_puz)
+        # full_treasury_puzzle_hash = full_treasury_puzzle.get_tree_hash()
+        launcher_id, launcher_proof = self.dao_info.parent_info[0]
+        assert launcher_proof
+        # eve_coin = Coin(launcher_id, full_treasury_puzzle_hash, uint64(1))
+        # inner_puz = self.dao_info.current_treasury_innerpuz
+        assert inner_puz
+        # proposal_flag  ; if this is set then we are closing a proposal
+        # (@ proposal_announcement (announcement_source delegated_puzzle_hash announcement_args spend_or_update_flag))
+        # proposal_validator_solution
+        # delegated_puzzle_reveal  ; this is the reveal of the puzzle announced by the proposal
+        # delegated_solution  ; this is not secure unless the delegated puzzle secures it
+        # my_singleton_struct
+
+        inner_sol = Program.to([0, 0, 0, 0, 0, singleton_struct_for_id(launcher_id)])
+        fullsol = Program.to(
+            [
+                launcher_proof.to_program(),
+                eve_coin.amount,
+                inner_sol,
+            ]
+        )
+        eve_coin_spend = CoinSpend(eve_coin, full_treasury_puzzle, fullsol)
+        eve_spend_bundle = SpendBundle([eve_coin_spend], G2Element())
+
+        # assert self.dao_info.current_treasury_innerpuz
+        # eve_record = TransactionRecord(
+        #     confirmed_at_height=uint32(0),
+        #     created_at_time=uint64(int(time.time())),
+        #     to_puzzle_hash=self.dao_info.current_treasury_innerpuz.get_tree_hash(),
+        #     amount=uint64(1),
+        #     fee_amount=fee,
+        #     confirmed=False,
+        #     sent=uint32(10),
+        #     spend_bundle=eve_spend_bundle,
+        #     additions=eve_spend_bundle.additions(),
+        #     removals=eve_spend_bundle.removals(),
+        #     wallet_id=self.id(),
+        #     sent_to=[],
+        #     trade_id=None,
+        #     type=uint32(TransactionType.INCOMING_TX.value),
+        #     name=bytes32(token_bytes()),
+        #     memos=[],
+        # )
+        # regular_record = dataclasses.replace(eve_record, spend_bundle=None)
+        # await self.wallet_state_manager.add_pending_transaction(regular_record)
+        # await self.wallet_state_manager.add_pending_transaction(eve_record)
+
+        next_proof = LineageProof(
+            eve_coin.parent_coin_info,
+            inner_puz.get_tree_hash(),
+            uint64(eve_coin.amount),
+        )
+        next_coin = Coin(eve_coin.name(), eve_coin.puzzle_hash, eve_coin.amount)
+        await self.add_parent(eve_coin.name(), next_proof)
+        await self.wallet_state_manager.add_interested_coin_ids([next_coin.name()], [self.wallet_id])
+
+        dao_info = dataclasses.replace(self.dao_info, current_treasury_coin=next_coin)
+        await self.save_info(dao_info)
+        await self.wallet_state_manager.singleton_store.add_spend(self.id(), eve_coin_spend)
+        return eve_spend_bundle
+
+    # This has to be in the wallet because we are taking an ID and then searching our stored proposals for that ID
+    def get_proposal_curry_values(self, proposal_id: bytes32) -> Tuple[Program, Program, Program]:
+        for prop in self.dao_info.proposals_list:
+            if prop.proposal_id == proposal_id:
+                return get_curry_vals_from_proposal_puzzle(prop.inner_puzzle)
+        raise ValueError("proposal not found")
+
+    def generate_simple_proposal_innerpuz(
+        self,
+        recipient_puzhashes: List[bytes32],
+        amounts: List[uint64],
+        asset_types: List[Optional[bytes32]] = [None],
+    ) -> Program:
+        if len(recipient_puzhashes) != len(amounts):
+            raise ValueError("List of amounts and recipient puzzle hashes are not the same length")
+        xch_conditions = []
+        asset_conditions = []
+        for recipient_puzhash, amount, asset_type in zip(recipient_puzhashes, amounts, asset_types):
+            if asset_type is not None:
+                asset_conditions.append([asset_type, [[51, recipient_puzhash, amount]]])
+            else:
+                xch_conditions.append([51, recipient_puzhash, amount])
+        puzzle = get_spend_p2_singleton_puzzle(self.dao_info.treasury_id, Program.to(xch_conditions), asset_conditions)  # type: ignore[arg-type]
+        return puzzle
+
+    async def generate_update_proposal_innerpuz(
+        self,
+        new_dao_rules: DAORules,
+        new_proposal_validator: Optional[Program] = None,
+    ) -> Program:
+        if not new_proposal_validator:
+            assert isinstance(self.dao_info.current_treasury_innerpuz, Program)
+            new_proposal_validator = get_proposal_validator(self.dao_info.current_treasury_innerpuz)
+            # assert isinstance(new_proposal_validator, Program)
+        puzzle = get_update_proposal_puzzle(new_dao_rules, new_proposal_validator)
+        return puzzle
+
+    async def generate_mint_proposal_innerpuz(
+        self,
+        amount_of_cats_to_create: uint64,
+        cats_new_innerpuzhash: bytes32,
+    ) -> Program:
+        cat_launcher = create_cat_launcher_for_singleton_id(self.dao_info.treasury_id)
+
+        cat_wallet: CATWallet = self.wallet_state_manager.wallets[self.dao_info.cat_wallet_id]
+        cat_tail_hash = cat_wallet.cat_info.limitations_program_hash
+        eve_puz_hash = curry_cat_eve(cats_new_innerpuzhash)
+        full_puz = construct_cat_puzzle(CAT_MOD, cat_tail_hash, eve_puz_hash)
+        xch_conditions = [
+            [
+                51,
+                cat_launcher.get_tree_hash(),
+                uint64(amount_of_cats_to_create),
+                [cats_new_innerpuzhash],
+            ],  # create cat_launcher coin
+            [
+                60,
+                Program.to(["m", full_puz.get_tree_hash()]).get_tree_hash(),
+            ],  # make an announcement for the launcher to assert
+        ]
+        puzzle = get_spend_p2_singleton_puzzle(self.dao_info.treasury_id, Program.to(xch_conditions), [])
+        return puzzle
+
+    async def generate_new_proposal(
+        self,
+        proposed_puzzle: Program,
+        vote_amount: Optional[uint64] = None,
+        fee: uint64 = uint64(0),
+        reuse_puzhash: Optional[bool] = None,
+        push: bool = True,
+    ) -> SpendBundle:
+        dao_rules = get_treasury_rules_from_puzzle(self.dao_info.current_treasury_innerpuz)
+        coins = await self.standard_wallet.select_coins(uint64(fee + dao_rules.proposal_minimum_amount))
+        if coins is None:
+            return None
+        # origin is normal coin which creates launcher coin
+        origin = coins.copy().pop()
+        genesis_launcher_puz = SINGLETON_LAUNCHER
+        # launcher coin contains singleton launcher, launcher coin ID == singleton_id == treasury_id
+        launcher_coin = Coin(origin.name(), genesis_launcher_puz.get_tree_hash(), dao_rules.proposal_minimum_amount)
+
+        cat_wallet: CATWallet = self.wallet_state_manager.wallets[self.dao_info.cat_wallet_id]
+
+        if vote_amount is None:
+            dao_cat_wallet = self.wallet_state_manager.get_wallet(
+                id=self.dao_info.dao_cat_wallet_id, required_type=DAOCATWallet
+            )
+            vote_amount = await dao_cat_wallet.get_spendable_balance()
+        assert vote_amount is not None
+        cat_tail_hash = cat_wallet.cat_info.limitations_program_hash
+        assert cat_tail_hash
+        dao_proposal_puzzle = get_proposal_puzzle(
+            proposal_id=launcher_coin.name(),
+            cat_tail_hash=cat_tail_hash,
+            treasury_id=self.dao_info.treasury_id,
+            votes_sum=uint64(0),
+            total_votes=uint64(0),
+            proposed_puzzle_hash=proposed_puzzle.get_tree_hash(),
+        )
+
+        full_proposal_puzzle = curry_singleton(launcher_coin.name(), dao_proposal_puzzle)
+        full_proposal_puzzle_hash = full_proposal_puzzle.get_tree_hash()
+
+        announcement_set: Set[Announcement] = set()
+        announcement_message = Program.to(
+            [full_proposal_puzzle_hash, dao_rules.proposal_minimum_amount, bytes(0x80)]
+        ).get_tree_hash()
+        announcement_set.add(Announcement(launcher_coin.name(), announcement_message))
+
+        tx_record: Optional[TransactionRecord] = await self.standard_wallet.generate_signed_transaction(
+            uint64(dao_rules.proposal_minimum_amount),
+            genesis_launcher_puz.get_tree_hash(),
+            fee,
+            origin_id=origin.name(),
+            coins=coins,
+            coin_announcements_to_consume=announcement_set,
+            reuse_puzhash=reuse_puzhash,
+        )
+
+        genesis_launcher_solution = Program.to(
+            [full_proposal_puzzle_hash, dao_rules.proposal_minimum_amount, bytes(0x80)]
+        )
+
+        launcher_cs = CoinSpend(launcher_coin, genesis_launcher_puz, genesis_launcher_solution)
+        launcher_sb = SpendBundle([launcher_cs], AugSchemeMPL.aggregate([]))
+        eve_coin = Coin(launcher_coin.name(), full_proposal_puzzle_hash, dao_rules.proposal_minimum_amount)
+
+        future_parent = LineageProof(
+            eve_coin.parent_coin_info,
+            dao_proposal_puzzle.get_tree_hash(),
+            uint64(eve_coin.amount),
+        )
+        eve_parent = LineageProof(
+            bytes32(launcher_coin.parent_coin_info),
+            bytes32(launcher_coin.puzzle_hash),
+            uint64(launcher_coin.amount),
+        )
+
+        await self.add_parent(bytes32(eve_coin.parent_coin_info), eve_parent)
+        await self.add_parent(eve_coin.name(), future_parent)
+
+        eve_spend = await self.generate_proposal_eve_spend(
+            eve_coin=eve_coin,
+            full_proposal_puzzle=full_proposal_puzzle,
+            dao_proposal_puzzle=dao_proposal_puzzle,
+            proposed_puzzle_reveal=proposed_puzzle,
+            launcher_coin=launcher_coin,
+            vote_amount=vote_amount,
+        )
+        assert tx_record
+        assert tx_record.spend_bundle is not None
+
+        full_spend = SpendBundle.aggregate([tx_record.spend_bundle, eve_spend, launcher_sb])
+        # breakpoint()
+        if push:
+            record = TransactionRecord(
+                confirmed_at_height=uint32(0),
+                created_at_time=uint64(int(time.time())),
+                to_puzzle_hash=full_proposal_puzzle.get_tree_hash(),
+                amount=uint64(dao_rules.proposal_minimum_amount),
+                fee_amount=fee,
+                confirmed=False,
+                sent=uint32(10),
+                spend_bundle=full_spend,
+                additions=full_spend.additions(),
+                removals=full_spend.removals(),
+                wallet_id=self.id(),
+                sent_to=[],
+                trade_id=None,
+                type=uint32(TransactionType.INCOMING_TX.value),
+                name=bytes32(token_bytes()),
+                memos=[],
+            )
+            await self.wallet_state_manager.add_pending_transaction(record)
+        return full_spend
+
+    async def generate_proposal_eve_spend(
+        self,
+        *,
+        eve_coin: Coin,
+        full_proposal_puzzle: Program,
+        dao_proposal_puzzle: Program,
+        proposed_puzzle_reveal: Program,
+        launcher_coin: Coin,
+        vote_amount: uint64,
+    ) -> SpendBundle:
+        cat_wallet: CATWallet = self.wallet_state_manager.wallets[self.dao_info.cat_wallet_id]
+        cat_tail = cat_wallet.cat_info.limitations_program_hash
+        dao_cat_wallet = await DAOCATWallet.get_or_create_wallet_for_cat(
+            self.wallet_state_manager, self.standard_wallet, cat_tail.hex()
+        )
+        assert dao_cat_wallet is not None
+
+        curry_vals = get_curry_vals_from_proposal_puzzle(dao_proposal_puzzle)
+        dao_cat_spend = await dao_cat_wallet.create_vote_spend(
+            vote_amount, launcher_coin.name(), True, curry_vals=curry_vals
+        )
+        # vote_amounts_or_proposal_validator_hash  ; The qty of "votes" to add or subtract. ALWAYS POSITIVE.
+        # vote_info_or_money_receiver_hash ; vote_info is whether we are voting YES or NO. XXX rename vote_type?
+        # vote_coin_ids_or_proposal_timelock_length  ; this is either the coin ID we're taking a vote from
+        # previous_votes_or_pass_margin  ; this is the active votes of the lockup we're communicating with
+        #                              ; OR this is what percentage of the total votes must be YES - represented as an integer from 0 to 10,000 - typically this is set at 5100 (51%)
+        # lockup_innerpuzhashes_or_attendance_required  ; this is either the innerpuz of the locked up CAT we're taking a vote from OR
+        #                                           ; the attendance required - the percentage of the current issuance which must have voted represented as 0 to 10,000 - this is announced by the treasury
+        # innerpuz_reveal  ; this is only added during the first vote
+        # soft_close_length  ; revealed by the treasury
+        # self_destruct_time ; revealed by the treasury
+        # oracle_spend_delay  ; used to recreate the treasury
+        # self_destruct_flag ; if not 0, do the self-destruct spend
+        vote_amounts = []
+        vote_coins = []
+        previous_votes = []
+        lockup_inner_puzhashes = []
+        for spend in dao_cat_spend.coin_spends:
+            vote_amounts.append(spend.coin.amount)
+            vote_coins.append(spend.coin.name())
+            previous_votes.append(
+                get_active_votes_from_lockup_puzzle(
+                    get_innerpuzzle_from_cat_puzzle(Program.from_bytes(bytes(spend.puzzle_reveal)))
+                )
+            )
+            lockup_inner_puzhashes.append(
+                get_innerpuz_from_lockup_puzzle(
+                    get_innerpuzzle_from_cat_puzzle(Program.from_bytes(bytes(spend.puzzle_reveal)))
+                ).get_tree_hash()
+            )
+        inner_sol = Program.to(
+            [
+                vote_amounts,
+                1,
+                vote_coins,
+                previous_votes,
+                lockup_inner_puzhashes,
+                proposed_puzzle_reveal,
+                0,
+                0,
+                0,
+                0,
+                eve_coin.amount,
+            ]
+        )
+        # full solution is (lineage_proof my_amount inner_solution)
+        fullsol = Program.to(
+            [
+                [launcher_coin.parent_coin_info, launcher_coin.amount],
+                eve_coin.amount,
+                inner_sol,
+            ]
+        )
+        list_of_coinspends = [CoinSpend(eve_coin, full_proposal_puzzle, fullsol)]
+        unsigned_spend_bundle = SpendBundle(list_of_coinspends, G2Element())
+        return unsigned_spend_bundle.aggregate([unsigned_spend_bundle, dao_cat_spend])
+
+    async def generate_proposal_vote_spend(
+        self,
+        proposal_id: bytes32,
+        vote_amount: Optional[uint64],
+        is_yes_vote: bool,
+        fee: uint64 = uint64(0),
+        reuse_puzhash: Optional[bool] = None,
+        push: bool = True,
+    ) -> SpendBundle:
+        self.log.info(f"Trying to create a proposal close spend with ID: {proposal_id}")
+        proposal_info = None
+        for pi in self.dao_info.proposals_list:
+            if pi.proposal_id == proposal_id:
+                proposal_info = pi
+                break
+        if proposal_info is None:
+            raise ValueError("Unable to find a proposal with that ID.")
+        if (proposal_info.timer_coin is None) and (
+            proposal_info.current_innerpuz == get_finished_state_puzzle(proposal_info.proposal_id)
+        ):
+            raise ValueError("This proposal is already closed. Feel free to unlock your coins.")
+        # TODO: we may well want to add in options for more specificity later, but for now this will do
+        cat_wallet: CATWallet = self.wallet_state_manager.wallets[self.dao_info.cat_wallet_id]
+        cat_tail = cat_wallet.cat_info.limitations_program_hash
+        dao_cat_wallet = await DAOCATWallet.get_or_create_wallet_for_cat(
+            self.wallet_state_manager, self.standard_wallet, cat_tail.hex()
+        )
+        assert dao_cat_wallet is not None
+        assert proposal_info.current_innerpuz is not None
+        curry_vals = get_curry_vals_from_proposal_puzzle(proposal_info.current_innerpuz)
+        if vote_amount is None:
+            vote_amount = await dao_cat_wallet.get_votable_balance(proposal_id)
+        assert vote_amount is not None
+        dao_cat_spend = await dao_cat_wallet.create_vote_spend(
+            vote_amount, proposal_id, is_yes_vote, curry_vals=curry_vals
+        )
+        # vote_amounts_or_proposal_validator_hash  ; The qty of "votes" to add or subtract. ALWAYS POSITIVE.
+        # vote_info_or_money_receiver_hash ; vote_info is whether we are voting YES or NO. XXX rename vote_type?
+        # vote_coin_ids_or_proposal_timelock_length  ; this is either the coin ID we're taking a vote from
+        # previous_votes_or_pass_margin  ; this is the active votes of the lockup we're communicating with
+        #                              ; OR this is what percentage of the total votes must be YES - represented as an integer from 0 to 10,000 - typically this is set at 5100 (51%)
+        # lockup_innerpuzhashes_or_attendance_required  ; this is either the innerpuz of the locked up CAT we're taking a vote from OR
+        #                                           ; the attendance required - the percentage of the current issuance which must have voted represented as 0 to 10,000 - this is announced by the treasury
+        # innerpuz_reveal  ; this is only added during the first vote
+        # soft_close_length  ; revealed by the treasury
+        # self_destruct_time ; revealed by the treasury
+        # oracle_spend_delay  ; used to recreate the treasury
+        # self_destruct_flag ; if not 0, do the self-destruct spend
+        vote_amounts = []
+        vote_coins = []
+        previous_votes = []
+        lockup_inner_puzhashes = []
+        assert dao_cat_spend is not None
+        for spend in dao_cat_spend.coin_spends:
+            vote_amounts.append(
+                Program.from_bytes(bytes(spend.solution)).at("frrrrrrf")
+            )  # this is the vote_amount field of the solution
+            # breakpoint()
+            vote_coins.append(spend.coin.name())
+            previous_votes.append(
+                get_active_votes_from_lockup_puzzle(
+                    get_innerpuzzle_from_cat_puzzle(Program.from_bytes(bytes(spend.puzzle_reveal)))
+                )
+            )
+            lockup_inner_puzhashes.append(
+                get_innerpuz_from_lockup_puzzle(
+                    get_innerpuzzle_from_cat_puzzle(Program.from_bytes(bytes(spend.puzzle_reveal)))
+                ).get_tree_hash()
+            )
+        # vote_amounts_or_proposal_validator_hash  ; The qty of "votes" to add or subtract. ALWAYS POSITIVE.
+        # vote_info  ; vote_info is whether we are voting YES or NO. XXX rename vote_type?
+        # vote_coin_ids_or_proposal_timelock_length  ; this is either the coin ID we're taking a vote from
+        # previous_votes_or_pass_margin  ; this is the active votes of the lockup we're communicating with
+        # ; OR this is what percentage of the total votes must be YES - represented as an integer from 0 to 10,000 - typically this is set at 5100 (51%)
+        # lockup_innerpuzhashes_or_attendance_required  ; this is either the innerpuz of the locked up CAT we're taking a vote from OR
+        # ; the attendance required - the percentage of the current issuance which must have voted represented as 0 to 10,000 - this is announced by the treasury
+        # innerpuz_reveal  ; this is only added during the first vote
+        # soft_close_length  ; revealed by the treasury
+        # self_destruct_time  ; revealed by the treasury
+        # oracle_spend_delay  ; used to recreate the treasury
+        # self_destruct_flag  ; if not 0, do the self-destruct spend
+        # my_amount
+        inner_sol = Program.to(
+            [
+                vote_amounts,
+                1 if is_yes_vote else 0,
+                vote_coins,
+                previous_votes,
+                lockup_inner_puzhashes,
+                0,
+                0,
+                0,
+                0,
+                0,
+                proposal_info.current_coin.amount,
+            ]
+        )
+        parent_info = self.get_parent_for_coin(proposal_info.current_coin)
+        assert parent_info is not None
+        # full solution is (lineage_proof my_amount inner_solution)
+        fullsol = Program.to(
+            [
+                [
+                    parent_info.parent_name,
+                    parent_info.inner_puzzle_hash,
+                    parent_info.amount,
+                ],
+                proposal_info.current_coin.amount,
+                inner_sol,
+            ]
+        )
+        full_proposal_puzzle = curry_singleton(proposal_id, proposal_info.current_innerpuz)
+        list_of_coinspends = [CoinSpend(proposal_info.current_coin, full_proposal_puzzle, fullsol)]
+        unsigned_spend_bundle = SpendBundle(list_of_coinspends, G2Element())
+        if fee > 0:
+            chia_tx = await self.create_tandem_xch_tx(fee, reuse_puzhash=reuse_puzhash)
+            assert chia_tx.spend_bundle is not None
+            spend_bundle = unsigned_spend_bundle.aggregate([unsigned_spend_bundle, dao_cat_spend, chia_tx.spend_bundle])
+        spend_bundle = unsigned_spend_bundle.aggregate([unsigned_spend_bundle, dao_cat_spend])
+        if push:
+            record = TransactionRecord(
+                confirmed_at_height=uint32(0),
+                created_at_time=uint64(int(time.time())),
+                to_puzzle_hash=full_proposal_puzzle.get_tree_hash(),
+                amount=uint64(1),
+                fee_amount=fee,
+                confirmed=False,
+                sent=uint32(10),
+                spend_bundle=spend_bundle,
+                additions=spend_bundle.additions(),
+                removals=spend_bundle.removals(),
+                wallet_id=self.id(),
+                sent_to=[],
+                trade_id=None,
+                type=uint32(TransactionType.INCOMING_TX.value),
+                name=bytes32(token_bytes()),
+                memos=[],
+            )
+            await self.wallet_state_manager.add_pending_transaction(record)
+        return spend_bundle
+
+    async def create_proposal_close_spend(
+        self,
+        proposal_id: bytes32,
+        genesis_id: Optional[bytes32] = None,
+        fee: uint64 = uint64(0),
+        push: bool = True,
+        self_destruct: bool = False,
+        reuse_puzhash: Optional[bool] = None,
+    ) -> SpendBundle:
+        self.log.info(f"Trying to create a proposal close spend with ID: {proposal_id}")
+        proposal_info = None
+        for pi in self.dao_info.proposals_list:
+            if pi.proposal_id == proposal_id:
+                proposal_info = pi
+                break
+        if proposal_info is None:
+            raise ValueError("Unable to find a proposal with that ID.")
+        if proposal_info.timer_coin is None:
+            # TODO: we should also check the current_inner is finished puzzle
+            raise ValueError("This proposal is already closed. Feel free to unlock your coins.")
+        # TODO: do we need to re-sync proposal state here?
+        assert self.dao_info.current_treasury_innerpuz is not None
+        curried_args = uncurry_treasury(self.dao_info.current_treasury_innerpuz)
+        (
+            _DAO_TREASURY_MOD_HASH,
+            proposal_validator,
+            proposal_timelock,
+            soft_close_length,
+            attendance_required,
+            pass_percentage,
+            self_destruct_length,
+            oracle_spend_delay,
+        ) = curried_args
+        proposal_state = await self.get_proposal_state(proposal_id)
+        if not proposal_state["closable"]:
+            raise ValueError(f"This proposal is not ready to be closed. proposal_id: {proposal_id}")
+        if proposal_state["passed"]:
+            self.log.info(f"Closing passed proposal: {proposal_id}")
+        else:
+            self.log.info(f"Closing failed proposal: {proposal_id}")
+        assert proposal_info.current_innerpuz is not None
+        full_proposal_puzzle = curry_singleton(proposal_id, proposal_info.current_innerpuz)
+        assert proposal_info.current_coin.puzzle_hash == full_proposal_puzzle.get_tree_hash()
+
+        # vote_amounts_or_proposal_validator_hash  ; The qty of "votes" to add or subtract. ALWAYS POSITIVE.
+        # vote_info ; vote_info is whether we are voting YES or NO. XXX rename vote_type?
+        # vote_coin_ids_or_proposal_timelock_length  ; this is either the coin ID we're taking a vote from
+        # previous_votes_or_pass_margin  ; this is the active votes of the lockup we're communicating with
+        #                              ; OR this is what percentage of the total votes must be YES - represented as an integer from 0 to 10,000 - typically this is set at 5100 (51%)
+        # lockup_innerpuzhashes_or_attendance_required  ; this is either the innerpuz of the locked up CAT we're taking a vote from OR
+        #                                           ; the attendance required - the percentage of the current issuance which must have voted represented as 0 to 10,000 - this is announced by the treasury
+        # innerpuz_reveal  ; this is only added during the first vote
+        # soft_close_length  ; revealed by the treasury
+        # self_destruct_time ; revealed by the treasury
+        # oracle_spend_delay  ; used to recreate the treasury
+        # self_destruct_flag ; if not 0, do the self-destruct spend
+        solution = Program.to(
+            [
+                proposal_validator.get_tree_hash(),
+                0,
+                proposal_timelock,
+                pass_percentage,
+                attendance_required,
+                0,
+                soft_close_length,
+                self_destruct_length,
+                oracle_spend_delay,
+                1 if self_destruct else 0,
+            ]
+        )
+        parent_info = self.get_parent_for_coin(proposal_info.current_coin)
+        assert parent_info is not None
+        fullsol = Program.to(
+            [
+                [
+                    parent_info.parent_name,
+                    parent_info.inner_puzzle_hash,
+                    parent_info.amount,
+                ],
+                proposal_info.current_coin.amount,
+                solution,
+            ]
+        )
+        proposal_cs = CoinSpend(proposal_info.current_coin, full_proposal_puzzle, fullsol)
+        # PROPOSAL_MOD_HASH
+        # PROPOSAL_TIMER_MOD_HASH
+        # CAT_MOD_HASH
+        # CAT_TAIL_HASH
+        # (@ MY_PARENT_SINGLETON_STRUCT (SINGLETON_MOD_HASH SINGLETON_ID . LAUNCHER_PUZZLE_HASH))
+        # TREASURY_ID
+        # proposal_yes_votes
+        # proposal_total_votes
+        # proposal_innerpuzhash
+        # proposal_timelock
+        # parent_parent  this is the parent of the timer's parent
+        if not self_destruct:
+            timer_puzzle = get_proposal_timer_puzzle(
+                self.get_cat_tail_hash(),
+                proposal_info.proposal_id,
+                self.dao_info.treasury_id,
+            )
+            curried_args = uncurry_proposal(proposal_info.current_innerpuz)
+            (
+                SINGLETON_STRUCT,  # (SINGLETON_MOD_HASH (SINGLETON_ID . LAUNCHER_PUZZLE_HASH))
+                PROPOSAL_MOD_HASH,
+                PROPOSAL_TIMER_MOD_HASH,  # proposal timer needs to know which proposal created it, AND
+                CAT_MOD_HASH,
+                TREASURY_MOD_HASH,
+                LOCKUP_MOD_HASH,
+                CAT_TAIL_HASH,
+                TREASURY_ID,
+                YES_VOTES,  # yes votes are +1, no votes don't tally - we compare yes_votes/total_votes at the end
+                TOTAL_VOTES,  # how many people responded
+                PROPOSED_PUZ_HASH,  # this is what runs if this proposal is successful - the inner puzzle of this proposal
+            ) = curried_args.as_iter()
+
+            if TOTAL_VOTES.as_int() < attendance_required.as_int():
+                raise ValueError("Unable to pass this proposal as it has not met the minimum vote attendance.")
+
+            if (YES_VOTES.as_int() * 10000) // TOTAL_VOTES.as_int() < pass_percentage.as_int():
+                raise ValueError("Unable to pass this proposal as it has insufficient yes votes.")
+
+            # treasury_mod_hash
+            # proposal_yes_votes
+            # proposal_total_votes
+            # proposal_innerpuzhash
+            # proposal_timelock
+            # parent_parent
+            timer_solution = Program.to(
+                [
+                    DAO_TREASURY_MOD_HASH,
+                    YES_VOTES,
+                    TOTAL_VOTES,
+                    PROPOSED_PUZ_HASH,
+                    proposal_timelock,
+                    proposal_id,  # TODO: our parent is the eve so our parent's parent is always the launcher coin ID, right?
+                    proposal_info.current_coin.amount,  # amount should never change
+                ]
+            )
+            timer_cs = CoinSpend(proposal_info.timer_coin, timer_puzzle, timer_solution)
+
+        full_treasury_puz = curry_singleton(self.dao_info.treasury_id, self.dao_info.current_treasury_innerpuz)
+        # proposal_flag
+        # (@ proposal_announcement (announcement_source delegated_puzzle_hash announcement_args))
+        # proposal_validator_solution
+        # delegated_puzzle_reveal  ; this is the reveal of the puzzle announced by the proposal
+        # delegated_solution  ; this is not secure unless the delegated puzzle secures it
+
+        # (
+        #   proposal_id
+        #   total_votes
+        #   yes_votes
+        # )
+        cat_spend_bundle = None
+        delegated_puzzle_sb = None
+        puzzle_reveal = await self.fetch_proposed_puzzle_reveal(proposal_id)
+        if proposal_state["passed"] and not self_destruct:
+            validator_solution = Program.to(
+                [
+                    proposal_id,
+                    TOTAL_VOTES,
+                    YES_VOTES,
+                    proposal_info.current_coin.parent_coin_info,
+                    proposal_info.current_coin.amount,
+                ]
+            )
+            # p2_singleton_parent_amount_list  ; for xch this is just a list of (coin_parent coin_amount)
+            # p2_singleton_tailhash_parent_amount_list   ; list of ((asset (parent amount) (parent amount)... ) (asset (parent amount)... )... ),
+
+            proposal_type, curried_args = get_proposal_args(puzzle_reveal)
+            if proposal_type == "spend":
+                # (
+                #  treasury_solution,
+                #  cat_spend_bundle,
+                #  delegated_solution,
+                #  delegated_puzzle_sb
+                # ) = await self.get_delegated_solution_for_spend_proposal(
+                #     curried_args,
+                #     full_proposal_puzzle,
+                #     PROPOSED_PUZ_HASH,
+                #     validator_solution,
+                #     puzzle_reveal,
+                # )
+                (
+                    _,
+                    _,
+                    CONDITIONS,
+                    LIST_OF_TAILHASH_CONDITIONS,
+                    P2_SINGLETON_VIA_DELEGATED_PUZZLE_PUZHASH,
+                ) = curried_args.as_iter()
+
+                sum = 0
+
+                # p2_singleton solution is:
+                # singleton_inner_puzhash
+                # delegated_puzzle
+                # delegated_solution
+                # my_id
+                # my_puzhash
+                # list_of_parent_amounts
+                # my_amount
+                coin_spends = []
+                xch_parent_amount_list = []
+                tailhash_parent_amount_list = []
+                treasury_inner_puzhash = self.dao_info.current_treasury_innerpuz.get_tree_hash()
+                p2_singleton_puzzle = get_p2_singleton_puzzle(self.dao_info.treasury_id)
+                cat_launcher = create_cat_launcher_for_singleton_id(self.dao_info.treasury_id)
+
+                # handle CAT minting
+                for cond in CONDITIONS.as_iter():
+                    if cond.first().as_int() == 51:
+                        if cond.rest().first().as_atom() == cat_launcher.get_tree_hash():
+                            cat_wallet: CATWallet = self.wallet_state_manager.wallets[self.dao_info.cat_wallet_id]
+                            cat_tail_hash = cat_wallet.cat_info.limitations_program_hash
+                            mint_amount = cond.rest().rest().first().as_int()
+                            new_cat_puzhash = cond.rest().rest().rest().first().first().as_atom()
+                            eve_puzzle = curry_cat_eve(new_cat_puzhash)
+                            if genesis_id is None:
+                                tail_reconstruction = cat_wallet.cat_info.my_tail
+                            else:
+                                tail_reconstruction = generate_cat_tail(genesis_id, self.dao_info.treasury_id)
+                            assert tail_reconstruction is not None
+                            assert tail_reconstruction.get_tree_hash() == cat_tail_hash
+                            assert isinstance(self.dao_info.current_treasury_coin, Coin)
+                            cat_launcher_coin = Coin(
+                                self.dao_info.current_treasury_coin.name(), cat_launcher.get_tree_hash(), mint_amount
+                            )
+                            # treasury_inner_puz_hash
+                            # parent_parent
+                            # new_puzzle_hash  ; the full CAT puzzle
+                            # amount
+                            full_puz = construct_cat_puzzle(CAT_MOD, cat_tail_hash, eve_puzzle)
+
+                            solution = Program.to(
+                                [
+                                    treasury_inner_puzhash,
+                                    self.dao_info.current_treasury_coin.parent_coin_info,
+                                    full_puz.get_tree_hash(),
+                                    mint_amount,
+                                ]
+                            )
+                            coin_spends.append(CoinSpend(cat_launcher_coin, cat_launcher, solution))
+                            eve_coin = Coin(cat_launcher_coin.name(), full_puz.get_tree_hash(), mint_amount)
+                            # my_amount
+                            # tail_reveal
+                            # tail_solution
+
+                            # tail_solution is (singleton_inner_puzhash parent_parent_id parent_amount)
+                            tail_solution = Program.to(
+                                [treasury_inner_puzhash, cat_launcher_coin.parent_coin_info, cat_launcher_coin.amount]
+                            )
+                            solution = Program.to([mint_amount, tail_reconstruction, tail_solution])
+                            new_spendable_cat = SpendableCAT(
+                                eve_coin,
+                                cat_tail_hash,
+                                eve_puzzle,
+                                solution,
+                            )
+                            if cat_spend_bundle is None:
+                                cat_spend_bundle = unsigned_spend_bundle_for_spendable_cats(
+                                    CAT_MOD, [new_spendable_cat]
+                                )
+                            else:
+                                cat_spend_bundle = cat_spend_bundle.aggregate(
+                                    [cat_spend_bundle, unsigned_spend_bundle_for_spendable_cats([new_spendable_cat])]
+                                )
+
+                for condition_statement in CONDITIONS.as_iter():
+                    if condition_statement.first().as_int() == 51:
+                        sum += condition_statement.rest().rest().first().as_int()
+                if sum > 0:
+                    xch_coins = await self.select_coins_for_asset_type(uint64(sum))
+                    for xch_coin in xch_coins:
+                        xch_parent_amount_list.append([xch_coin.parent_coin_info, xch_coin.amount])
+                        solution = Program.to(
+                            [
+                                treasury_inner_puzhash,
+                                0,
+                                0,
+                                xch_coin.name(),
+                                0,
+                                0,
+                                xch_coin.amount,
+                            ]
+                        )
+                        coin_spends.append(CoinSpend(xch_coin, p2_singleton_puzzle, solution))
+                    delegated_puzzle_sb = SpendBundle(coin_spends, AugSchemeMPL.aggregate([]))
+                for tail_hash_conditions_pair in LIST_OF_TAILHASH_CONDITIONS.as_iter():
+                    tail_hash: bytes32 = tail_hash_conditions_pair.first().as_atom()
+                    conditions: Program = tail_hash_conditions_pair.rest().first()
+                    sum_of_conditions = 0
+                    sum_of_coins = 0
+                    spendable_cat_list = []
+                    for condition in conditions.as_iter():
+                        if condition.first().as_int() == 51:
+                            sum_of_conditions += condition.rest().rest().first().as_int()
+                    cat_coins = await self.select_coins_for_asset_type(uint64(sum), tail_hash)
+                    parent_amount_list = []
+                    for cat_coin in cat_coins:
+                        sum_of_coins += cat_coin.amount
+                        parent_amount_list.append([cat_coin.parent_coin_info, cat_coin.amount])
+                        lineage_proof = await self.fetch_cat_lineage_proof(cat_coin)
+                        # singleton_inner_puzhash
+                        # delegated_puzzle
+                        # delegated_solution
+                        # my_id
+                        # my_puzhash  ; only needed for merging, set to 0 otherwise
+                        if cat_coin == cat_coins[-1]:  # the last coin is the one that makes the conditions
+                            change_condition = Program.to(
+                                [51, p2_singleton_puzzle.get_tree_hash(), sum_of_coins - sum_of_conditions]
+                            )
+                            delegated_puzzle = Program.to((1, change_condition.cons(conditions)))
+                            solution = Program.to(
+                                [
+                                    treasury_inner_puzhash,
+                                    delegated_puzzle,
+                                    0,
+                                    cat_coin.name(),
+                                    0,
+                                ]
+                            )
+                        else:
+                            solution = Program.to(
+                                [
+                                    treasury_inner_puzhash,
+                                    0,
+                                    0,
+                                    cat_coin.name(),
+                                    0,
+                                ]
+                            )
+                        new_spendable_cat = SpendableCAT(
+                            cat_coin,
+                            tail_hash,
+                            p2_singleton_puzzle,
+                            solution,
+                            lineage_proof=lineage_proof,
+                        )
+                        spendable_cat_list.append(new_spendable_cat)
+                    # create or merge with other CAT spends
+                    if cat_spend_bundle is None:
+                        cat_spend_bundle = unsigned_spend_bundle_for_spendable_cats(CAT_MOD, spendable_cat_list)
+                    else:
+                        cat_spend_bundle = cat_spend_bundle.aggregate(
+                            [cat_spend_bundle, unsigned_spend_bundle_for_spendable_cats(CAT_MOD, spendable_cat_list)]
+                        )
+                    tailhash_parent_amount_list.append([tail_hash, parent_amount_list])
+
+                delegated_solution = Program.to(
+                    [
+                        xch_parent_amount_list,
+                        tailhash_parent_amount_list,
+                        treasury_inner_puzhash,
+                    ]
+                )
+                # proposal_flag  ; if this is set then we are closing a proposal
+                # (announcement_source delegated_puzzle_hash announcement_args)
+                # proposal_validator_solution
+                # delegated_puzzle_reveal  ; this is the reveal of the puzzle announced by the proposal
+                # delegated_solution  ; this is not secure unless the delegated puzzle secures it
+                # treasury_solution = Program.to(
+                #     [
+                #         1,
+                #         [full_proposal_puzzle.get_tree_hash(), PROPOSED_PUZ_HASH.as_atom(), 0],
+                #         validator_solution,
+                #         puzzle_reveal,
+                #         delegated_solution,
+                #     ]
+                # )
+            elif proposal_type == "update":
+                (
+                    _,
+                    PROPOSAL_VALIDATOR,
+                    PROPOSAL_LENGTH,
+                    PROPOSAL_SOFTCLOSE_LENGTH,
+                    ATTENDANCE_REQUIRED,
+                    PASS_MARGIN,
+                    PROPOSAL_SELF_DESTRUCT_TIME,
+                    ORACLE_SPEND_DELAY,
+                ) = curried_args.as_iter()
+                coin_spends = []
+                treasury_inner_puzhash = self.dao_info.current_treasury_innerpuz.get_tree_hash()
+                delegated_solution = Program.to([])
+
+            treasury_solution = Program.to(
+                [
+                    1,
+                    [proposal_info.current_coin.name(), PROPOSED_PUZ_HASH.as_atom(), 0],
+                    validator_solution,
+                    puzzle_reveal,
+                    delegated_solution,
+                ]
+            )
+        else:
+            treasury_solution = Program.to([0, 0, 0, 0, 0, 0, 0])
+
+        assert self.dao_info.current_treasury_coin is not None
+        parent_info = self.get_parent_for_coin(self.dao_info.current_treasury_coin)
+        assert parent_info is not None
+        full_treasury_solution = Program.to(
+            [
+                [
+                    parent_info.parent_name,
+                    parent_info.inner_puzzle_hash,
+                    parent_info.amount,
+                ],
+                1,
+                treasury_solution,
+            ]
+        )
+
+        treasury_cs = CoinSpend(self.dao_info.current_treasury_coin, full_treasury_puz, full_treasury_solution)
+
+        if self_destruct:
+            spend_bundle = SpendBundle([proposal_cs, treasury_cs], AugSchemeMPL.aggregate([]))
+        else:
+            spend_bundle = SpendBundle([proposal_cs, timer_cs, treasury_cs], AugSchemeMPL.aggregate([]))
+        if fee > 0:
+            chia_tx = await self.create_tandem_xch_tx(fee, reuse_puzhash=reuse_puzhash)
+            assert chia_tx.spend_bundle is not None
+            full_spend = SpendBundle.aggregate([spend_bundle, chia_tx.spend_bundle])
+        else:
+            full_spend = SpendBundle.aggregate([spend_bundle])
+        if cat_spend_bundle is not None:
+            full_spend = full_spend.aggregate([full_spend, cat_spend_bundle])
+        if delegated_puzzle_sb is not None:
+            full_spend = full_spend.aggregate([full_spend, delegated_puzzle_sb])
+        # breakpoint()
+        if push:
+            record = TransactionRecord(
+                confirmed_at_height=uint32(0),
+                created_at_time=uint64(int(time.time())),
+                to_puzzle_hash=DAO_FINISHED_STATE.get_tree_hash(),
+                amount=uint64(1),
+                fee_amount=fee,
+                confirmed=False,
+                sent=uint32(10),
+                spend_bundle=full_spend,
+                additions=full_spend.additions(),
+                removals=full_spend.removals(),
+                wallet_id=self.id(),
+                sent_to=[],
+                trade_id=None,
+                type=uint32(TransactionType.INCOMING_TX.value),
+                name=bytes32(token_bytes()),
+                memos=[],
+            )
+            await self.wallet_state_manager.add_pending_transaction(record)
+        return full_spend
+
+    async def fetch_proposed_puzzle_reveal(self, proposal_id: bytes32) -> Program:
+        wallet_node: Any = self.wallet_state_manager.wallet_node
+        peer: WSChiaConnection = wallet_node.get_full_node_peer()
+        if peer is None:
+            raise ValueError("Could not find any peers to request puzzle and solution from")
+        # The proposal_id is launcher coin, so proposal_id's child is eve and the eve spend contains the reveal
+        children = await wallet_node.fetch_children(proposal_id, peer)
+        eve_state = children[0]
+
+        eve_spend = await fetch_coin_spend(eve_state.created_height, eve_state.coin, peer)
+        puzzle_reveal = get_proposed_puzzle_reveal_from_solution(eve_spend.solution.to_program())
+        # breakpoint()
+        return puzzle_reveal
+
+    async def fetch_cat_lineage_proof(self, cat_coin: Coin) -> LineageProof:
+        wallet_node: Any = self.wallet_state_manager.wallet_node
+        peer: WSChiaConnection = wallet_node.get_full_node_peer()
+        if peer is None:
+            raise ValueError("Could not find any peers to request puzzle and solution from")
+        state = await wallet_node.get_coin_state([cat_coin.parent_coin_info], peer)
+        assert state is not None
+        # CoinState contains Coin, spent_height, and created_height,
+        parent_spend = await fetch_coin_spend(state[0].spent_height, state[0].coin, peer)
+        parent_inner_puz = get_innerpuzzle_from_cat_puzzle(parent_spend.puzzle_reveal.to_program())
+        return LineageProof(state[0].coin.parent_coin_info, parent_inner_puz.get_tree_hash(), state[0].coin.amount)
+
+    async def _create_treasury_fund_transaction(
+        self,
+        funding_wallet: WalletProtocol,
+        amount: uint64,
+        fee: uint64 = uint64(0),
+        reuse_puzhash: Optional[bool] = None,
+    ) -> TransactionRecord:
+        if funding_wallet.type() == WalletType.STANDARD_WALLET.value:
+            p2_singleton_puzhash = get_p2_singleton_puzhash(self.dao_info.treasury_id, asset_id=None)
+            wallet: Wallet = funding_wallet  # type: ignore[assignment]
+            return await wallet.generate_signed_transaction(
+                amount,
+                p2_singleton_puzhash,
+                fee=fee,
+                memos=[self.dao_info.treasury_id],
+                reuse_puzhash=reuse_puzhash,
+            )
+        elif funding_wallet.type() == WalletType.CAT.value:
+            cat_wallet: CATWallet = funding_wallet  # type: ignore[assignment]
+            # generate_signed_transaction has a different type signature in Wallet and CATWallet
+            # CATWallet uses a List of amounts and a List of puzhashes as the first two arguments
+            p2_singleton_puzhash = get_p2_singleton_puzhash(self.dao_info.treasury_id)
+            tx_records: List[TransactionRecord] = await cat_wallet.generate_signed_transactions(
+                [amount],
+                [p2_singleton_puzhash],
+                fee=fee,
+                memos=[[self.dao_info.treasury_id]],
+                reuse_puzhash=reuse_puzhash,
+                override_memos=True,
+            )
+            return tx_records[0]
+        else:
+            raise ValueError(f"Assets of type {funding_wallet.type()} are not currently supported.")
+
+    async def create_add_money_to_treasury_spend(
+        self,
+        amount: uint64,
+        fee: uint64 = uint64(0),
+        funding_wallet_id: uint32 = uint32(1),
+        reuse_puzhash: Optional[bool] = None,
+    ) -> TransactionRecord:
+        # TODO: add tests for create_add_money_to_treasury_spend
+        # set up the p2_singleton
+        funding_wallet = self.wallet_state_manager.wallets[funding_wallet_id]
+        tx_record = await self._create_treasury_fund_transaction(funding_wallet, amount, fee, reuse_puzhash)
+        await self.wallet_state_manager.add_pending_transaction(tx_record)
+        return tx_record
+
+    async def fetch_singleton_lineage_proof(self, coin: Coin) -> LineageProof:
+        wallet_node: Any = self.wallet_state_manager.wallet_node
+        peer: WSChiaConnection = wallet_node.get_full_node_peer()
+        if peer is None:
+            raise ValueError("Could not find any peers to request puzzle and solution from")
+        state = await wallet_node.get_coin_state([coin.parent_coin_info], peer)
+        assert state is not None
+        # CoinState contains Coin, spent_height, and created_height,
+        parent_spend = await fetch_coin_spend(state[0].spent_height, state[0].coin, peer)
+        parent_inner_puz = get_inner_puzzle_from_singleton(parent_spend.puzzle_reveal.to_program())
+        assert isinstance(parent_inner_puz, Program)
+        return LineageProof(state[0].coin.parent_coin_info, parent_inner_puz.get_tree_hash(), state[0].coin.amount)
+
+    async def free_coins_from_finished_proposals(
+        self, fee: uint64 = uint64(0), push: bool = True, reuse_puzhash: Optional[bool] = None
+    ) -> SpendBundle:
+        dao_cat_wallet: DAOCATWallet = self.wallet_state_manager.wallets[self.dao_info.dao_cat_wallet_id]
+        full_spend = None
+        spends = []
+        for proposal_info in self.dao_info.proposals_list:
+            if proposal_info.closed:
+                inner_solution = Program.to(
+                    [
+                        proposal_info.current_coin.amount,
+                    ]
+                )
+                lineage_proof: LineageProof = await self.fetch_singleton_lineage_proof(proposal_info.current_coin)
+                solution = Program.to([lineage_proof.to_program(), proposal_info.current_coin.amount, inner_solution])
+                finished_puz = get_finished_state_puzzle(proposal_info.proposal_id)
+                cs = CoinSpend(proposal_info.current_coin, finished_puz, solution)
+                prop_sb = SpendBundle([cs], AugSchemeMPL.aggregate([]))
+                sb = await dao_cat_wallet.remove_active_proposal(proposal_info.proposal_id, push=False)
+                spends.append(prop_sb)
+                spends.append(sb)
+
+        if not spends:
+            raise ValueError("No proposals are available for release")
+
+        full_spend = SpendBundle.aggregate(spends)
+        if fee > 0:
+            chia_tx = await self.create_tandem_xch_tx(fee, reuse_puzhash=reuse_puzhash)
+            assert chia_tx.spend_bundle is not None
+            full_spend = full_spend.aggregate([full_spend, chia_tx.spend_bundle])
+        if push:
+            record = TransactionRecord(
+                confirmed_at_height=uint32(0),
+                created_at_time=uint64(int(time.time())),
+                to_puzzle_hash=finished_puz.get_tree_hash(),
+                amount=uint64(1),
+                fee_amount=fee,
+                confirmed=False,
+                sent=uint32(10),
+                spend_bundle=full_spend,
+                additions=full_spend.additions(),
+                removals=full_spend.removals(),
+                wallet_id=self.id(),
+                sent_to=[],
+                trade_id=None,
+                type=uint32(TransactionType.INCOMING_TX.value),
+                name=bytes32(token_bytes()),
+                memos=[],
+            )
+            await self.wallet_state_manager.add_pending_transaction(record)
+        return full_spend
+
+    async def parse_proposal(self, proposal_id: bytes32) -> Dict[str, Any]:
+        for prop_info in self.dao_info.proposals_list:
+            if prop_info.proposal_id == proposal_id:
+                state = await self.get_proposal_state(proposal_id)
+                proposed_puzzle_reveal = await self.fetch_proposed_puzzle_reveal(proposal_id)
+                proposal_type, curried_args = get_proposal_args(proposed_puzzle_reveal)
+                if proposal_type == "spend":
+                    cat_launcher = create_cat_launcher_for_singleton_id(self.dao_info.treasury_id)
+                    (
+                        _,
+                        _,
+                        CONDITIONS,
+                        LIST_OF_TAILHASH_CONDITIONS,
+                        P2_SINGLETON_VIA_DELEGATED_PUZZLE_PUZHASH,
+                    ) = curried_args.as_iter()
+                    mint_amount = None
+                    new_cat_puzhash = None
+                    xch_created_coins = []
+                    for cond in CONDITIONS.as_iter():
+                        if cond.first().as_int() == 51:
+                            if cond.rest().first().as_atom() == cat_launcher.get_tree_hash():
+                                mint_amount = cond.rest().rest().first().as_int()
+                                new_cat_puzhash = cond.rest().rest().rest().first().first().as_atom()
+                            else:
+                                cc = {"puzzle_hash": cond.at("rf").as_atom(), "amount": cond.at("rrf").as_int()}
+                                xch_created_coins.append(cc)
+
+                    asset_create_coins: List[Dict[Any, Any]] = []
+                    for asset in LIST_OF_TAILHASH_CONDITIONS.as_iter():
+                        if asset == Program.to(0):
+                            asset_dict: Optional[Dict[str, Any]] = None
+                        else:
+                            asset_id = asset.first().as_atom()
+                            cc_list = []
+                            for cond in asset.rest().first():
+                                if cond.first().as_int() == 51:
+                                    asset_dict = {
+                                        "puzzle_hash": cond.at("rf").as_atom(),
+                                        "amount": cond.at("rrf").as_int(),
+                                    }
+                                    cc_list.append(asset_dict)
+                            asset_create_coins.append({asset_id: cc_list})
+                    dictionary: Dict[str, Any] = {
+                        "state": state,
+                        "proposal_type": proposal_type,
+                        "proposed_puzzle_reveal": proposed_puzzle_reveal,
+                        "xch_conditions": xch_created_coins,
+                        "asset_conditions": asset_create_coins,
+                    }
+                    if mint_amount is not None and new_cat_puzhash is not None:
+                        dictionary["mint_amount"] = mint_amount
+                        dictionary["new_cat_puzhash"] = new_cat_puzhash
+                elif proposal_type == "update":
+                    dao_rules = get_dao_rules_from_update_proposal(proposed_puzzle_reveal)
+                    dictionary = {
+                        "state": state,
+                        "proposal_type": proposal_type,
+                        "dao_rules": dao_rules,
+                    }
+                return dictionary
+        raise ValueError(f"Unable to find proposal with id: {proposal_id.hex()}")
+
+    async def is_proposal_closeable(self, proposal_info: ProposalInfo) -> bool:
+        dao_rules = get_treasury_rules_from_puzzle(self.dao_info.current_treasury_innerpuz)
+        if proposal_info.singleton_block_height + dao_rules.proposal_timelock < self.dao_info.current_height:
+            return False
+        tip_height = await self.get_tip_created_height(proposal_info.proposal_id)
+        assert isinstance(tip_height, int)
+        if tip_height + dao_rules.soft_close_length < self.dao_info.current_height:
+            return False
+        return True
+
+    async def get_frozen_amount(self) -> uint64:
+        return uint64(0)
+
+    async def get_spendable_balance(self, unspent_records: Optional[Set[WalletCoinRecord]] = None) -> uint128:
+        spendable_am = await self.wallet_state_manager.get_confirmed_spendable_balance_for_wallet(
+            self.wallet_info.id, unspent_records
+        )
+        return uint128(spendable_am)
+
+    async def get_max_send_amount(self, records: Optional[Set[WalletCoinRecord]] = None) -> uint128:
+        return uint128(0)
+
+    # if asset_id == None: then we get normal XCH
+    async def get_balance_by_asset_type(self, asset_id: Optional[bytes32] = None) -> uint128:
+        # TODO: Pull coins from DB once they're being stored
+        puzhash = get_p2_singleton_puzhash(self.dao_info.treasury_id, asset_id=asset_id)
+        records = await self.wallet_state_manager.coin_store.get_coin_records_by_puzzle_hash(puzhash)
+        return uint128(sum([record.coin.amount for record in records if not record.spent]))
+
+    # if asset_id == None: then we get normal XCH
+    async def select_coins_for_asset_type(self, amount: uint64, asset_id: Optional[bytes32] = None) -> List[Coin]:
+        # TODO: Pull coins from DB once they're being stored
+        puzhash = get_p2_singleton_puzhash(self.dao_info.treasury_id, asset_id=asset_id)
+        records = await self.wallet_state_manager.coin_store.get_coin_records_by_puzzle_hash(puzhash)
+        # TODO: smarter coin selection algorithm
+        total = 0
+        coins = []
+        for record in records:
+            total += record.coin.amount
+            coins.append(record.coin)
+            if total >= amount:
+                break
+        if total < amount:
+            raise ValueError(f"Not enough of that asset_id: {asset_id}")
+        return coins
+
+    async def add_parent(self, name: bytes32, parent: Optional[LineageProof]) -> None:
+        self.log.info(f"Adding parent {name}: {parent}")
+        current_list = self.dao_info.parent_info.copy()
+        current_list.append((name, parent))
+        dao_info: DAOInfo = DAOInfo(
+            self.dao_info.treasury_id,
+            self.dao_info.cat_wallet_id,
+            self.dao_info.dao_cat_wallet_id,
+            self.dao_info.proposals_list,
+            current_list,
+            self.dao_info.current_treasury_coin,
+            self.dao_info.current_treasury_innerpuz,
+            self.dao_info.singleton_block_height,
+            self.dao_info.filter_below_vote_amount,
+            self.dao_info.assets,
+            self.dao_info.current_height,
+        )
+        await self.save_info(dao_info)
+
+    async def save_info(self, dao_info: DAOInfo) -> None:
+        self.dao_info = dao_info
+        current_info = self.wallet_info
+        data_str = json.dumps(dao_info.to_json_dict())
+        wallet_info = WalletInfo(current_info.id, current_info.name, current_info.type, data_str)
+        self.wallet_info = wallet_info
+        await self.wallet_state_manager.user_store.update_wallet(wallet_info)
+
+    def generate_wallet_name(self) -> str:
+        """
+        Generate a new DAO wallet name
+        :return: wallet name
+        """
+        max_num = 0
+        for wallet in self.wallet_state_manager.wallets.values():
+            if wallet.type() == WalletType.DAO:
+                matched = re.search(r"^Profile (\d+)$", wallet.wallet_info.name)  # TODO: bug: wallet.wallet_info
+                if matched and int(matched.group(1)) > max_num:
+                    max_num = int(matched.group(1))
+        return f"Profile {max_num + 1}"
+
+    def require_derivation_paths(self) -> bool:
+        return True
+
+    def get_cat_wallet_id(self) -> uint32:
+        return self.dao_info.cat_wallet_id
+
+    async def create_new_dao_cats(
+        self,
+        amount: uint64,
+        push: bool = False,
+        reuse_puzhash: Optional[bool] = None,
+    ) -> Tuple[List[TransactionRecord], Optional[List[Coin]]]:
+        # get the lockup puzzle hash
+        dao_cat_wallet: DAOCATWallet = self.wallet_state_manager.wallets[self.dao_info.dao_cat_wallet_id]
+        return await dao_cat_wallet.create_new_dao_cats(amount, push, reuse_puzhash=reuse_puzhash)
+
+    @staticmethod
+    def get_next_interesting_coin(spend: CoinSpend) -> Optional[Coin]:
+        # CoinSpend of one of the coins that we cared about. This coin was spent in a block, but might be in a reorg
+        # If we return a value, it is a coin that we are also interested in (to support two transitions per block)
+        return get_most_recent_singleton_coin_from_coin_spend(spend)
+
+    async def get_tip(self, singleton_id: bytes32) -> Optional[Tuple[uint32, SingletonRecord]]:
+        ret: List[
+            Tuple[uint32, SingletonRecord]
+        ] = await self.wallet_state_manager.singleton_store.get_records_by_singleton_id(singleton_id)
+        if len(ret) == 0:
+            return None
+        return ret[-1]
+
+    async def get_tip_created_height(self, singleton_id: bytes32) -> Optional[int]:
+        ret: List[
+            Tuple[uint32, SingletonRecord]
+        ] = await self.wallet_state_manager.singleton_store.get_records_by_singleton_id(singleton_id)
+        if len(ret) < 1:
+            return None
+        assert isinstance(ret[-2], SingletonRecord)
+        return ret[-2].removed_height
+
+    async def add_or_update_proposal_info(
+        self,
+        new_state: CoinSpend,
+        block_height: uint32,
+    ) -> None:
+        new_dao_info = copy.copy(self.dao_info)
+        puzzle = get_inner_puzzle_from_singleton(new_state.puzzle_reveal)
+        if puzzle is None:
+            raise ValueError("get_innerpuzzle_from_puzzle failed")
+        solution = (
+            Program.from_bytes(bytes(new_state.solution)).rest().rest().first()
+        )  # get proposal solution from full singleton solution
+        singleton_id = singleton.get_singleton_id_from_puzzle(new_state.puzzle_reveal)
+        if singleton_id is None:
+            raise ValueError("get_singleton_id_from_puzzle failed")
+        curried_args = puzzle.uncurry()[1].as_iter()
+        (
+            SINGLETON_STRUCT,  # (SINGLETON_MOD_HASH, (SINGLETON_ID, LAUNCHER_PUZZLE_HASH))
+            PROPOSAL_MOD_HASH,
+            PROPOSAL_TIMER_MOD_HASH,
+            CAT_MOD_HASH,
+            TREASURY_MOD_HASH,
+            LOCKUP_MOD_HASH,
+            CAT_TAIL_HASH,
+            TREASURY_ID,
+            YES_VOTES,  # yes votes are +1, no votes don't tally - we compare yes_votes/total_votes at the end
+            TOTAL_VOTES,  # how many people responded
+            INNERPUZ,
+        ) = curried_args
+        dao_rules = get_treasury_rules_from_puzzle(self.dao_info.current_treasury_innerpuz)
+        current_coin = get_most_recent_singleton_coin_from_coin_spend(new_state)
+        if current_coin is None:
+            raise RuntimeError("get_most_recent_singleton_coin_from_coin_spend({new_state}) failed")
+
+        ended = False
+        timer_coin = None
+        if solution.at("rrrrrrf").as_int() == 0:
+            # we need to add the vote amounts from the solution to get accurate totals
+            is_yes_vote = solution.at("rf").as_int()
+            votes_added = solution.at("ff").as_int()
+            current_innerpuz = get_new_puzzle_from_proposal_solution(puzzle, solution)
+            if current_innerpuz is None:
+                raise RuntimeError("get_new_puzzle_from_proposal_solution failed")
+        else:
+            # If we have entered the finished state
+            # TODO: we need to alert the user that they can free up their coins
+            is_yes_vote = 0
+            votes_added = 0
+            current_innerpuz = get_new_puzzle_from_proposal_solution(puzzle, solution)
+            if current_innerpuz == DAO_FINISHED_STATE:
+                ended = True
+
+        if current_coin.amount < dao_rules.proposal_minimum_amount and not ended:
+            # TODO: is this the best way of handling this?
+            # breakpoint()
+            raise ValueError("this coin does not meet the minimum requirements and can be ignored")
+        new_total_votes = TOTAL_VOTES.as_int() + votes_added
+        if new_total_votes < self.dao_info.filter_below_vote_amount:
+            return  # ignore all proposals below the filter amount
+
+        if is_yes_vote == 1:
+            new_yes_votes = YES_VOTES.as_int() + votes_added
+        else:
+            new_yes_votes = YES_VOTES.as_int()
+
+        required_yes_votes = (self.dao_rules.attendance_required * self.dao_rules.pass_percentage) // 10000
+        yes_votes_needed = max(0, required_yes_votes - new_yes_votes)
+
+        passed = True if yes_votes_needed == 0 else False
+
+        index = 0
+        for current_info in new_dao_info.proposals_list:
+            # Search for current proposal_info
+            if current_info.proposal_id == singleton_id:
+                # If we are receiving a voting spend update
+
+                # TODO: what do we do here?
+                # GW: Removed a block height check
+                new_proposal_info = ProposalInfo(
+                    singleton_id,
+                    puzzle,
+                    new_total_votes,
+                    new_yes_votes,
+                    current_coin,
+                    current_innerpuz,
+                    current_info.timer_coin,
+                    block_height,
+                    passed,
+                    ended,
+                )
+                new_dao_info.proposals_list[index] = new_proposal_info
+                await self.save_info(new_dao_info)
+                future_parent = LineageProof(
+                    new_state.coin.parent_coin_info,
+                    puzzle.get_tree_hash(),
+                    uint64(new_state.coin.amount),
+                )
+                await self.add_parent(new_state.coin.name(), future_parent)
+                return
+            index = index + 1
+
+        # Search for the timer coin
+        if not ended:
+            wallet_node: Any = self.wallet_state_manager.wallet_node
+            peer: WSChiaConnection = wallet_node.get_full_node_peer()
+            if peer is None:
+                raise ValueError("Could not find any peers to request puzzle and solution from")
+            children = await wallet_node.fetch_children(singleton_id, peer)
+            assert len(children) > 0
+            found = False
+            parent_coin_id = singleton_id
+
+            if self.dao_info.current_treasury_innerpuz is None:
+                raise ValueError("self.dao_info.current_treasury_innerpuz is None")
+
+            timer_coin_puzhash = get_proposal_timer_puzzle(
+                CAT_TAIL_HASH.as_atom(),
+                singleton_id,
+                self.dao_info.treasury_id,
+            ).get_tree_hash()
+
+            while not found and len(children) > 0:
+                children = await wallet_node.fetch_children(parent_coin_id, peer)
+                if len(children) == 0:
+                    break
+                children_state = [child for child in children if child.coin.amount % 2 == 1]
+                assert children_state is not None
+                assert len(children_state) > 0
+                child_state = children_state[0]
+                for child in children:
+                    if child.coin.puzzle_hash == timer_coin_puzhash:
+                        found = True
+                        timer_coin = child.coin
+                        break
+                child_coin = child_state.coin
+                parent_coin_id = child_coin.name()
+
+        # If we reach here then we don't currently know about this coin
+        new_proposal_info = ProposalInfo(
+            singleton_id,
+            puzzle,
+            uint64(new_total_votes),
+            uint64(new_yes_votes),
+            current_coin,
+            current_innerpuz,
+            timer_coin,  # if this is None then the proposal has finished
+            block_height,  # block height that current proposal singleton coin was created in
+            passed,
+            ended,
+        )
+        new_dao_info.proposals_list.append(new_proposal_info)
+        await self.save_info(new_dao_info)
+        future_parent = LineageProof(
+            new_state.coin.parent_coin_info,
+            puzzle.get_tree_hash(),
+            uint64(new_state.coin.amount),
+        )
+        await self.add_parent(new_state.coin.name(), future_parent)
+        return
+
+    async def update_closed_proposal_coin(self, new_state: CoinSpend, block_height: uint32) -> None:
+        new_dao_info = copy.copy(self.dao_info)
+        puzzle = get_inner_puzzle_from_singleton(new_state.puzzle_reveal)
+        proposal_id = singleton.get_singleton_id_from_puzzle(new_state.puzzle_reveal)
+        current_coin = get_most_recent_singleton_coin_from_coin_spend(new_state)
+        index = 0
+        for pi in self.dao_info.proposals_list:
+            if pi.proposal_id == proposal_id:
+                assert isinstance(current_coin, Coin)
+                new_info = ProposalInfo(
+                    proposal_id,
+                    pi.inner_puzzle,
+                    pi.amount_voted,
+                    pi.yes_votes,
+                    current_coin,
+                    pi.current_innerpuz,
+                    pi.timer_coin,
+                    pi.singleton_block_height,
+                    pi.passed,
+                    pi.closed,
+                )
+                new_dao_info.proposals_list[index] = new_info
+                await self.save_info(new_dao_info)
+                assert isinstance(puzzle, Program)
+                future_parent = LineageProof(
+                    new_state.coin.parent_coin_info,
+                    puzzle.get_tree_hash(),
+                    uint64(new_state.coin.amount),
+                )
+                await self.add_parent(new_state.coin.name(), future_parent)
+                return
+            index = index + 1
+
+    async def get_proposal_state(self, proposal_id: bytes32) -> Dict[str, Union[int, bool]]:
+        """
+        Use this to figure out whether a proposal has passed or failed and whether it can be closed
+        Given a proposal_id:
+        - if required yes votes are recorded then proposal passed.
+        - if timelock and attendance are met then proposal can close
+        Returns a dict of passed and closable bools, and the remaining votes/blocks needed
+
+        Note that a proposal can be in a passed and closable state now, but become failed if a large number of
+        'no' votes are recieved before the soft close is reached.
+        """
+        for prop in self.dao_info.proposals_list:
+            if prop.proposal_id == proposal_id:
+                is_closed = prop.closed
+                break
+        else:
+            raise ValueError(f"Proposal not found for id {proposal_id}")
+
+        wallet_node = self.wallet_state_manager.wallet_node
+        peer: WSChiaConnection = wallet_node.get_full_node_peer()
+        if peer is None:
+            raise ValueError("Could not find any peers to request puzzle and solution from")
+        assert isinstance(prop.timer_coin, Coin)
+        timer_cs = (await wallet_node.get_coin_state([prop.timer_coin.name()], peer))[0]
+        peak = await self.wallet_state_manager.blockchain.get_peak_block()
+        blocks_elapsed = peak.height - timer_cs.created_height
+
+        required_yes_votes = (self.dao_rules.attendance_required * self.dao_rules.pass_percentage) // 10000
+        total_votes_needed = max(0, self.dao_rules.attendance_required - prop.amount_voted)
+        yes_votes_needed = max(0, required_yes_votes - prop.yes_votes)
+        blocks_needed = max(0, self.dao_rules.proposal_timelock - blocks_elapsed)
+
+        passed = True if yes_votes_needed == 0 else False
+        closable = True if total_votes_needed == blocks_needed == 0 else False
+        proposal_state = {
+            "total_votes_needed": total_votes_needed,
+            "yes_votes_needed": yes_votes_needed,
+            "blocks_needed": blocks_needed,
+            "passed": passed,
+            "closable": closable,
+            "closed": is_closed,
+        }
+        return proposal_state
+
+    async def update_treasury_info(
+        self,
+        new_state: CoinSpend,
+        block_height: uint32,
+    ) -> None:
+        if self.dao_info.singleton_block_height <= block_height:
+            # TODO: what do we do here?
+            # return
+            pass
+        puzzle = get_inner_puzzle_from_singleton(new_state.puzzle_reveal)
+        if puzzle is None:
+            raise ValueError("get_innerpuzzle_from_puzzle failed")
+        solution = (
+            Program.from_bytes(bytes(new_state.solution)).rest().rest().first()
+        )  # get proposal solution from full singleton solution
+        new_innerpuz = get_new_puzzle_from_treasury_solution(puzzle, solution)
+        child_coin = get_most_recent_singleton_coin_from_coin_spend(new_state)
+        assert isinstance(child_coin, Coin)
+        assert isinstance(self.dao_info.current_treasury_coin, Coin)
+        if child_coin.puzzle_hash != self.dao_info.current_treasury_coin.puzzle_hash:
+            # update dao rules
+            assert isinstance(new_innerpuz, Program)
+            self.dao_rules = get_treasury_rules_from_puzzle(new_innerpuz)
+        dao_info = DAOInfo(
+            self.dao_info.treasury_id,  # treasury_id: bytes32
+            self.dao_info.cat_wallet_id,
+            self.dao_info.dao_cat_wallet_id,
+            self.dao_info.proposals_list,  # proposals_list: List[ProposalInfo]
+            self.dao_info.parent_info,  # treasury_id: bytes32
+            child_coin,  # current_coin
+            new_innerpuz,  # current innerpuz
+            block_height,  # block_height: uint32
+            self.dao_info.filter_below_vote_amount,
+            self.dao_info.assets,
+            self.dao_info.current_height,
+        )
+        await self.save_info(dao_info)
+        future_parent = LineageProof(
+            new_state.coin.parent_coin_info,
+            puzzle.get_tree_hash(),
+            uint64(new_state.coin.amount),
+        )
+        await self.add_parent(new_state.coin.name(), future_parent)
+        return
+
+    async def get_spend_history(self, singleton_id: bytes32) -> List[Tuple[uint32, CoinSpend]]:
+        ret: List[
+            Tuple[uint32, CoinSpend]
+        ] = await self.wallet_state_manager.singleton_store.get_records_by_singleton_id(singleton_id)
+        if len(ret) == 0:
+            raise ValueError(f"No records found in singleton store for singleton id {singleton_id}")
+        return ret
+
+    # TODO: Find a nice way to express interest in more than one singleton.
+    #     e.g. def register_singleton_for_wallet()
+    async def apply_state_transition(self, new_state: CoinSpend, block_height: uint32) -> bool:
+        """
+        We are being notified of a singleton state transition. A Singleton has been spent.
+        Returns True iff the spend is a valid transition spend for the singleton, False otherwise.
+        """
+
+        self.log.info(
+            f"DAOWallet.apply_state_transition called with the height: {block_height} and CoinSpend of {new_state.coin.name()}."
+        )
+        singleton_id = get_singleton_id_from_puzzle(new_state.puzzle_reveal)
+        if not singleton_id:
+            raise ValueError("Received a non singleton coin for dao wallet")
+        tip: Optional[Tuple[uint32, SingletonRecord]] = await self.get_tip(singleton_id)
+        if tip is None:
+            # this is our first time, just store it
+            await self.wallet_state_manager.singleton_store.add_spend(self.wallet_id, new_state, block_height)
+        else:
+            assert isinstance(tip, SingletonRecord)
+            tip_spend = tip.parent_coinspend
+
+            tip_coin: Optional[Coin] = get_most_recent_singleton_coin_from_coin_spend(tip_spend)
+            assert tip_coin is not None
+            # spent_coin_name: bytes32 = tip_coin.name()
+
+            # TODO: Work out what is needed here
+            # if spent_coin_name != new_state.coin.name():
+            #     history: List[Tuple[uint32, CoinSpend]] = await self.get_spend_history()
+            #     if new_state.coin.name() in [sp.coin.name() for _, sp in history]:
+            #         self.log.info(f"Already have state transition: {new_state.coin.name().hex()}")
+            #     else:
+            #         self.log.warning(
+            #             f"Failed to apply state transition. tip: {tip_coin} new_state: {new_state} height {block_height}"
+            #         )
+            #     return False
+
+            # TODO: Add check for pending transaction on our behalf in here
+            # if we have pending transaction that is now invalidated, then:
+            # check if we should auto re-create spend or flash error to use (should we have a failed tx db?)
+            await self.wallet_state_manager.singleton_store.add_spend(self.wallet_id, new_state, block_height)
+
+        # Consume new DAOBlockchainInfo
+        # Determine if this is a treasury spend or a proposal spend
+        puzzle = get_inner_puzzle_from_singleton(new_state.puzzle_reveal)
+        assert puzzle
+        try:
+            mod, curried_args = puzzle.uncurry()
+        except ValueError as e:
+            self.log.warning("Cannot uncurry puzzle in DAO Wallet: error: %s", e)
+            raise e
+        if mod == DAO_TREASURY_MOD:
+            await self.update_treasury_info(new_state, block_height)
+        elif mod == DAO_PROPOSAL_MOD:
+            await self.add_or_update_proposal_info(new_state, block_height)
+        elif puzzle == DAO_FINISHED_STATE:
+            await self.update_closed_proposal_coin(new_state, block_height)
+        else:
+            raise ValueError(f"Unsupported spend in DAO Wallet: {self.id()}")
+
+        return True
+
+    async def new_peak(self, peak_height: uint64) -> None:
+        """
+        new_peak is called from the WalletStateManager whenever there is a new peak
+        # This is where we can attempt to push spends, check on time locks, etc.
+        """
+
+        dao_info = DAOInfo(
+            self.dao_info.treasury_id,  # treasury_id: bytes32
+            self.dao_info.cat_wallet_id,
+            self.dao_info.dao_cat_wallet_id,
+            self.dao_info.proposals_list,  # proposals_list: List[ProposalInfo]
+            self.dao_info.parent_info,  # treasury_id: bytes32
+            self.dao_info.current_treasury_coin,
+            self.dao_info.current_treasury_innerpuz,
+            self.dao_info.singleton_block_height,
+            self.dao_info.filter_below_vote_amount,
+            self.dao_info.assets,
+            self.dao_info.current_height,
+        )
+        await self.save_info(dao_info)
+        pass
diff --git a/chia/wallet/dao_wallet/dao_wallet_puzzles.py b/chia/wallet/dao_wallet/dao_wallet_puzzles.py
new file mode 100644
index 000000000..d04a29520
--- /dev/null
+++ b/chia/wallet/dao_wallet/dao_wallet_puzzles.py
@@ -0,0 +1,33 @@
+from __future__ import annotations
+
+from chia.types.blockchain_format.program import Program
+from chia.types.blockchain_format.sized_bytes import bytes32
+
+
+def get_dao_inner_puzhash_by_p2(
+    p2_puzzle_hash: bytes32,
+    launcher_id: bytes32,
+    metadata: Program = Program.to([]),
+) -> bytes32:
+    """
+    Calculate DAO inner puzzle hash from a P2 puzzle hash
+    :param p2_puzzle_hash: P2 puzzle hash
+    :param launcher_id: ID of the launch coin
+    :param metadata: DAO metadata
+    :return: DAO inner puzzle hash
+    """
+
+    # backup_ids_hash = Program(Program.to(recovery_list)).get_tree_hash()
+    # singleton_struct = Program.to((SINGLETON_TOP_LAYER_MOD_HASH, (launcher_id, LAUNCHER_PUZZLE_HASH)))
+    #
+    # quoted_mod_hash = calculate_hash_of_quoted_mod_hash(TREASURY_INNERPUZ_MOD_HASH)
+    #
+    # return curry_and_treehash(
+    #     quoted_mod_hash,
+    #     p2_puzzle_hash,
+    #     Program.to(backup_ids_hash).get_tree_hash(),
+    #     Program.to(num_of_backup_ids_needed).get_tree_hash(),
+    #     Program.to(singleton_struct).get_tree_hash(),
+    #     metadata.get_tree_hash(),
+    # )
+    return bytes32(b"0" * 32)
diff --git a/chia/wallet/did_wallet/did_wallet.py b/chia/wallet/did_wallet/did_wallet.py
index ab854ceec..d251b26af 100644
--- a/chia/wallet/did_wallet/did_wallet.py
+++ b/chia/wallet/did_wallet/did_wallet.py
@@ -233,7 +233,7 @@ class DIDWallet:
             None,
             None,
             False,
-            json.dumps(did_wallet_puzzles.program_to_metadata(metadata)),
+            json.dumps(did_wallet_puzzles.did_program_to_metadata(metadata)),
         )
         self.check_existed_did()
         info_as_string = json.dumps(self.did_info.to_json_dict())
diff --git a/chia/wallet/did_wallet/did_wallet_puzzles.py b/chia/wallet/did_wallet/did_wallet_puzzles.py
index 0d615c31b..4205f16b2 100644
--- a/chia/wallet/did_wallet/did_wallet_puzzles.py
+++ b/chia/wallet/did_wallet/did_wallet_puzzles.py
@@ -187,7 +187,7 @@ def metadata_to_program(metadata: Dict) -> Program:
     return Program.to(kv_list)
 
 
-def program_to_metadata(program: Program) -> Dict:
+def did_program_to_metadata(program: Program) -> Dict:
     """
     Convert a program to a metadata dict
     :param program: Chialisp program contains the metadata
diff --git a/chia/wallet/nft_wallet/nft_puzzles.py b/chia/wallet/nft_wallet/nft_puzzles.py
index 44f6f79a1..820277fab 100644
--- a/chia/wallet/nft_wallet/nft_puzzles.py
+++ b/chia/wallet/nft_wallet/nft_puzzles.py
@@ -146,7 +146,7 @@ def metadata_to_program(metadata: Dict[bytes, Any]) -> Program:
     return program
 
 
-def program_to_metadata(program: Program) -> Dict[bytes, Any]:
+def nft_program_to_metadata(program: Program) -> Dict[bytes, Any]:
     """
     Convert a program to a metadata dict
     :param program: Chialisp program contains the metadata
@@ -181,7 +181,7 @@ def update_metadata(metadata: Program, update_condition: Program) -> Program:
     :param update_condition: Update metadata conditions
     :return: Updated metadata
     """
-    new_metadata: Dict[bytes, Any] = program_to_metadata(metadata)
+    new_metadata: Dict[bytes, Any] = nft_program_to_metadata(metadata)
     uri: Program = update_condition.rest().rest().first()
     prepend_value(uri.first().as_python(), uri.rest(), new_metadata)
     return metadata_to_program(new_metadata)
diff --git a/chia/wallet/puzzles/curry_by_index.clib b/chia/wallet/puzzles/curry_by_index.clib
new file mode 100644
index 000000000..299f2fd69
--- /dev/null
+++ b/chia/wallet/puzzles/curry_by_index.clib
@@ -0,0 +1,16 @@
+(
+  (defun recurry_by_index_ordered (
+      index_value_pairs_list  ; MUST BE ORDERED
+      current_position  ; must be 0 on initial call
+      CURRENT_PARAMS  ; current list of curry params
+    )
+    (if index_value_pairs_list
+        (if (= (f (f index_value_pairs_list)) current_position)
+            (c (r (f index_value_pairs_list)) (recurry_by_index_ordered (r index_value_pairs_list) (+ current_position 1) (r CURRENT_PARAMS)))
+            (c (f CURRENT_PARAMS) (recurry_by_index_ordered index_value_pairs_list (+ current_position 1) (r CURRENT_PARAMS)))
+        )
+        ()
+    )
+  )
+
+)
diff --git a/chia/wallet/puzzles/dao_cat_buy_in.clsp b/chia/wallet/puzzles/dao_cat_buy_in.clsp
new file mode 100644
index 000000000..be86e9511
--- /dev/null
+++ b/chia/wallet/puzzles/dao_cat_buy_in.clsp
@@ -0,0 +1,71 @@
+; This is an innerpuz inside a DAO CAT, or any CAT, or even any coin, which locks it up until a payment gets made
+
+(mod (
+    INPUT_RATIO_INT  ; the default here is 1 - meaning for one chia input you get exactly the OUTPUT_RATIO_INT output
+    OUTPUT_RATIO_INT  ; the default here is 1 - meaning for one output you must pay exactly the INPUT_RATIO_INT as input
+    ; IMPORTANT NOTE: this does not implicitly take into account the 1:1000 Chia/CAT conversation that the UI uses
+    SETTLEMENT_PAYMENTS_PUZHASH  ; a notarized coin payment is `(nonce . ((puzzle_hash amount ...) (puzzle_hash amount ...) ...))`
+    ; here we will use this coin's ID as the nonce to prevent someone from claiming multiple buy ins at once
+    BUY_IN_PAYMENT_ADDRESS  ; this is the address we check that a payment has been made to before paying out
+    ; for the DAO we curry the p2_singleton with the DAO Treasury ID in the wallet and then curry that here
+    new_puzhash  ; this is secured by creating an announcement here which must be asserted elsewhere
+    ; ^ probably by the puzzle that creates the settlement. Where that, the settlement, and this are spent together.
+    payment_amount  ; secured in the same announcement as above
+    my_coin_id
+    my_puzhash
+    my_amount
+  )
+  (include condition_codes.clib)
+  (include curry-and-treehash.clib)
+  (include *standard-cl-21*)
+
+  (defconstant TEN_THOUSAND 10000)
+
+  ; TODO: optimise out the repeated divmod - apparently it costs 1116	(third most expensive op)
+  (defun calculate_output (INPUT_RATIO_INT OUTPUT_RATIO_INT payment_amount)
+    (+
+      (* (f (divmod payment_amount INPUT_RATIO_INT)) OUTPUT_RATIO_INT)
+      (calculate_percentage output (f (divmod (* (r (divmod payment_amount INPUT_RATIO_INT)) TEN_THOUSAND) INPUT_RATIO_INT)))
+    )
+  )
+
+  (defun-inline calculate_percentage (amount percentage)
+    (f (divmod (* amount percentage) TEN_THOUSAND))
+  )
+
+  (defun create_outputs (my_puzhash new_puzhash my_amount calculated_output)
+    (list
+      (list CREATE_COIN my_puzhash (- my_amount calculate_output))
+      (list CREATE_COIN new_puzhash calculated_output)
+    )
+  )
+
+  (c
+    (list
+      ASSERT_PUZZLE_ANNOUNCEMENT
+      (sha256
+        SETTLEMENT_PAYMENTS_PUZHASH
+        (sha256tree
+          (c
+            my_coin_id
+            (list (list BUY_IN_PAYMENT_ADDRESS payment_amount))
+          )
+        )
+      )
+    )
+    (c
+      (list CREATE_COIN_ANNOUNCEMENT (sha256tree (c new_puzhash payment_amount)))
+      (c
+        (list ASSERT_MY_ID my_coin_id)
+        (c
+          (list ASSERT_MY_PUZZLEHASH my_puzhash)
+          (c
+            (list ASSERT_MY_AMOUNT my_amount)
+            (create_outputs my_puzhash new_puzhash my_amount (calculate_output INPUT_RATIO_INT OUTPUT_RATIO_INT payment_amount))
+          )
+        )
+
+      )
+    )
+  )
+)
diff --git a/chia/wallet/puzzles/dao_cat_buy_in.clsp.hex b/chia/wallet/puzzles/dao_cat_buy_in.clsp.hex
new file mode 100644
index 000000000..8e4ac2567
--- /dev/null
+++ b/chia/wallet/puzzles/dao_cat_buy_in.clsp.hex
@@ -0,0 +1 @@
+ff02ffff01ff04ffff04ffff013fffff04ffff0bff17ffff02ff04ffff04ff02ffff04ffff04ff82017fffff04ffff04ff2fffff04ff8200bfffff01808080ffff01808080ff8080808080ffff01808080ffff04ffff04ffff013cffff04ffff02ff04ffff04ff02ffff04ffff04ff5fff8200bf80ff80808080ffff01808080ffff04ffff04ffff018c4153534552545f4d595f4944ffff04ff82017fffff01808080ffff04ffff04ffff0148ffff04ff8202ffffff01808080ffff04ffff04ffff0149ffff04ff8205ffffff01808080ffff02ff0effff04ff02ffff04ff8202ffffff04ff5fffff04ff8205ffffff04ffff02ff0affff04ff02ffff04ff05ffff04ff0bffff04ff8200bfff808080808080ff808080808080808080808080ffff04ffff01ffff02ffff03ffff07ff0580ffff01ff02ffff01ff0bffff0102ffff02ff04ffff04ff02ffff04ffff05ff0580ff80808080ffff02ff04ffff04ff02ffff04ffff06ff0580ff8080808080ff0180ffff01ff02ffff01ff0bffff0101ff0580ff018080ff0180ffff10ffff12ffff05ffff14ff17ff058080ff0b80ffff05ffff14ffff12ffff01866f7574707574ffff05ffff14ffff12ffff06ffff14ff17ff058080ffff0182271080ff05808080ffff01822710808080ff04ffff04ffff0133ffff04ff05ffff04ffff11ff17ff0a80ff80808080ffff04ffff04ffff0133ffff04ff0bffff04ff2fff80808080ff808080ff018080
\ No newline at end of file
diff --git a/chia/wallet/puzzles/dao_cat_eve.clsp b/chia/wallet/puzzles/dao_cat_eve.clsp
new file mode 100644
index 000000000..de7016a8a
--- /dev/null
+++ b/chia/wallet/puzzles/dao_cat_eve.clsp
@@ -0,0 +1,13 @@
+(mod (
+    NEW_PUZZLE_HASH  ; this is the CAT inner_puzzle
+    my_amount
+    tail_reveal
+    tail_solution
+  )
+  (include condition_codes.clib)
+  (list
+    (list CREATE_COIN NEW_PUZZLE_HASH my_amount (list NEW_PUZZLE_HASH))
+    (list ASSERT_MY_AMOUNT my_amount)
+    (list CREATE_COIN 0 -113 tail_reveal tail_solution)  ; this is secure because anything but the real values won't work
+  )
+)
diff --git a/chia/wallet/puzzles/dao_cat_eve.clsp.hex b/chia/wallet/puzzles/dao_cat_eve.clsp.hex
new file mode 100644
index 000000000..23f72b9be
--- /dev/null
+++ b/chia/wallet/puzzles/dao_cat_eve.clsp.hex
@@ -0,0 +1 @@
+ff02ffff01ff04ffff04ff06ffff04ff05ffff04ff0bffff04ffff04ff05ff8080ff8080808080ffff04ffff04ff04ffff04ff0bff808080ffff04ffff04ff06ffff04ff80ffff04ffff01818fffff04ff17ffff04ff2fff808080808080ff80808080ffff04ffff01ff4933ff018080
diff --git a/chia/wallet/puzzles/dao_cat_launcher.clsp b/chia/wallet/puzzles/dao_cat_launcher.clsp
new file mode 100644
index 000000000..205451645
--- /dev/null
+++ b/chia/wallet/puzzles/dao_cat_launcher.clsp
@@ -0,0 +1,36 @@
+(mod (
+    TREASURY_SINGLETON_STRUCT
+    treasury_inner_puz_hash
+    parent_parent
+    new_puzzle_hash  ; the full CAT puzzle
+    amount
+  )
+  (include condition_codes.clib)
+  (include curry-and-treehash.clib)
+
+  (defun calculate_singleton_puzzle_hash (PROPOSAL_SINGLETON_STRUCT inner_puzzle_hash)
+    (puzzle-hash-of-curried-function (f PROPOSAL_SINGLETON_STRUCT)
+      inner_puzzle_hash
+      (sha256tree PROPOSAL_SINGLETON_STRUCT)
+    )
+  )
+
+  (defun create_parent_conditions (parent_id new_puzzle_hash amount)
+    (list
+      (list ASSERT_COIN_ANNOUNCEMENT (sha256 parent_id (sha256tree (list 'm' new_puzzle_hash))))
+      (list ASSERT_MY_PARENT_ID parent_id)
+    )
+  )
+
+  (c
+    (list CREATE_COIN new_puzzle_hash amount (list new_puzzle_hash (sha256tree (list 'm' new_puzzle_hash)) (list 'm' new_puzzle_hash)))
+    (c
+      (list ASSERT_MY_AMOUNT amount)
+      (create_parent_conditions
+        (sha256 parent_parent (calculate_singleton_puzzle_hash TREASURY_SINGLETON_STRUCT treasury_inner_puz_hash) ONE)
+        new_puzzle_hash
+        amount
+      )
+    )
+  )
+)
diff --git a/chia/wallet/puzzles/dao_cat_launcher.clsp.hex b/chia/wallet/puzzles/dao_cat_launcher.clsp.hex
new file mode 100644
index 000000000..f0fc7a252
--- /dev/null
+++ b/chia/wallet/puzzles/dao_cat_launcher.clsp.hex
@@ -0,0 +1 @@
+ff02ffff01ff04ffff04ff34ffff04ff2fffff04ff5fffff04ffff04ff2fffff04ffff02ff3effff04ff02ffff04ffff04ffff016dffff04ff2fff808080ff80808080ffff04ffff04ffff016dffff04ff2fff808080ff80808080ff8080808080ffff04ffff04ff28ffff04ff5fff808080ffff02ff36ffff04ff02ffff04ffff0bff17ffff02ff26ffff04ff02ffff04ff05ffff04ff0bff8080808080ff3c80ffff04ff2fffff04ff5fff8080808080808080ffff04ffff01ffffff3dff4947ffff0233ff0401ffff01ff02ff02ffff03ff05ffff01ff02ff3affff04ff02ffff04ff0dffff04ffff0bff2affff0bff3cff2c80ffff0bff2affff0bff2affff0bff3cff1280ff0980ffff0bff2aff0bffff0bff3cff8080808080ff8080808080ffff010b80ff0180ffffff02ff2effff04ff02ffff04ff09ffff04ff0bffff04ffff02ff3effff04ff02ffff04ff05ff80808080ff808080808080ff04ffff04ff10ffff04ffff0bff05ffff02ff3effff04ff02ffff04ffff04ffff016dffff04ff0bff808080ff8080808080ff808080ffff04ffff04ff38ffff04ff05ff808080ff808080ffff0bff2affff0bff3cff2480ffff0bff2affff0bff2affff0bff3cff1280ff0580ffff0bff2affff02ff3affff04ff02ffff04ff07ffff04ffff0bff3cff3c80ff8080808080ffff0bff3cff8080808080ff02ffff03ffff07ff0580ffff01ff0bffff0102ffff02ff3effff04ff02ffff04ff09ff80808080ffff02ff3effff04ff02ffff04ff0dff8080808080ffff01ff0bffff0101ff058080ff0180ff018080
diff --git a/chia/wallet/puzzles/dao_dividend.clsp b/chia/wallet/puzzles/dao_dividend.clsp
new file mode 100644
index 000000000..5c7467e4b
--- /dev/null
+++ b/chia/wallet/puzzles/dao_dividend.clsp
@@ -0,0 +1,57 @@
+(mod
+  (
+    SINGLETON_STRUCT  ; ((SINGLETON_MOD_HASH, (SINGLETON_ID, LAUNCHER_PUZZLE_HASH)))
+    DAO_DIVIDEND_MOD
+    DAO_DIVIDEND_TIMER_MOD
+    CAT_MOD_HASH
+    TREASURY_MOD_HASH
+    LOCKUP_MOD_HASH
+    STARTING_CHIA_AMOUNT
+    CURRENT_CAT_ISSUANCE
+    TIMELOCK
+    spend_type
+    my_amount
+  )
+
+  (include condition_codes.clib)
+  (include curry-and-treehash.clib)
+  (defconstant dao_finished_state 0xfb015415f2e6a09c1141f880fc2135beec6adf2a19e4d02a191432846db16559)
+
+  ; TODO: THIS FILE IS NOT FINISHED
+
+  (defun-inline calculate_percentage (amount percentage)
+    (f (divmod (* amount percentage) TEN_THOUSAND))
+  )
+
+  (defun calculate_dividend_timer_puzzlehash (DAO_DIVIDEND_TIMER_MOD)
+    ()
+  )
+
+  (if spend_type
+      ; claim
+      (c
+        (list ASSERT_MY_AMOUNT my_amount)
+        (if (> my_amount STARTING_CHIA_AMOUNT)
+            (if (= my_amount STARTING_CHIA_AMOUNT)
+                (list CREATE_COIN (calculate_dividend_timer_puzzlehash ) 0)  ; create proposal timer - this prevents the dividend from starting with inaccurate amounts
+                ()
+            )
+            (x)
+        )
+      )
+
+      ; move to finished state
+      (list
+        (list CREATE_COIN dao_finished_state ONE)
+        (list ASSERT_MY_AMOUNT my_amount)
+        (list ASSERT_PUZZLE_ANNOUNCEMENT  ; assert that the treasury has actually taken the payment
+          (sha256
+            ;; Commented out to pass clvm compile checks
+            ;; (calculate_treasury_puzzlehash)
+            (sha256tree (list (- my_amount ONE) (f (r SINGLETON_STRUCT))))
+          )
+        )
+      )
+  )
+
+)
diff --git a/chia/wallet/puzzles/dao_dividend.clsp.hex b/chia/wallet/puzzles/dao_dividend.clsp.hex
new file mode 100644
index 000000000..077854c9e
--- /dev/null
+++ b/chia/wallet/puzzles/dao_dividend.clsp.hex
@@ -0,0 +1 @@
+ff02ffff01ff02ffff03ff820bffffff01ff04ffff04ff08ffff04ff8217ffff808080ffff02ffff03ffff15ff8217ffff82017f80ffff01ff02ffff03ffff09ff8217ffff82017f80ffff01ff04ff1cffff04ffff02ff1affff04ff02ff808080ffff01ff80808080ff8080ff0180ffff01ff088080ff018080ffff01ff04ffff04ff1cffff04ff16ffff04ff12ff80808080ffff04ffff04ff08ffff04ff8217ffff808080ffff04ffff04ff14ffff04ffff0bffff02ff1effff04ff02ffff04ffff04ffff11ff8217ffff1280ffff04ff15ff808080ff8080808080ff808080ff8080808080ff0180ffff04ffff01ffff49ff3f33ffff0180ffa0fb015415f2e6a09c1141f880fc2135beec6adf2a19e4d02a191432846db16559ff02ffff03ffff07ff0580ffff01ff0bffff0102ffff02ff1effff04ff02ffff04ff09ff80808080ffff02ff1effff04ff02ffff04ff0dff8080808080ffff01ff0bffff0101ff058080ff0180ff018080
\ No newline at end of file
diff --git a/chia/wallet/puzzles/dao_dividend_timer.clsp b/chia/wallet/puzzles/dao_dividend_timer.clsp
new file mode 100644
index 000000000..d10377862
--- /dev/null
+++ b/chia/wallet/puzzles/dao_dividend_timer.clsp
@@ -0,0 +1,96 @@
+; This is a persistent timer for a proposal which allows it to have a relative time that survives despite it being recreated.
+; It has a curried TIMELOCK, which is applied as a ASSERT_HEIGHT_RELATIVE
+; It creates/asserts announcements to pair it with the finishing spend of a proposal
+
+(mod (
+    DIVIDEND_MOD_HASH
+    DIVIDEND_TIMER_MOD_HASH
+    CAT_MOD_HASH
+    CAT_TAIL
+    CURRENT_CAT_ISSUANCE
+    TIMELOCK
+    MY_PARENT_SINGLETON_STRUCT
+    TREASURY_ID
+
+  )
+  (include condition_codes.clib)
+  (include curry-and-treehash.clib)
+  (include *standard-cl-21*)
+
+  ; TODO: THIS FILE IS NOT FINISHED
+
+  (defun calculate_singleton_puzzle_hash (PROPOSAL_SINGLETON_STRUCT inner_puzzle_hash)
+    (puzzle-hash-of-curried-function (f PROPOSAL_SINGLETON_STRUCT)
+      inner_puzzle_hash
+      (sha256tree PROPOSAL_SINGLETON_STRUCT)
+    )
+  )
+
+  (defun calculate_dividend_puzzlehash (
+      PROPOSAL_SINGLETON_STRUCT
+      PROPOSAL_MOD_HASH
+      PROPOSAL_TIMER_MOD_HASH
+      CAT_MOD_HASH
+      CAT_TAIL
+      CURRENT_CAT_ISSUANCE
+      PROPOSAL_PASS_PERCENTAGE
+      TREASURY_ID
+      PROPOSAL_TIMELOCK
+      proposal_current_votes
+      proposal_total_votes
+      proposal_innerpuzhash
+    )
+    (puzzle-hash-of-curried-function PROPOSAL_MOD_HASH
+      proposal_innerpuzhash
+      (sha256 ONE proposal_total_votes)
+      (sha256 ONE proposal_current_votes)
+      (sha256 ONE PROPOSAL_TIMELOCK)
+      (sha256 ONE TREASURY_ID)
+      (sha256 ONE PROPOSAL_PASS_PERCENTAGE)
+      (sha256 ONE CURRENT_CAT_ISSUANCE)
+      (sha256 ONE CAT_TAIL)
+      (sha256 ONE CAT_MOD_HASH)
+      (sha256 ONE PROPOSAL_TIMER_MOD_HASH)
+      (sha256 ONE PROPOSAL_MOD_HASH)
+      (sha256tree PROPOSAL_SINGLETON_STRUCT)
+    )
+  )
+
+  ; saves the calculated proposal puzzlehash to use in two conditions rather than calculating it twice
+  (defun generate_proposal_conditions (TREASURY_ID dividend_puzzlehash proposal_parent_id proposal_amount)
+    (list
+      (list ASSERT_PUZZLE_ANNOUNCEMENT (sha256 dividend_puzzlehash TREASURY_ID))
+      (list ASSERT_MY_PARENT_ID (calculate_coin_id proposal_parent_id dividend_puzzlehash proposal_amount))
+    )
+  )
+
+
+  ; main
+  (c
+    (list ASSERT_HEIGHT_RELATIVE PROPOSAL_TIMELOCK)
+    (c
+      (list CREATE_PUZZLE_ANNOUNCEMENT (f (r MY_PARENT_SINGLETON_STRUCT)))
+      (generate_proposal_conditions
+        TREASURY_ID
+        (calculate_singleton_puzzle_hash MY_PARENT_SINGLETON_STRUCT
+          (calculate_dividend_puzzlehash
+            MY_PARENT_SINGLETON_STRUCT
+            PROPOSAL_MOD_HASH
+            PROPOSAL_TIMER_MOD_HASH
+            CAT_MOD_HASH
+            CAT_TAIL
+            CURRENT_CAT_ISSUANCE
+            PROPOSAL_PASS_PERCENTAGE
+            TREASURY_ID
+            PROPOSAL_TIMELOCK
+            proposal_current_votes
+            proposal_total_votes
+            proposal_innerpuzhash
+          )
+        )
+        proposal_parent_id
+        proposal_amount
+      )
+    )
+  )
+)
diff --git a/chia/wallet/puzzles/dao_dividend_timer.clsp.hex b/chia/wallet/puzzles/dao_dividend_timer.clsp.hex
new file mode 100644
index 000000000..4fefb21ee
--- /dev/null
+++ b/chia/wallet/puzzles/dao_dividend_timer.clsp.hex
@@ -0,0 +1 @@
+ff02ffff01ff04ffff04ffff0152ffff04ffff019150524f504f53414c5f54494d454c4f434bffff01808080ffff04ffff04ffff013effff04ffff05ffff06ff82017f8080ffff01808080ffff02ff1effff04ff02ffff04ff8202ffffff04ffff02ff1affff04ff02ffff04ff82017fffff04ffff02ff16ffff04ff02ffff04ff82017fffff04ffff019150524f504f53414c5f4d4f445f48415348ffff04ffff019750524f504f53414c5f54494d45525f4d4f445f48415348ffff04ff17ffff04ff2fffff04ff5fffff04ffff019850524f504f53414c5f504153535f50455243454e54414745ffff04ff8202ffffff04ffff019150524f504f53414c5f54494d454c4f434bffff04ffff019670726f706f73616c5f63757272656e745f766f746573ffff04ffff019470726f706f73616c5f746f74616c5f766f746573ffff04ffff019570726f706f73616c5f696e6e657270757a68617368ff808080808080808080808080808080ff8080808080ffff04ffff019270726f706f73616c5f706172656e745f6964ffff04ffff018f70726f706f73616c5f616d6f756e74ff808080808080808080ffff04ffff01ffffff02ffff03ff05ffff01ff02ffff01ff02ff08ffff04ff02ffff04ffff06ff0580ffff04ffff0bffff0102ffff0bffff0101ffff010480ffff0bffff0102ffff0bffff0102ffff0bffff0101ffff010180ffff05ff058080ffff0bffff0102ff0bffff0bffff0101ffff018080808080ff8080808080ff0180ffff01ff02ffff010bff018080ff0180ffff0bffff0102ffff01a0a12871fee210fb8619291eaea194581cbd2531e4b23759d225f6806923f63222ffff0bffff0102ffff0bffff0102ffff01a09dcf97a184f32623d11a73124ceb99a5709b083721e878a16d78f596718ba7b2ff0580ffff0bffff0102ffff02ff08ffff04ff02ffff04ff07ffff01ffa09dcf97a184f32623d11a73124ceb99a5709b083721e878a16d78f596718ba7b280808080ffff01a04bf5122f344554c53bde2ebb8cd2b7e3d1600ad631c385a5d7cce23c7785459a808080ff02ffff03ffff22ffff09ffff0dff0580ffff012080ffff09ffff0dff0b80ffff012080ffff15ff17ffff0181ff8080ffff01ff02ffff01ff0bff05ff0bff1780ff0180ffff01ff02ffff01ff0880ff018080ff0180ffffff02ffff03ffff07ff0580ffff01ff02ffff01ff0bffff0102ffff02ff12ffff04ff02ffff04ffff05ff0580ff80808080ffff02ff12ffff04ff02ffff04ffff06ff0580ff8080808080ff0180ffff01ff02ffff01ff0bffff0101ff0580ff018080ff0180ff02ff14ffff04ff02ffff04ff09ffff04ff0bffff04ffff02ff12ffff04ff02ffff04ff05ff80808080ff808080808080ffff02ff14ffff04ff02ffff04ff0bffff04ff822fffffff04ffff0bffff0101ff8217ff80ffff04ffff0bffff0101ff820bff80ffff04ffff0bffff0101ff8205ff80ffff04ffff0bffff0101ff8202ff80ffff04ffff0bffff0101ff82017f80ffff04ffff0bffff0101ff8200bf80ffff04ffff0bffff0101ff5f80ffff04ffff0bffff0101ff2f80ffff04ffff0bffff0101ff1780ffff04ffff0bffff0101ff0b80ffff04ffff02ff12ffff04ff02ffff04ff05ff80808080ff80808080808080808080808080808080ff04ffff04ffff013fffff04ffff0bff0bff0580ff808080ffff04ffff04ffff0147ffff04ffff02ff1cffff04ff02ffff04ff17ffff04ff0bffff04ff2fff808080808080ff808080ff808080ff018080
\ No newline at end of file
diff --git a/chia/wallet/puzzles/dao_finished_state.clsp b/chia/wallet/puzzles/dao_finished_state.clsp
new file mode 100644
index 000000000..cef81fdfe
--- /dev/null
+++ b/chia/wallet/puzzles/dao_finished_state.clsp
@@ -0,0 +1,35 @@
+; This code is the end state of a proposal or a dividend.
+; It is an oracle which simply recreates itself and emits an announcement that it has concluded operation
+
+(mod (SINGLETON_STRUCT DAO_FINISHED_STATE_MOD_HASH my_amount)
+  (include condition_codes.clib)
+  (include curry-and-treehash.clib)
+  (include *standard-cl-21*)
+
+  (defun wrap_in_singleton (SINGLETON_STRUCT my_inner_puzhash)
+    (puzzle-hash-of-curried-function (f SINGLETON_STRUCT)
+      my_inner_puzhash
+      (sha256tree SINGLETON_STRUCT)
+    )
+  )
+
+  (defun recreate_self (SINGLETON_STRUCT DAO_FINISHED_STATE_MOD_HASH)
+    (puzzle-hash-of-curried-function DAO_FINISHED_STATE_MOD_HASH
+      (sha256 ONE DAO_FINISHED_STATE_MOD_HASH)
+      (sha256tree SINGLETON_STRUCT)
+    )
+  )
+
+
+  (let
+    (
+      (my_inner_puzhash (recreate_self SINGLETON_STRUCT DAO_FINISHED_STATE_MOD_HASH))
+    )
+    (list
+      (list ASSERT_MY_PUZZLEHASH (wrap_in_singleton SINGLETON_STRUCT my_inner_puzhash))
+      (list ASSERT_MY_AMOUNT my_amount)
+      (list CREATE_COIN my_inner_puzhash my_amount)
+      (list CREATE_PUZZLE_ANNOUNCEMENT 'f')
+    )
+  )
+)
diff --git a/chia/wallet/puzzles/dao_finished_state.clsp.hex b/chia/wallet/puzzles/dao_finished_state.clsp.hex
new file mode 100644
index 000000000..ae24d9c61
--- /dev/null
+++ b/chia/wallet/puzzles/dao_finished_state.clsp.hex
@@ -0,0 +1 @@
+ff02ffff01ff04ffff04ffff0148ffff04ffff02ff16ffff04ff02ffff04ffff05ffff06ff018080ffff04ffff02ff1effff04ff02ffff04ff05ffff04ff0bff8080808080ff8080808080ffff01808080ffff04ffff04ffff0149ffff04ffff05ffff06ffff06ffff06ff0180808080ffff01808080ffff04ffff04ffff0133ffff04ffff02ff1effff04ff02ffff04ff05ffff04ff0bff8080808080ffff04ffff05ffff06ffff06ffff06ff0180808080ffff0180808080ffff04ffff04ffff013effff04ffff0166ffff01808080ffff018080808080ffff04ffff01ffffff02ffff03ff05ffff01ff02ffff01ff02ff08ffff04ff02ffff04ffff06ff0580ffff04ffff0bffff0102ffff0bffff0101ffff010480ffff0bffff0102ffff0bffff0102ffff0bffff0101ffff010180ffff05ff058080ffff0bffff0102ff0bffff0bffff0101ffff018080808080ff8080808080ff0180ffff01ff02ffff010bff018080ff0180ff0bffff0102ffff01a0a12871fee210fb8619291eaea194581cbd2531e4b23759d225f6806923f63222ffff0bffff0102ffff0bffff0102ffff01a09dcf97a184f32623d11a73124ceb99a5709b083721e878a16d78f596718ba7b2ff0580ffff0bffff0102ffff02ff08ffff04ff02ffff04ff07ffff01ffa09dcf97a184f32623d11a73124ceb99a5709b083721e878a16d78f596718ba7b280808080ffff01a04bf5122f344554c53bde2ebb8cd2b7e3d1600ad631c385a5d7cce23c7785459a808080ffff02ffff03ffff07ff0580ffff01ff02ffff01ff0bffff0102ffff02ff0affff04ff02ffff04ffff05ff0580ff80808080ffff02ff0affff04ff02ffff04ffff06ff0580ff8080808080ff0180ffff01ff02ffff01ff0bffff0101ff0580ff018080ff0180ffff02ff0cffff04ff02ffff04ff09ffff04ff0bffff04ffff02ff0affff04ff02ffff04ff05ff80808080ff808080808080ff02ff0cffff04ff02ffff04ff0bffff04ffff0bffff0101ff0b80ffff04ffff02ff0affff04ff02ffff04ff05ff80808080ff808080808080ff018080
diff --git a/chia/wallet/puzzles/dao_finished_state.clsp.hex.sha256tree b/chia/wallet/puzzles/dao_finished_state.clsp.hex.sha256tree
new file mode 100644
index 000000000..ecf06a70d
--- /dev/null
+++ b/chia/wallet/puzzles/dao_finished_state.clsp.hex.sha256tree
@@ -0,0 +1 @@
+7f3cc356732907933a8f9b1ccf16f71735d07340eb38c847aa402e97d75eb40b
diff --git a/chia/wallet/puzzles/dao_lockup.clsp b/chia/wallet/puzzles/dao_lockup.clsp
new file mode 100644
index 000000000..e8d915395
--- /dev/null
+++ b/chia/wallet/puzzles/dao_lockup.clsp
@@ -0,0 +1,351 @@
+; This code is the "voting mode" for a DAO CAT.
+; The coin can be spent from this state to vote on a proposal or claim a dividend.
+; It locks the CAT in while it has active votes/dividends going on.
+; Once a vote or dividend closes, then the coin can spend itself to remove that coin from the "active list"
+; If the "active list" is empty the coin can leave the voting mode
+
+(mod (
+    PROPOSAL_MOD_HASH
+    SINGLETON_MOD_HASH
+    SINGLETON_LAUNCHER_PUZHASH
+    LOCKUP_MOD_HASH
+    CAT_MOD_HASH
+    CAT_TAIL_HASH
+    ACTIVE_VOTES  ; "active votes" list
+    INNERPUZ
+    my_id  ; if my_id is 0 we do the return to return_address (exit voting mode) spend case
+    inner_solution
+    my_amount
+    new_proposal_vote_id_or_removal_id  ; if we're exiting fully, set this to 0
+    proposal_curry_vals
+    vote_info
+    vote_amount
+    my_inner_puzhash
+    new_innerpuzhash  ; only include this if we're changing owners - secured because coin is still made from inner_puz
+  )
+  (include condition_codes.clib)
+  (include curry-and-treehash.clib)
+  (include *standard-cl-21*)
+
+  (defconstant dao_finished_state 0x7f3cc356732907933a8f9b1ccf16f71735d07340eb38c847aa402e97d75eb40b)
+
+  (defun calculate_finished_state (singleton_struct dao_finished_state)
+    (puzzle-hash-of-curried-function dao_finished_state
+      (sha256 ONE dao_finished_state)
+      (sha256tree singleton_struct)
+    )
+  )
+
+  ; take two lists and merge them into one
+  (defun merge_list (list_a list_b)
+    (if list_a
+        (c (f list_a) (merge_list (r list_a) list_b))
+        list_b
+    )
+  )
+
+  (defun wrap_in_cat_layer (CAT_MOD_HASH CAT_TAIL_HASH INNERPUZHASH)
+    (puzzle-hash-of-curried-function CAT_MOD_HASH
+      INNERPUZHASH
+      (sha256 ONE CAT_TAIL_HASH)
+      (sha256 ONE CAT_MOD_HASH)
+    )
+  )
+
+  ; loop through conditions and check that they aren't trying to create anything they shouldn't
+  (defun check_conditions (conditions vote_added_puzhash my_amount message vote_amount my_inner_puzhash seen_vote seen_change)
+    (if conditions
+        (if (= (f (f conditions)) CREATE_COIN)  ; this guarantees that the new coin is obeying the rules - other coins are banned to avoid re-voting
+            (if (= (f (r (f conditions))) vote_added_puzhash)
+                (if seen_vote  ; assert we haven't already made a coin with the new vote included
+                    (x)
+                    (if (= (f (r (r (f conditions)))) my_amount)  ; we vote with all our value
+                        (if seen_change  ; assert that we haven't already recreated ourself in some fashion
+                            (x)
+                            (c (f conditions) (check_conditions (r conditions) vote_added_puzhash my_amount message vote_amount my_inner_puzhash 1 1))
+                        )
+                        (if (= (f (r (r (f conditions)))) vote_amount)  ; we vote with part of our power
+                            (c (f conditions) (check_conditions (r conditions) vote_added_puzhash my_amount message vote_amount my_inner_puzhash 1 seen_change))
+                            (x)
+                        )
+                    )
+                )
+                (if (all
+                      (= (f (r (f conditions))) my_inner_puzhash)
+                      (not seen_change)
+                      (= (f (r (r (f conditions)))) (- my_amount vote_amount))
+                    )  ; we recreate ourselves with unused voting power
+                    (c (f conditions) (check_conditions (r conditions) vote_added_puzhash my_amount message vote_amount my_inner_puzhash seen_vote 1))
+                    (x)
+                )
+            )
+            (if (= (f (f conditions)) CREATE_PUZZLE_ANNOUNCEMENT)  ; this secures the values used to generate message - other messages are banned in case of LIES
+                (if (= (f (r (f conditions))) message)
+                    (c (f conditions) (check_conditions (r conditions) vote_added_puzhash my_amount message vote_amount my_inner_puzhash seen_vote seen_change))
+                    (x)
+                )
+                (c (f conditions) (check_conditions (r conditions) vote_added_puzhash my_amount message vote_amount my_inner_puzhash seen_vote seen_change))
+            )
+        )
+        (if (all seen_vote seen_change)  ; check all value is accounted for
+            ()
+            (x)
+        )
+    )
+  )
+
+  ; go through our list of active votes and check that we aren't revoting
+  (defun check_not_previously_voted (
+      SINGLETON_MOD_HASH
+      SINGLETON_LAUNCHER_PUZHASH
+      LOCKUP_MOD_HASH
+      CAT_MOD_HASH
+      CAT_TAIL_HASH
+      PROPOSAL_MOD_HASH
+      INNERPUZ
+      my_id
+      new_vote_id
+      active_votes
+      proposal_curry_vals
+    )
+    (if active_votes
+        (if (= new_vote_id (f active_votes))  ; check new vote id is not equal to an existent vote id
+            (x)
+            (check_not_previously_voted
+              SINGLETON_MOD_HASH
+              SINGLETON_LAUNCHER_PUZHASH
+              LOCKUP_MOD_HASH
+              CAT_MOD_HASH
+              CAT_TAIL_HASH
+              PROPOSAL_MOD_HASH
+              INNERPUZ
+              my_id
+              new_vote_id
+              (r active_votes)
+              proposal_curry_vals
+            )
+        )
+        (list ASSERT_PUZZLE_ANNOUNCEMENT (sha256  ; the problem might be here
+            (calculate_proposal_puzzlehash
+              PROPOSAL_MOD_HASH
+              CAT_MOD_HASH
+              LOCKUP_MOD_HASH
+              CAT_TAIL_HASH
+              (c SINGLETON_MOD_HASH (c new_vote_id SINGLETON_LAUNCHER_PUZHASH))
+              proposal_curry_vals
+            )
+            my_id
+          )
+        )
+    )
+  )
+
+
+  (defun calculate_singleton_puzzle_hash (PROPOSAL_SINGLETON_STRUCT inner_puzzle_hash)
+    (puzzle-hash-of-curried-function (f PROPOSAL_SINGLETON_STRUCT)
+      inner_puzzle_hash
+      (sha256tree PROPOSAL_SINGLETON_STRUCT)
+    )
+  )
+
+  (defun calculate_proposal_puzzlehash (
+      PROPOSAL_MOD_HASH
+      CAT_MOD_HASH
+      LOCKUP_MOD_HASH
+      CAT_TAIL_HASH
+      proposal_singleton_struct
+      (
+        TREASURY_MOD_HASH
+        PROPOSAL_TIMER_MOD_HASH
+        TREASURY_ID
+        YES_VOTES
+        TOTAL_VOTES
+        INNERPUZHASH
+      )
+    )
+    (calculate_singleton_puzzle_hash
+      proposal_singleton_struct
+      (puzzle-hash-of-curried-function PROPOSAL_MOD_HASH
+        (sha256 ONE INNERPUZHASH)
+        (sha256 ONE TOTAL_VOTES)
+        (sha256 ONE YES_VOTES)
+        (sha256 ONE TREASURY_ID)
+        (sha256 ONE CAT_TAIL_HASH)
+        (sha256 ONE LOCKUP_MOD_HASH)
+        (sha256 ONE TREASURY_MOD_HASH)
+        (sha256 ONE CAT_MOD_HASH)
+        (sha256 ONE PROPOSAL_TIMER_MOD_HASH)
+        (sha256 ONE PROPOSAL_MOD_HASH)
+        (sha256tree proposal_singleton_struct)
+      )
+    )
+  )
+
+  ; PROPOSAL_MOD_HASH
+  ; SINGLETON_MOD_HASH
+  ; SINGLETON_LAUNCHER_PUZHASH
+  ; LOCKUP_MOD_HASH
+  ; CAT_MOD_HASH
+  ; CAT_TAIL_HASH
+  ; ACTIVE_VOTES  ; "active votes" list
+  ; INNERPUZ
+  (defun calculate_lockup_puzzlehash (
+      PROPOSAL_MOD_HASH
+      SINGLETON_MOD_HASH
+      SINGLETON_LAUNCHER_PUZHASH
+      LOCKUP_MOD_HASH
+      CAT_MOD_HASH
+      CAT_TAIL_HASH
+      active_votes
+      innerpuzhash
+    )
+    (puzzle-hash-of-curried-function LOCKUP_MOD_HASH
+      innerpuzhash
+      (sha256tree active_votes)
+      (sha256 ONE CAT_TAIL_HASH)
+      (sha256 ONE CAT_MOD_HASH)
+      (sha256 ONE LOCKUP_MOD_HASH)
+      (sha256 ONE SINGLETON_LAUNCHER_PUZHASH)
+      (sha256 ONE SINGLETON_MOD_HASH)
+      (sha256 ONE PROPOSAL_MOD_HASH)
+    )
+  )
+
+  ; search for an announcement that a proposal is finished and then remove that proposal ID from ACTIVE_VOTES
+  (defun check_for_removal_announcement (
+      PROPOSAL_MOD_HASH
+      SINGLETON_MOD_HASH
+      SINGLETON_LAUNCHER_PUZHASH
+      LOCKUP_MOD_HASH
+      CAT_MOD_HASH
+      CAT_TAIL_HASH
+      ACTIVE_VOTES
+      INNERPUZ
+      removal_id
+      my_amount
+      proposal_curry_vals
+      unused_votes
+    )
+    (if ACTIVE_VOTES
+        (if (= (f ACTIVE_VOTES) removal_id)
+            (list
+              (list
+                CREATE_COIN  ; recreate self with the finished proposal ID removed
+                (calculate_lockup_puzzlehash
+                  PROPOSAL_MOD_HASH
+                  SINGLETON_MOD_HASH
+                  SINGLETON_LAUNCHER_PUZHASH
+                  LOCKUP_MOD_HASH
+                  CAT_MOD_HASH
+                  CAT_TAIL_HASH
+                  (merge_list unused_votes (r ACTIVE_VOTES))  ; removes the current entry from the list
+                  (sha256tree INNERPUZ)
+                )
+                my_amount
+              )
+              (list
+                ASSERT_PUZZLE_ANNOUNCEMENT  ; check proposal is actually finished
+                (sha256
+                  (calculate_singleton_puzzle_hash
+                    (c SINGLETON_MOD_HASH (c removal_id SINGLETON_LAUNCHER_PUZHASH))
+                    (calculate_finished_state
+                      (c SINGLETON_MOD_HASH (c removal_id SINGLETON_LAUNCHER_PUZHASH))
+                      dao_finished_state
+                    )
+                  )
+                  'f'
+                )
+              )
+              (list ASSERT_MY_AMOUNT my_amount)  ; assert that we aren't lying about our amount to free up money and re-vote
+            )
+
+            (check_for_removal_announcement  ; keep looping through ACTIVE_VOTES to search for removal_id
+              PROPOSAL_MOD_HASH
+              SINGLETON_MOD_HASH
+              SINGLETON_LAUNCHER_PUZHASH
+              LOCKUP_MOD_HASH
+              CAT_MOD_HASH
+              CAT_TAIL_HASH
+              (r ACTIVE_VOTES)
+              INNERPUZ
+              removal_id
+              my_amount
+              proposal_curry_vals
+              (c (f ACTIVE_VOTES) unused_votes)
+            )
+        )
+        (x)  ; proposal ID not found, invalid spend
+    )
+  )
+
+
+  ; main
+  (if my_id
+      (c (list ASSERT_MY_PUZZLEHASH (wrap_in_cat_layer CAT_MOD_HASH CAT_TAIL_HASH my_inner_puzhash))
+        (c
+          (list ASSERT_MY_AMOUNT my_amount)
+          (c
+            (list ASSERT_MY_COIN_ID my_id)
+            (c
+              (if new_proposal_vote_id_or_removal_id
+                  (check_not_previously_voted  ; this returns a single condition asserting announcement from vote singleton
+                    SINGLETON_MOD_HASH
+                    SINGLETON_LAUNCHER_PUZHASH
+                    LOCKUP_MOD_HASH
+                    CAT_MOD_HASH
+                    CAT_TAIL_HASH
+                    PROPOSAL_MOD_HASH
+                    INNERPUZ
+                    my_id
+                    new_proposal_vote_id_or_removal_id
+                    ACTIVE_VOTES
+                    proposal_curry_vals
+                  )
+                  (list REMARK)
+              )
+
+              (check_conditions  ; loop over conditions and check that we aren't trying to leave voting state
+                (a INNERPUZ inner_solution)
+                (calculate_lockup_puzzlehash  ; compare created coin to our own calculation on what the next puzzle should be
+                  PROPOSAL_MOD_HASH
+                  SINGLETON_MOD_HASH
+                  SINGLETON_LAUNCHER_PUZHASH
+                  LOCKUP_MOD_HASH
+                  CAT_MOD_HASH
+                  CAT_TAIL_HASH
+                  (c new_proposal_vote_id_or_removal_id ACTIVE_VOTES)
+                  (if new_innerpuzhash new_innerpuzhash (sha256tree INNERPUZ))
+                )
+                my_amount
+                ; TODO: add namespace to this announcement to allow announcements from the innerpuz
+                (sha256tree (list new_proposal_vote_id_or_removal_id vote_amount vote_info my_id))  ; (sha256tree (list (f (r SINGLETON_STRUCT)) (f vote_amount_list) vote_info (f coin_id_list)))
+                vote_amount
+                my_inner_puzhash
+                0
+                0
+              )
+            )
+          )
+        )
+      )
+
+      ; return to return_address or remove something from active list - check if our locked list is empty
+      (if ACTIVE_VOTES
+          (check_for_removal_announcement  ; locked list is not empty, so we must be trying to remove something from it
+            PROPOSAL_MOD_HASH
+            SINGLETON_MOD_HASH
+            SINGLETON_LAUNCHER_PUZHASH
+            LOCKUP_MOD_HASH
+            CAT_MOD_HASH
+            CAT_TAIL_HASH
+            ACTIVE_VOTES
+            INNERPUZ
+            new_proposal_vote_id_or_removal_id
+            my_amount
+            proposal_curry_vals
+            ()
+          )
+          (a INNERPUZ inner_solution)
+      )
+  )
+)
diff --git a/chia/wallet/puzzles/dao_lockup.clsp.hex b/chia/wallet/puzzles/dao_lockup.clsp.hex
new file mode 100644
index 000000000..530b09ca7
--- /dev/null
+++ b/chia/wallet/puzzles/dao_lockup.clsp.hex
@@ -0,0 +1 @@
+ff02ffff01ff02ffff03ff8205ffffff01ff02ffff01ff04ffff04ffff0148ffff04ffff02ff3cffff04ff02ffff04ff5fffff04ff8200bfffff04ff8302ffffff808080808080ffff01808080ffff04ffff04ffff0149ffff04ff8217ffffff01808080ffff04ffff04ffff0146ffff04ff8205ffffff01808080ffff04ffff02ffff03ff822fffffff01ff02ffff01ff02ff2affff04ff02ffff04ff0bffff04ff17ffff04ff2fffff04ff5fffff04ff8200bfffff04ff05ffff04ff8202ffffff04ff8205ffffff04ff822fffffff04ff82017fffff04ff825fffff8080808080808080808080808080ff0180ffff01ff02ffff01ff04ffff0101ffff018080ff018080ff0180ffff02ff12ffff04ff02ffff04ffff02ff8202ffff820bff80ffff04ffff02ff2effff04ff02ffff04ff05ffff04ff0bffff04ff17ffff04ff2fffff04ff5fffff04ff8200bfffff04ffff04ff822fffff82017f80ffff04ffff02ffff03ff8305ffffffff01ff02ffff018305ffffff0180ffff01ff02ffff01ff02ff38ffff04ff02ffff04ff8202ffff80808080ff018080ff0180ff8080808080808080808080ffff04ff8217ffffff04ffff02ff38ffff04ff02ffff04ffff04ff822fffffff04ff83017fffffff04ff8300bfffffff04ff8205ffffff018080808080ff80808080ffff04ff83017fffffff04ff8302ffffffff04ffff0180ffff04ffff0180ff808080808080808080808080808080ff0180ffff01ff02ffff01ff02ffff03ff82017fffff01ff02ffff01ff02ff3effff04ff02ffff04ff05ffff04ff0bffff04ff17ffff04ff2fffff04ff5fffff04ff8200bfffff04ff82017fffff04ff8202ffffff04ff822fffffff04ff8217ffffff04ff825fffffff04ffff0180ff808080808080808080808080808080ff0180ffff01ff02ffff01ff02ff8202ffff820bff80ff018080ff0180ff018080ff0180ffff04ffff01ffffffff02ffff03ff05ffff01ff02ffff01ff02ff10ffff04ff02ffff04ffff06ff0580ffff04ffff0bffff0102ffff0bffff0101ffff010480ffff0bffff0102ffff0bffff0102ffff0bffff0101ffff010180ffff05ff058080ffff0bffff0102ff0bffff0bffff0101ffff018080808080ff8080808080ff0180ffff01ff02ffff010bff018080ff0180ffff0bffff0102ffff01a0a12871fee210fb8619291eaea194581cbd2531e4b23759d225f6806923f63222ffff0bffff0102ffff0bffff0102ffff01a09dcf97a184f32623d11a73124ceb99a5709b083721e878a16d78f596718ba7b2ff0580ffff0bffff0102ffff02ff10ffff04ff02ffff04ff07ffff01ffa09dcf97a184f32623d11a73124ceb99a5709b083721e878a16d78f596718ba7b280808080ffff01a04bf5122f344554c53bde2ebb8cd2b7e3d1600ad631c385a5d7cce23c7785459a808080ff02ffff03ffff07ff0580ffff01ff02ffff01ff0bffff0102ffff02ff38ffff04ff02ffff04ffff05ff0580ff80808080ffff02ff38ffff04ff02ffff04ffff06ff0580ff8080808080ff0180ffff01ff02ffff01ff0bffff0101ff0580ff018080ff0180ffff02ff28ffff04ff02ffff04ff0bffff04ffff0bffff0101ff0b80ffff04ffff02ff38ffff04ff02ffff04ff05ff80808080ff808080808080ffff02ffff03ff05ffff01ff02ffff01ff04ffff05ff0580ffff02ff2cffff04ff02ffff04ffff06ff0580ffff04ff0bff808080808080ff0180ffff01ff02ffff010bff018080ff0180ff02ff28ffff04ff02ffff04ff05ffff04ff17ffff04ffff0bffff0101ff0b80ffff04ffff0bffff0101ff0580ff80808080808080ffffff02ffff03ff05ffff01ff02ffff01ff02ffff03ffff09ffff05ffff05ff058080ffff013380ffff01ff02ffff01ff02ffff03ffff09ffff05ffff06ffff05ff05808080ff0b80ffff01ff02ffff01ff02ffff03ff82017fffff01ff02ffff01ff0880ff0180ffff01ff02ffff01ff02ffff03ffff09ffff05ffff06ffff06ffff05ff0580808080ff1780ffff01ff02ffff01ff02ffff03ff8202ffffff01ff02ffff01ff0880ff0180ffff01ff02ffff01ff04ffff05ff0580ffff02ff12ffff04ff02ffff04ffff06ff0580ffff04ff0bffff04ff17ffff04ff2fffff04ff5fffff04ff8200bfffff04ffff0101ffff04ffff0101ff808080808080808080808080ff018080ff0180ff0180ffff01ff02ffff01ff02ffff03ffff09ffff05ffff06ffff06ffff05ff0580808080ff5f80ffff01ff02ffff01ff04ffff05ff0580ffff02ff12ffff04ff02ffff04ffff06ff0580ffff04ff0bffff04ff17ffff04ff2fffff04ff5fffff04ff8200bfffff04ffff0101ffff04ff8202ffff808080808080808080808080ff0180ffff01ff02ffff01ff0880ff018080ff0180ff018080ff0180ff018080ff0180ff0180ffff01ff02ffff01ff02ffff03ffff22ffff09ffff05ffff06ffff05ff05808080ff8200bf80ffff20ff8202ff80ffff09ffff05ffff06ffff06ffff05ff0580808080ffff11ff17ff5f808080ffff01ff02ffff01ff04ffff05ff0580ffff02ff12ffff04ff02ffff04ffff06ff0580ffff04ff0bffff04ff17ffff04ff2fffff04ff5fffff04ff8200bfffff04ff82017fffff04ffff0101ff808080808080808080808080ff0180ffff01ff02ffff01ff0880ff018080ff0180ff018080ff0180ff0180ffff01ff02ffff01ff02ffff03ffff09ffff05ffff05ff058080ffff013e80ffff01ff02ffff01ff02ffff03ffff09ffff05ffff06ffff05ff05808080ff2f80ffff01ff02ffff01ff04ffff05ff0580ffff02ff12ffff04ff02ffff04ffff06ff0580ffff04ff0bffff04ff17ffff04ff2fffff04ff5fffff04ff8200bfffff04ff82017fffff04ff8202ffff808080808080808080808080ff0180ffff01ff02ffff01ff0880ff018080ff0180ff0180ffff01ff02ffff01ff04ffff05ff0580ffff02ff12ffff04ff02ffff04ffff06ff0580ffff04ff0bffff04ff17ffff04ff2fffff04ff5fffff04ff8200bfffff04ff82017fffff04ff8202ffff808080808080808080808080ff018080ff0180ff018080ff0180ff0180ffff01ff02ffff01ff02ffff03ffff22ff82017fff8202ff80ffff01ff02ffff01ff0180ff0180ffff01ff02ffff01ff0880ff018080ff0180ff018080ff0180ffff02ffff03ff820bffffff01ff02ffff01ff02ffff03ffff09ff8205ffffff05ff820bff8080ffff01ff02ffff01ff0880ff0180ffff01ff02ffff01ff02ff2affff04ff02ffff04ff05ffff04ff0bffff04ff17ffff04ff2fffff04ff5fffff04ff8200bfffff04ff82017fffff04ff8202ffffff04ff8205ffffff04ffff06ff820bff80ffff04ff8217ffff8080808080808080808080808080ff018080ff0180ff0180ffff01ff02ffff01ff04ffff013fffff04ffff0bffff02ff16ffff04ff02ffff04ff8200bfffff04ff2fffff04ff17ffff04ff5fffff04ffff04ff05ffff04ff8205ffff0b8080ffff04ff8217ffff808080808080808080ff8202ff80ffff01808080ff018080ff0180ff02ff28ffff04ff02ffff04ff09ffff04ff0bffff04ffff02ff38ffff04ff02ffff04ff05ff80808080ff808080808080ffff02ff3affff04ff02ffff04ff5fffff04ffff02ff28ffff04ff02ffff04ff05ffff04ffff0bffff0101ff822fbf80ffff04ffff0bffff0101ff8217bf80ffff04ffff0bffff0101ff820bbf80ffff04ffff0bffff0101ff8205bf80ffff04ffff0bffff0101ff2f80ffff04ffff0bffff0101ff1780ffff04ffff0bffff0101ff82013f80ffff04ffff0bffff0101ff0b80ffff04ffff0bffff0101ff8202bf80ffff04ffff0bffff0101ff0580ffff04ffff02ff38ffff04ff02ffff04ff5fff80808080ff808080808080808080808080808080ff8080808080ffff02ff28ffff04ff02ffff04ff2fffff04ff8202ffffff04ffff02ff38ffff04ff02ffff04ff82017fff80808080ffff04ffff0bffff0101ff8200bf80ffff04ffff0bffff0101ff5f80ffff04ffff0bffff0101ff2f80ffff04ffff0bffff0101ff1780ffff04ffff0bffff0101ff0b80ffff04ffff0bffff0101ff0580ff808080808080808080808080ff02ffff03ff82017fffff01ff02ffff01ff02ffff03ffff09ffff05ff82017f80ff8205ff80ffff01ff02ffff01ff04ffff04ffff0133ffff04ffff02ff2effff04ff02ffff04ff05ffff04ff0bffff04ff17ffff04ff2fffff04ff5fffff04ff8200bfffff04ffff02ff2cffff04ff02ffff04ff822fffffff04ffff06ff82017f80ff8080808080ffff04ffff02ff38ffff04ff02ffff04ff8202ffff80808080ff8080808080808080808080ffff04ff820bffffff0180808080ffff04ffff04ffff013fffff04ffff0bffff02ff3affff04ff02ffff04ffff04ff0bffff04ff8205ffff178080ffff04ffff02ff14ffff04ff02ffff04ffff04ff0bffff04ff8205ffff178080ffff04ffff01a07f3cc356732907933a8f9b1ccf16f71735d07340eb38c847aa402e97d75eb40bff8080808080ff8080808080ffff016680ffff01808080ffff04ffff04ffff0149ffff04ff820bffffff01808080ffff0180808080ff0180ffff01ff02ffff01ff02ff3effff04ff02ffff04ff05ffff04ff0bffff04ff17ffff04ff2fffff04ff5fffff04ff8200bfffff04ffff06ff82017f80ffff04ff8202ffffff04ff8205ffffff04ff820bffffff04ff8217ffffff04ffff04ffff05ff82017f80ff822fff80ff808080808080808080808080808080ff018080ff0180ff0180ffff01ff02ffff01ff0880ff018080ff0180ff018080
diff --git a/chia/wallet/puzzles/dao_lockup.clsp.hex.sha256tree b/chia/wallet/puzzles/dao_lockup.clsp.hex.sha256tree
new file mode 100644
index 000000000..3932de2d5
--- /dev/null
+++ b/chia/wallet/puzzles/dao_lockup.clsp.hex.sha256tree
@@ -0,0 +1 @@
+9fa63e652e131f89a9f8bb6f7abb5ffc6ac485a78dcfb8710cd9df5c368774d9
diff --git a/chia/wallet/puzzles/dao_proposal.clsp b/chia/wallet/puzzles/dao_proposal.clsp
new file mode 100644
index 000000000..d2ee3f3d7
--- /dev/null
+++ b/chia/wallet/puzzles/dao_proposal.clsp
@@ -0,0 +1,407 @@
+(mod (
+    SINGLETON_STRUCT  ; (SINGLETON_MOD_HASH (SINGLETON_ID . LAUNCHER_PUZZLE_HASH))
+    PROPOSAL_MOD_HASH
+    PROPOSAL_TIMER_MOD_HASH  ; proposal timer needs to know which proposal created it, AND
+    CAT_MOD_HASH
+    TREASURY_MOD_HASH
+    LOCKUP_MOD_HASH
+    CAT_TAIL_HASH
+    TREASURY_ID
+    YES_VOTES  ; yes votes are +1, no votes don't tally - we compare yes_votes/total_votes at the end
+    TOTAL_VOTES  ; how many people responded
+    PROPOSED_PUZ_HASH  ; this is what runs if this proposal is successful - the inner puzzle of this proposal
+    vote_amounts_or_proposal_validator_hash  ; The qty of "votes" to add or subtract. ALWAYS POSITIVE.
+    vote_info  ; vote_info is whether we are voting YES or NO. XXX rename vote_type?
+    vote_coin_ids_or_proposal_timelock_length  ; this is either the coin ID we're taking a vote from
+    previous_votes_or_pass_margin  ; this is the active votes of the lockup we're communicating with
+    ; OR this is what percentage of the total votes must be YES - represented as an integer from 0 to 10,000 - typically this is set at 5100 (51%)
+    lockup_innerpuzhashes_or_attendance_required  ; this is either the innerpuz of the locked up CAT we're taking a vote from OR
+    ; the attendance required - the percentage of the current issuance which must have voted represented as 0 to 10,000 - this is announced by the treasury
+    innerpuz_reveal  ; this is only added during the first vote
+    soft_close_length  ; revealed by the treasury
+    self_destruct_time  ; revealed by the treasury
+    oracle_spend_delay  ; used to recreate the treasury
+    self_destruct_flag  ; if not 0, do the self-destruct spend
+    my_amount
+  )
+  (include condition_codes.clib)
+  (include utility_macros.clib)
+  (include curry-and-treehash.clib)
+  (include *standard-cl-21*)
+
+  (defconstant dao_finished_state 0x7f3cc356732907933a8f9b1ccf16f71735d07340eb38c847aa402e97d75eb40b)
+  (defconstant TEN_THOUSAND 10000)
+
+  (defun-inline calculate_win_percentage (TOTAL PERCENTAGE)
+    (f (divmod (* TOTAL PERCENTAGE) TEN_THOUSAND))
+  )
+
+  (defun calculate_finished_state (singleton_struct dao_finished_state)
+    (puzzle-hash-of-curried-function dao_finished_state
+      (sha256 ONE dao_finished_state)
+      (sha256tree singleton_struct)
+    )
+  )
+
+  (defun calculate_timer_puzhash (
+      PROPOSAL_MOD_HASH
+      PROPOSAL_TIMER_MOD_HASH
+      LOCKUP_MOD_HASH
+      CAT_MOD_HASH
+      CAT_TAIL_HASH
+      MY_SINGLETON_STRUCT
+      TREASURY_ID
+    )
+    (puzzle-hash-of-curried-function PROPOSAL_TIMER_MOD_HASH
+      (sha256 ONE TREASURY_ID)
+      (sha256tree MY_SINGLETON_STRUCT)
+      (sha256 ONE CAT_TAIL_HASH)
+      (sha256 ONE CAT_MOD_HASH)
+      (sha256 ONE LOCKUP_MOD_HASH)
+      (sha256 ONE PROPOSAL_TIMER_MOD_HASH)
+      (sha256 ONE PROPOSAL_MOD_HASH)
+    )
+  )
+
+  (defun calculate_lockup_puzzlehash (
+      PROPOSAL_MOD_HASH
+      SINGLETON_MOD_HASH
+      SINGLETON_LAUNCHER_PUZHASH
+      LOCKUP_MOD_HASH
+      CAT_MOD_HASH
+      CAT_TAIL_HASH
+      previous_votes
+      lockup_innerpuzhash
+    )
+    (puzzle-hash-of-curried-function LOCKUP_MOD_HASH
+      lockup_innerpuzhash
+      (sha256tree previous_votes)
+      (sha256 ONE CAT_TAIL_HASH)
+      (sha256 ONE CAT_MOD_HASH)
+      (sha256 ONE LOCKUP_MOD_HASH)
+      (sha256 ONE SINGLETON_LAUNCHER_PUZHASH)
+      (sha256 ONE SINGLETON_MOD_HASH)
+      (sha256 ONE PROPOSAL_MOD_HASH)
+    )
+  )
+
+  (defun recreate_self (
+      SINGLETON_STRUCT
+      PROPOSAL_MOD_HASH
+      PROPOSAL_TIMER_MOD_HASH
+      CAT_MOD_HASH
+      TREASURY_MOD_HASH
+      LOCKUP_MOD_HASH
+      CAT_TAIL_HASH
+      TREASURY_ID
+      YES_VOTES
+      TOTAL_VOTES
+      PROPOSED_PUZ_HASH
+    )
+    (puzzle-hash-of-curried-function PROPOSAL_MOD_HASH
+      (sha256 ONE PROPOSED_PUZ_HASH)
+      (sha256 ONE TOTAL_VOTES)
+      (sha256 ONE YES_VOTES)
+      (sha256 ONE TREASURY_ID)
+      (sha256 ONE CAT_TAIL_HASH)
+      (sha256 ONE LOCKUP_MOD_HASH)
+      (sha256 ONE TREASURY_MOD_HASH)
+      (sha256 ONE CAT_MOD_HASH)
+      (sha256 ONE PROPOSAL_TIMER_MOD_HASH)
+      (sha256 ONE PROPOSAL_MOD_HASH)
+      (sha256tree SINGLETON_STRUCT)
+    )
+  )
+
+  (defun wrap_in_cat_layer (CAT_MOD_HASH CAT_TAIL_HASH INNERPUZHASH)
+    (puzzle-hash-of-curried-function CAT_MOD_HASH
+      INNERPUZHASH
+      (sha256 ONE CAT_TAIL_HASH)
+      (sha256 ONE CAT_MOD_HASH)
+    )
+  )
+
+  (defun calculate_singleton_puzzle_hash (PROPOSAL_SINGLETON_STRUCT inner_puzzle_hash)
+    (puzzle-hash-of-curried-function (f PROPOSAL_SINGLETON_STRUCT)
+      inner_puzzle_hash
+      (sha256tree PROPOSAL_SINGLETON_STRUCT)
+    )
+  )
+
+  (defun calculate_treasury_puzzlehash (
+      treasury_singleton_struct
+      TREASURY_MOD_HASH
+      PROPOSAL_VALIDATOR_HASH
+      PROPOSAL_LENGTH
+      PROPOSAL_SOFTCLOSE_LENGTH
+      attendance_required
+      pass_percentage
+      self_destruct_time
+      oracle_spend_delay
+    )
+
+    (calculate_singleton_puzzle_hash treasury_singleton_struct
+      (puzzle-hash-of-curried-function TREASURY_MOD_HASH
+        (sha256 ONE oracle_spend_delay)
+        (sha256 ONE self_destruct_time)
+        (sha256 ONE pass_percentage)
+        (sha256 ONE attendance_required)
+        (sha256 ONE PROPOSAL_SOFTCLOSE_LENGTH)
+        (sha256 ONE PROPOSAL_LENGTH)
+        PROPOSAL_VALIDATOR_HASH
+        (sha256 ONE TREASURY_MOD_HASH)
+      )
+    )
+  )
+
+  (defun loop_over_vote_coins (
+      SINGLETON_STRUCT
+      CAT_MOD_HASH
+      CAT_TAIL_HASH
+      PROPOSAL_MOD_HASH
+      PROPOSAL_TIMER_MOD_HASH
+      TREASURY_MOD_HASH
+      LOCKUP_MOD_HASH
+      TREASURY_ID
+      YES_VOTES
+      TOTAL_VOTES
+      PROPOSED_PUZ_HASH
+      coin_id_list
+      vote_amount_list
+      previous_votes
+      lockup_innerpuzhashes
+      vote_info
+      sum
+      output
+      my_amount
+    )
+    (if coin_id_list
+        (c
+          (list CREATE_PUZZLE_ANNOUNCEMENT (f coin_id_list))
+          (c
+            (list
+              ASSERT_PUZZLE_ANNOUNCEMENT  ; take the vote
+              (sha256
+                (wrap_in_cat_layer
+                  CAT_MOD_HASH
+                  CAT_TAIL_HASH
+                  (calculate_lockup_puzzlehash  ; because the message comes from
+                    PROPOSAL_MOD_HASH
+                    (f SINGLETON_STRUCT)
+                    (r (r SINGLETON_STRUCT))
+                    LOCKUP_MOD_HASH
+                    CAT_MOD_HASH
+                    CAT_TAIL_HASH
+                    (f previous_votes)
+                    (f lockup_innerpuzhashes)
+                  )
+                )
+                (sha256tree (list (f (r SINGLETON_STRUCT)) (f vote_amount_list) vote_info (f coin_id_list)))
+              )
+            )
+            (loop_over_vote_coins
+              SINGLETON_STRUCT
+              CAT_MOD_HASH
+              CAT_TAIL_HASH
+              PROPOSAL_MOD_HASH
+              PROPOSAL_TIMER_MOD_HASH
+              TREASURY_MOD_HASH
+              LOCKUP_MOD_HASH
+              TREASURY_ID
+              YES_VOTES
+              TOTAL_VOTES
+              PROPOSED_PUZ_HASH
+              (r coin_id_list)
+              (r vote_amount_list)
+              (r previous_votes)
+              (r lockup_innerpuzhashes)
+              vote_info
+              (+ (f vote_amount_list) sum)
+              output
+              my_amount
+            )
+          )
+        )
+        (c
+          (list
+            CREATE_COIN  ; recreate self with vote information added
+            (recreate_self
+              SINGLETON_STRUCT
+              PROPOSAL_MOD_HASH
+              PROPOSAL_TIMER_MOD_HASH
+              CAT_MOD_HASH
+              TREASURY_MOD_HASH
+              LOCKUP_MOD_HASH
+              CAT_TAIL_HASH
+              TREASURY_ID
+              (if vote_info (+ YES_VOTES sum) YES_VOTES)
+              (+ TOTAL_VOTES sum)
+              PROPOSED_PUZ_HASH
+            )
+            my_amount
+            (list TREASURY_ID)  ; hint to Treasury ID so people can find it
+          )
+          (c
+            (list ASSERT_MY_AMOUNT my_amount)
+            output
+          )
+        )
+    )
+
+  )
+
+
+  (if self_destruct_flag
+      ; assert self_destruct_time > proposal_timelock_length
+      ; this is the code path for if we've not been accepted by the treasury for a long time, and we're "bad" for some reason
+      (assert (> self_destruct_time vote_coin_ids_or_proposal_timelock_length)
+        (list
+          (list CREATE_COIN (calculate_finished_state SINGLETON_STRUCT dao_finished_state) ONE (list TREASURY_ID))
+          (list ASSERT_HEIGHT_RELATIVE self_destruct_time)
+          (list ASSERT_PUZZLE_ANNOUNCEMENT  ; make sure that we have a matching treasury oracle spend
+            (sha256
+              (calculate_treasury_puzzlehash
+                (c (f SINGLETON_STRUCT) (c TREASURY_ID (r (r SINGLETON_STRUCT))))
+                TREASURY_MOD_HASH
+                vote_amounts_or_proposal_validator_hash
+                vote_coin_ids_or_proposal_timelock_length  ; check the veracity of these values by if the treasury uses them
+                soft_close_length
+                lockup_innerpuzhashes_or_attendance_required
+                previous_votes_or_pass_margin
+                self_destruct_time
+                oracle_spend_delay
+              )
+              0  ; the arguments are secured implicitly in the puzzle of the treasury
+            )
+          )
+        )
+      )
+      ; We're not trying to self destruct
+      ; Check whether we have a soft close to either try closing the proposal or adding votes
+      ; soft_close_length is used to prevent people from spamming the proposal and preventing others from being able to vote.
+      ; Someone could add 1 'no' vote to the proposal in every block until the proposal timelock has passed and then close the proposal as failed.
+      ; soft_close_length imposes some fixed number of blocks have passed without the proposal being spent before it can be closed.
+      ; This means there will always be some time for people to vote if they want before a proposal is closed.
+      (if soft_close_length
+          ; Add the conditions which apply in both passed and failed cases
+          (c
+            (list ASSERT_HEIGHT_RELATIVE soft_close_length)
+            (c
+              (list CREATE_COIN (calculate_finished_state SINGLETON_STRUCT dao_finished_state) ONE (list TREASURY_ID))
+              (c
+                (list
+                  ASSERT_PUZZLE_ANNOUNCEMENT
+                  (sha256  ; external timer
+                    (calculate_timer_puzhash
+                      PROPOSAL_MOD_HASH
+                      PROPOSAL_TIMER_MOD_HASH
+                      LOCKUP_MOD_HASH
+                      CAT_MOD_HASH
+                      CAT_TAIL_HASH
+                      SINGLETON_STRUCT
+                      TREASURY_ID
+                    )
+                    (f (r SINGLETON_STRUCT))
+                  )
+                )
+                (c
+                  (list CREATE_PUZZLE_ANNOUNCEMENT vote_coin_ids_or_proposal_timelock_length)
+                  ; We are trying to close the proposal, so check whether it passed or failed
+                  (if
+                    (all
+                      (> TOTAL_VOTES lockup_innerpuzhashes_or_attendance_required)
+                      (> YES_VOTES (calculate_win_percentage TOTAL_VOTES previous_votes_or_pass_margin))
+                    )
+                    ; Passed
+                    (list
+                      (list CREATE_COIN_ANNOUNCEMENT (sha256tree (list PROPOSED_PUZ_HASH 0)))  ; the 0 at the end is announcement_args in proposal_validators
+                      ; the above coin annnouncement lets us validate this coin in the proposal validator
+                      (list ASSERT_PUZZLE_ANNOUNCEMENT  ; make sure that we actually have a matching treasury spend
+                        (sha256
+                          (calculate_treasury_puzzlehash
+                            (c (f SINGLETON_STRUCT) (c TREASURY_ID (r (r SINGLETON_STRUCT))))
+                            TREASURY_MOD_HASH
+                            vote_amounts_or_proposal_validator_hash
+                            vote_coin_ids_or_proposal_timelock_length  ; check the veracity of these values by if the treasury uses them
+                            soft_close_length
+                            lockup_innerpuzhashes_or_attendance_required
+                            previous_votes_or_pass_margin
+                            self_destruct_time
+                            oracle_spend_delay
+                          )
+                          (f (r SINGLETON_STRUCT))  ; directed at singleton, but most values are implicitly announced in the puzzle
+                        )
+                      )
+                    )
+                    ; Failed
+                    (list
+                      (list ASSERT_PUZZLE_ANNOUNCEMENT  ; make sure that we verify solution values against the treasury's oracle spend
+                        (sha256
+                          (calculate_treasury_puzzlehash
+                            (c (f SINGLETON_STRUCT) (c TREASURY_ID (r (r SINGLETON_STRUCT))))
+                            TREASURY_MOD_HASH
+                            vote_amounts_or_proposal_validator_hash
+                            vote_coin_ids_or_proposal_timelock_length  ; check the veracity of these values by if the treasury uses them
+                            soft_close_length
+                            lockup_innerpuzhashes_or_attendance_required
+                            previous_votes_or_pass_margin
+                            self_destruct_time
+                            oracle_spend_delay
+                          )
+                          0  ; the arguments are secured implicitly in the puzzle of the treasury
+                        )
+                      )
+                    )
+                  )
+                )
+              )
+            )
+          )
+
+
+          ; no soft_close_length so run the add votes path
+          (loop_over_vote_coins
+            SINGLETON_STRUCT
+            CAT_MOD_HASH
+            CAT_TAIL_HASH
+            PROPOSAL_MOD_HASH
+            PROPOSAL_TIMER_MOD_HASH
+            TREASURY_MOD_HASH
+            LOCKUP_MOD_HASH
+            TREASURY_ID
+            YES_VOTES
+            TOTAL_VOTES
+            PROPOSED_PUZ_HASH
+            vote_coin_ids_or_proposal_timelock_length
+            vote_amounts_or_proposal_validator_hash
+            previous_votes_or_pass_margin
+            lockup_innerpuzhashes_or_attendance_required
+            vote_info
+            0
+            (if (any YES_VOTES TOTAL_VOTES)  ; this prevents the timer from being created if the coin has been created with fake votes
+                ()
+                (c
+                  (list
+                    CREATE_COIN
+                    (calculate_timer_puzhash
+                      PROPOSAL_MOD_HASH
+                      PROPOSAL_TIMER_MOD_HASH
+                      LOCKUP_MOD_HASH
+                      CAT_MOD_HASH
+                      CAT_TAIL_HASH
+                      SINGLETON_STRUCT
+                      TREASURY_ID
+                    )
+                    0
+                  )
+                  (if (= (sha256tree innerpuz_reveal) PROPOSED_PUZ_HASH)  ; reveal the proposed code on chain with the first vote
+                      ()
+                      (x)
+                  )
+                )
+            )
+            my_amount
+          )
+      )
+  )
+)
diff --git a/chia/wallet/puzzles/dao_proposal.clsp.hex b/chia/wallet/puzzles/dao_proposal.clsp.hex
new file mode 100644
index 000000000..b6dbfc72f
--- /dev/null
+++ b/chia/wallet/puzzles/dao_proposal.clsp.hex
@@ -0,0 +1 @@
+ff02ffff01ff02ffff03ff835fffffffff01ff02ffff01ff02ffff03ffff15ff8317ffffff8300bfff80ffff01ff02ffff01ff04ffff04ffff0133ffff04ffff02ff2cffff04ff02ffff04ff05ffff04ffff01a07f3cc356732907933a8f9b1ccf16f71735d07340eb38c847aa402e97d75eb40bff8080808080ffff04ffff0101ffff04ffff04ff8202ffffff018080ffff018080808080ffff04ffff04ffff0152ffff04ff8317ffffffff01808080ffff04ffff04ffff013fffff04ffff0bffff02ff2effff04ff02ffff04ffff04ffff05ff0580ffff04ff8202ffffff06ffff06ff0580808080ffff04ff5fffff04ff822fffffff04ff8300bfffffff04ff830bffffffff04ff8302ffffffff04ff83017fffffff04ff8317ffffffff04ff832fffffff808080808080808080808080ffff018080ffff01808080ffff0180808080ff0180ffff01ff02ffff01ff0880ff018080ff0180ff0180ffff01ff02ffff01ff02ffff03ff830bffffffff01ff02ffff01ff04ffff04ffff0152ffff04ff830bffffffff01808080ffff04ffff04ffff0133ffff04ffff02ff2cffff04ff02ffff04ff05ffff04ffff01a07f3cc356732907933a8f9b1ccf16f71735d07340eb38c847aa402e97d75eb40bff8080808080ffff04ffff0101ffff04ffff04ff8202ffffff018080ffff018080808080ffff04ffff04ffff013fffff04ffff0bffff02ff3cffff04ff02ffff04ff0bffff04ff17ffff04ff8200bfffff04ff2fffff04ff82017fffff04ff05ffff04ff8202ffff80808080808080808080ffff05ffff06ff05808080ffff01808080ffff04ffff04ffff013effff04ff8300bfffffff01808080ffff02ffff03ffff22ffff15ff820bffff8302ffff80ffff15ff8205ffffff05ffff14ffff12ff820bffff83017fff80ffff0182271080808080ffff01ff02ffff01ff04ffff04ffff013cffff04ffff02ff14ffff04ff02ffff04ffff04ff8217ffffff04ffff0180ffff01808080ff80808080ffff01808080ffff04ffff04ffff013fffff04ffff0bffff02ff2effff04ff02ffff04ffff04ffff05ff0580ffff04ff8202ffffff06ffff06ff0580808080ffff04ff5fffff04ff822fffffff04ff8300bfffffff04ff830bffffffff04ff8302ffffffff04ff83017fffffff04ff8317ffffffff04ff832fffffff808080808080808080808080ffff05ffff06ff05808080ffff01808080ffff01808080ff0180ffff01ff02ffff01ff04ffff04ffff013fffff04ffff0bffff02ff2effff04ff02ffff04ffff04ffff05ff0580ffff04ff8202ffffff06ffff06ff0580808080ffff04ff5fffff04ff822fffffff04ff8300bfffffff04ff830bffffffff04ff8302ffffffff04ff83017fffffff04ff8317ffffffff04ff832fffffff808080808080808080808080ffff018080ffff01808080ffff018080ff018080ff018080808080ff0180ffff01ff02ffff01ff02ff3effff04ff02ffff04ff05ffff04ff2fffff04ff82017fffff04ff0bffff04ff17ffff04ff5fffff04ff8200bfffff04ff8202ffffff04ff8205ffffff04ff820bffffff04ff8217ffffff04ff8300bfffffff04ff822fffffff04ff83017fffffff04ff8302ffffffff04ff825fffffff04ffff0180ffff04ffff02ffff03ffff21ff8205ffff820bff80ffff01ff02ffff01ff0180ff0180ffff01ff02ffff01ff04ffff04ffff0133ffff04ffff02ff3cffff04ff02ffff04ff0bffff04ff17ffff04ff8200bfffff04ff2fffff04ff82017fffff04ff05ffff04ff8202ffff80808080808080808080ffff04ffff0180ffff0180808080ffff02ffff03ffff09ffff02ff14ffff04ff02ffff04ff8305ffffff80808080ff8217ff80ffff01ff02ffff01ff0180ff0180ffff01ff02ffff01ff0880ff018080ff018080ff018080ff0180ffff04ff8400bfffffff80808080808080808080808080808080808080808080ff018080ff0180ff018080ff0180ffff04ffff01ffffffff02ffff03ff05ffff01ff02ffff01ff02ff10ffff04ff02ffff04ffff06ff0580ffff04ffff0bffff0102ffff0bffff0101ffff010480ffff0bffff0102ffff0bffff0102ffff0bffff0101ffff010180ffff05ff058080ffff0bffff0102ff0bffff0bffff0101ffff018080808080ff8080808080ff0180ffff01ff02ffff010bff018080ff0180ff0bffff0102ffff01a0a12871fee210fb8619291eaea194581cbd2531e4b23759d225f6806923f63222ffff0bffff0102ffff0bffff0102ffff01a09dcf97a184f32623d11a73124ceb99a5709b083721e878a16d78f596718ba7b2ff0580ffff0bffff0102ffff02ff10ffff04ff02ffff04ff07ffff01ffa09dcf97a184f32623d11a73124ceb99a5709b083721e878a16d78f596718ba7b280808080ffff01a04bf5122f344554c53bde2ebb8cd2b7e3d1600ad631c385a5d7cce23c7785459a808080ffff02ffff03ffff07ff0580ffff01ff02ffff01ff0bffff0102ffff02ff14ffff04ff02ffff04ffff05ff0580ff80808080ffff02ff14ffff04ff02ffff04ffff06ff0580ff8080808080ff0180ffff01ff02ffff01ff0bffff0101ff0580ff018080ff0180ffff02ff18ffff04ff02ffff04ff0bffff04ffff0bffff0101ff0b80ffff04ffff02ff14ffff04ff02ffff04ff05ff80808080ff808080808080ff02ff18ffff04ff02ffff04ff0bffff04ffff0bffff0101ff82017f80ffff04ffff02ff14ffff04ff02ffff04ff8200bfff80808080ffff04ffff0bffff0101ff5f80ffff04ffff0bffff0101ff2f80ffff04ffff0bffff0101ff1780ffff04ffff0bffff0101ff0b80ffff04ffff0bffff0101ff0580ff8080808080808080808080ffffff02ff18ffff04ff02ffff04ff2fffff04ff8202ffffff04ffff02ff14ffff04ff02ffff04ff82017fff80808080ffff04ffff0bffff0101ff8200bf80ffff04ffff0bffff0101ff5f80ffff04ffff0bffff0101ff2f80ffff04ffff0bffff0101ff1780ffff04ffff0bffff0101ff0b80ffff04ffff0bffff0101ff0580ff808080808080808080808080ffff02ff18ffff04ff02ffff04ff0bffff04ffff0bffff0101ff8217ff80ffff04ffff0bffff0101ff820bff80ffff04ffff0bffff0101ff8205ff80ffff04ffff0bffff0101ff8202ff80ffff04ffff0bffff0101ff82017f80ffff04ffff0bffff0101ff8200bf80ffff04ffff0bffff0101ff5f80ffff04ffff0bffff0101ff2f80ffff04ffff0bffff0101ff1780ffff04ffff0bffff0101ff0b80ffff04ffff02ff14ffff04ff02ffff04ff05ff80808080ff808080808080808080808080808080ff02ff18ffff04ff02ffff04ff05ffff04ff17ffff04ffff0bffff0101ff0b80ffff04ffff0bffff0101ff0580ff80808080808080ffff02ff18ffff04ff02ffff04ff09ffff04ff0bffff04ffff02ff14ffff04ff02ffff04ff05ff80808080ff808080808080ffff02ff16ffff04ff02ffff04ff05ffff04ffff02ff18ffff04ff02ffff04ff0bffff04ffff0bffff0101ff8205ff80ffff04ffff0bffff0101ff8202ff80ffff04ffff0bffff0101ff82017f80ffff04ffff0bffff0101ff8200bf80ffff04ffff0bffff0101ff5f80ffff04ffff0bffff0101ff2f80ffff04ff17ffff04ffff0bffff0101ff0b80ff808080808080808080808080ff8080808080ff02ffff03ff822fffffff01ff02ffff01ff04ffff04ffff013effff04ffff05ff822fff80ffff01808080ffff04ffff04ffff013fffff04ffff0bffff02ff3affff04ff02ffff04ff0bffff04ff17ffff04ffff02ff12ffff04ff02ffff04ff2fffff04ffff05ff0580ffff04ffff06ffff06ff058080ffff04ff82017fffff04ff0bffff04ff17ffff04ffff05ff8300bfff80ffff04ffff05ff83017fff80ff8080808080808080808080ff808080808080ffff02ff14ffff04ff02ffff04ffff04ffff05ffff06ff058080ffff04ffff05ff825fff80ffff04ff8302ffffffff04ffff05ff822fff80ffff018080808080ff8080808080ffff01808080ffff02ff3effff04ff02ffff04ff05ffff04ff0bffff04ff17ffff04ff2fffff04ff5fffff04ff8200bfffff04ff82017fffff04ff8202ffffff04ff8205ffffff04ff820bffffff04ff8217ffffff04ffff06ff822fff80ffff04ffff06ff825fff80ffff04ffff06ff8300bfff80ffff04ffff06ff83017fff80ffff04ff8302ffffffff04ffff10ffff05ff825fff80ff8305ffff80ffff04ff830bffffffff04ff8317ffffff808080808080808080808080808080808080808080808080ff0180ffff01ff02ffff01ff04ffff04ffff0133ffff04ffff02ff2affff04ff02ffff04ff05ffff04ff2fffff04ff5fffff04ff0bffff04ff8200bfffff04ff82017fffff04ff17ffff04ff8202ffffff04ffff02ffff03ff8302ffffffff01ff02ffff01ff10ff8205ffff8305ffff80ff0180ffff01ff02ffff018205ffff018080ff0180ffff04ffff10ff820bffff8305ffff80ffff04ff8217ffff8080808080808080808080808080ffff04ff8317ffffffff04ffff04ff8202ffffff018080ffff018080808080ffff04ffff04ffff0149ffff04ff8317ffffffff01808080ff830bffff8080ff018080ff0180ff018080
diff --git a/chia/wallet/puzzles/dao_proposal.clsp.hex.sha256tree b/chia/wallet/puzzles/dao_proposal.clsp.hex.sha256tree
new file mode 100644
index 000000000..45c30b689
--- /dev/null
+++ b/chia/wallet/puzzles/dao_proposal.clsp.hex.sha256tree
@@ -0,0 +1 @@
+a27440cdee44f910e80225592e51dc03721a9d819cc358165587fa2b34eef4cd
diff --git a/chia/wallet/puzzles/dao_proposal_timer.clsp b/chia/wallet/puzzles/dao_proposal_timer.clsp
new file mode 100644
index 000000000..c899cceb5
--- /dev/null
+++ b/chia/wallet/puzzles/dao_proposal_timer.clsp
@@ -0,0 +1,119 @@
+; This is a persistent timer for a proposal which allows it to have a relative time that survives despite it being recreated.
+; The closing time is contained in the timelock and passed in to the solution, and confirmed via an announcement from the Proposal
+; It creates/asserts announcements to pair it with the finishing spend of a proposal
+
+(mod (
+    PROPOSAL_MOD_HASH
+    PROPOSAL_TIMER_MOD_HASH
+    LOCKUP_MOD_HASH
+    CAT_MOD_HASH
+    CAT_TAIL_HASH
+    (@ MY_PARENT_SINGLETON_STRUCT (SINGLETON_MOD_HASH SINGLETON_ID . LAUNCHER_PUZZLE_HASH))
+    TREASURY_ID
+    treasury_mod_hash
+    proposal_yes_votes
+    proposal_total_votes
+    proposal_innerpuzhash
+    proposal_timelock
+    parent_parent
+    parent_amount
+  )
+  (include condition_codes.clib)
+  (include curry-and-treehash.clib)
+  (include *standard-cl-21*)
+
+  (defun calculate_singleton_puzzle_hash (PROPOSAL_SINGLETON_STRUCT inner_puzzle_hash)
+    (puzzle-hash-of-curried-function (f PROPOSAL_SINGLETON_STRUCT)
+      inner_puzzle_hash
+      (sha256tree PROPOSAL_SINGLETON_STRUCT)
+    )
+  )
+
+  ; PROPOSAL_MOD_HASH
+  ; CAT_MOD_HASH
+  ; LOCKUP_MOD_HASH
+  ; CAT_TAIL_HASH
+  ; MY_PARENT_SINGLETON_STRUCT
+  ; treasury_mod_hash
+  ; PROPOSAL_TIMER_MOD_HASH
+  ; TREASURY_ID
+  ; proposal_yes_votes
+  ; proposal_total_votes
+  ; proposal_innerpuzhash
+  (defun calculate_proposal_puzzlehash (
+      PROPOSAL_MOD_HASH
+      CAT_MOD_HASH
+      LOCKUP_MOD_HASH
+      CAT_TAIL_HASH
+      proposal_singleton_struct
+      TREASURY_MOD_HASH
+      PROPOSAL_TIMER_MOD_HASH
+      TREASURY_ID
+      YES_VOTES
+      TOTAL_VOTES
+      INNERPUZHASH
+    )
+    (calculate_singleton_puzzle_hash
+      proposal_singleton_struct
+      (puzzle-hash-of-curried-function PROPOSAL_MOD_HASH
+        (sha256 ONE INNERPUZHASH)
+        (sha256 ONE TOTAL_VOTES)
+        (sha256 ONE YES_VOTES)
+        (sha256 ONE TREASURY_ID)
+        (sha256 ONE CAT_TAIL_HASH)
+        (sha256 ONE LOCKUP_MOD_HASH)
+        (sha256 ONE TREASURY_MOD_HASH)
+        (sha256 ONE CAT_MOD_HASH)
+        (sha256 ONE PROPOSAL_TIMER_MOD_HASH)
+        (sha256 ONE PROPOSAL_MOD_HASH)
+        (sha256tree proposal_singleton_struct)
+      )
+    )
+  )
+
+  ; main
+  (list
+    (list ASSERT_HEIGHT_RELATIVE proposal_timelock)
+    (list CREATE_PUZZLE_ANNOUNCEMENT (f (r MY_PARENT_SINGLETON_STRUCT)))
+    (list
+      ASSERT_PUZZLE_ANNOUNCEMENT
+      (sha256
+        (calculate_proposal_puzzlehash
+          PROPOSAL_MOD_HASH
+          CAT_MOD_HASH
+          LOCKUP_MOD_HASH
+          CAT_TAIL_HASH
+          MY_PARENT_SINGLETON_STRUCT
+          treasury_mod_hash
+          PROPOSAL_TIMER_MOD_HASH
+          TREASURY_ID
+          proposal_yes_votes
+          proposal_total_votes
+          proposal_innerpuzhash
+        )
+        proposal_timelock
+      )
+    )
+    (list
+      ASSERT_MY_PARENT_ID
+      (sha256
+        parent_parent
+        (calculate_proposal_puzzlehash
+          PROPOSAL_MOD_HASH
+          CAT_MOD_HASH
+          LOCKUP_MOD_HASH
+          CAT_TAIL_HASH
+          MY_PARENT_SINGLETON_STRUCT
+          treasury_mod_hash
+          PROPOSAL_TIMER_MOD_HASH
+          TREASURY_ID
+          0
+          0
+          proposal_innerpuzhash
+        )
+        parent_amount
+      )
+
+    )
+  )
+)
diff --git a/chia/wallet/puzzles/dao_proposal_timer.clsp.hex b/chia/wallet/puzzles/dao_proposal_timer.clsp.hex
new file mode 100644
index 000000000..168174cdb
--- /dev/null
+++ b/chia/wallet/puzzles/dao_proposal_timer.clsp.hex
@@ -0,0 +1 @@
+ff02ffff01ff04ffff04ffff0152ffff04ff822fffffff01808080ffff04ffff04ffff013effff04ffff05ffff06ff8200bf8080ffff01808080ffff04ffff04ffff013fffff04ffff0bffff02ff1effff04ff02ffff04ff05ffff04ff2fffff04ff17ffff04ff5fffff04ff8200bfffff04ff8202ffffff04ff0bffff04ff82017fffff04ff8205ffffff04ff820bffffff04ff8217ffff8080808080808080808080808080ff822fff80ffff01808080ffff04ffff04ffff0147ffff04ffff0bff825fffffff02ff1effff04ff02ffff04ff05ffff04ff2fffff04ff17ffff04ff5fffff04ff8200bfffff04ff8202ffffff04ff0bffff04ff82017fffff04ffff0180ffff04ffff0180ffff04ff8217ffff8080808080808080808080808080ff8300bfff80ffff01808080ffff018080808080ffff04ffff01ffffff02ffff03ff05ffff01ff02ffff01ff02ff08ffff04ff02ffff04ffff06ff0580ffff04ffff0bffff0102ffff0bffff0101ffff010480ffff0bffff0102ffff0bffff0102ffff0bffff0101ffff010180ffff05ff058080ffff0bffff0102ff0bffff0bffff0101ffff018080808080ff8080808080ff0180ffff01ff02ffff010bff018080ff0180ff0bffff0102ffff01a0a12871fee210fb8619291eaea194581cbd2531e4b23759d225f6806923f63222ffff0bffff0102ffff0bffff0102ffff01a09dcf97a184f32623d11a73124ceb99a5709b083721e878a16d78f596718ba7b2ff0580ffff0bffff0102ffff02ff08ffff04ff02ffff04ff07ffff01ffa09dcf97a184f32623d11a73124ceb99a5709b083721e878a16d78f596718ba7b280808080ffff01a04bf5122f344554c53bde2ebb8cd2b7e3d1600ad631c385a5d7cce23c7785459a808080ffff02ffff03ffff07ff0580ffff01ff02ffff01ff0bffff0102ffff02ff0affff04ff02ffff04ffff05ff0580ff80808080ffff02ff0affff04ff02ffff04ffff06ff0580ff8080808080ff0180ffff01ff02ffff01ff0bffff0101ff0580ff018080ff0180ffff02ff0cffff04ff02ffff04ff09ffff04ff0bffff04ffff02ff0affff04ff02ffff04ff05ff80808080ff808080808080ff02ff16ffff04ff02ffff04ff5fffff04ffff02ff0cffff04ff02ffff04ff05ffff04ffff0bffff0101ff8217ff80ffff04ffff0bffff0101ff820bff80ffff04ffff0bffff0101ff8205ff80ffff04ffff0bffff0101ff8202ff80ffff04ffff0bffff0101ff2f80ffff04ffff0bffff0101ff1780ffff04ffff0bffff0101ff8200bf80ffff04ffff0bffff0101ff0b80ffff04ffff0bffff0101ff82017f80ffff04ffff0bffff0101ff0580ffff04ffff02ff0affff04ff02ffff04ff5fff80808080ff808080808080808080808080808080ff8080808080ff018080
diff --git a/chia/wallet/puzzles/dao_proposal_timer.clsp.hex.sha256tree b/chia/wallet/puzzles/dao_proposal_timer.clsp.hex.sha256tree
new file mode 100644
index 000000000..c642bef7f
--- /dev/null
+++ b/chia/wallet/puzzles/dao_proposal_timer.clsp.hex.sha256tree
@@ -0,0 +1 @@
+5526d8dc33b60a23c86ac7184e8f7051515af16dbb7489555f389b84a5313c84
diff --git a/chia/wallet/puzzles/dao_proposal_validator.clsp b/chia/wallet/puzzles/dao_proposal_validator.clsp
new file mode 100644
index 000000000..163699691
--- /dev/null
+++ b/chia/wallet/puzzles/dao_proposal_validator.clsp
@@ -0,0 +1,100 @@
+(mod
+  (
+    SINGLETON_STRUCT  ; (SINGLETON_MOD_HASH (SINGLETON_ID . LAUNCHER_PUZZLE_HASH))
+    PROPOSAL_MOD_HASH
+    PROPOSAL_TIMER_MOD_HASH
+    CAT_MOD_HASH
+    LOCKUP_MOD_HASH
+    TREASURY_MOD_HASH
+    CAT_TAIL_HASH
+    PROPOSAL_MINIMUM_AMOUNT
+    PROPOSAL_EXCESS_PAYOUT_PUZ_HASH  ; this is where the excess money gets paid out to
+    Attendance_Required  ; this is passed in as a Truth from above
+    Pass_Margin  ; this is a pass in as a Truth from above
+    (announcement_source delegated_puzzle_hash announcement_args)
+    (  ; this is the proposal_vaidator solution
+      proposal_id
+      total_votes
+      yes_votes
+      coin_parent
+      coin_amount
+    )
+    conditions
+  )
+
+  (include condition_codes.clib)
+  (include curry-and-treehash.clib)
+  (include utility_macros.clib)
+
+  (defconstant TEN_THOUSAND 10000)
+
+  (defun-inline calculate_win_percentage (TOTAL PERCENTAGE)
+    (f (divmod (* TOTAL PERCENTAGE) TEN_THOUSAND))
+  )
+
+  (defun-inline calculate_full_puzzle_hash (SINGLETON_STRUCT inner_puzzle_hash)
+    (puzzle-hash-of-curried-function (f SINGLETON_STRUCT)
+      inner_puzzle_hash
+      (sha256tree SINGLETON_STRUCT)
+    )
+  )
+
+  (defun-inline calculate_proposal_puzzle (
+      PROPOSAL_MOD_HASH
+      PROPOSAL_SINGLETON_STRUCT
+      PROPOSAL_TIMER_MOD_HASH
+      CAT_MOD_HASH
+      TREASURY_MOD_HASH
+      LOCKUP_MOD_HASH
+      CAT_TAIL_HASH
+      TREASURY_ID
+      proposal_yes_votes
+      proposal_total_votes
+      proposal_innerpuz_hash
+    )
+    (puzzle-hash-of-curried-function PROPOSAL_MOD_HASH
+      (sha256 ONE proposal_innerpuz_hash)
+      (sha256 ONE proposal_total_votes)
+      (sha256 ONE proposal_yes_votes)
+      (sha256 ONE TREASURY_ID)
+      (sha256 ONE CAT_TAIL_HASH)
+      (sha256 ONE LOCKUP_MOD_HASH)
+      (sha256 ONE TREASURY_MOD_HASH)
+      (sha256 ONE CAT_MOD_HASH)
+      (sha256 ONE PROPOSAL_TIMER_MOD_HASH)
+      (sha256 ONE PROPOSAL_MOD_HASH)
+      (sha256tree PROPOSAL_SINGLETON_STRUCT)
+    )
+  )
+
+  (assert
+    ; (= (sha256tree my_solution) announcement_args) - quex suggested this. We don't need to check it now. Can be used for future functionality.
+    (> (+ coin_amount ONE) PROPOSAL_MINIMUM_AMOUNT)  ; >=
+    (> total_votes Attendance_Required)  ; TODO: we might want to change this to storing total cats and calculating like with yes votes
+    (> yes_votes (calculate_win_percentage total_votes Pass_Margin))
+    (=
+      announcement_source
+      (calculate_coin_id
+        coin_parent
+        (calculate_full_puzzle_hash
+          (c (f SINGLETON_STRUCT) (c proposal_id (r (r SINGLETON_STRUCT))))
+          (calculate_proposal_puzzle
+            PROPOSAL_MOD_HASH
+            (c (f SINGLETON_STRUCT) (c proposal_id (r (r SINGLETON_STRUCT))))
+            PROPOSAL_TIMER_MOD_HASH
+            CAT_MOD_HASH
+            TREASURY_MOD_HASH
+            LOCKUP_MOD_HASH
+            CAT_TAIL_HASH
+            (f (r SINGLETON_STRUCT))
+            yes_votes  ; this is where we validate the yes votes and total votes
+            total_votes
+            delegated_puzzle_hash
+          )
+        )
+        coin_amount
+      )
+    )
+    (c (list CREATE_COIN PROPOSAL_EXCESS_PAYOUT_PUZ_HASH (- coin_amount 1)) conditions)
+  )
+)
diff --git a/chia/wallet/puzzles/dao_proposal_validator.clsp.hex b/chia/wallet/puzzles/dao_proposal_validator.clsp.hex
new file mode 100644
index 000000000..01145d47a
--- /dev/null
+++ b/chia/wallet/puzzles/dao_proposal_validator.clsp.hex
@@ -0,0 +1 @@
+ff02ffff01ff02ffff03ffff15ffff10ff830bdfffff1480ff8202ff80ffff01ff02ffff03ffff15ff83015fffff820bff80ffff01ff02ffff03ffff15ff8302dfffffff05ffff14ffff12ff83015fffff8217ff80ff3c808080ffff01ff02ffff03ffff09ff824fffffff02ff16ffff04ff02ffff04ff8305dfffffff04ffff02ff2effff04ff02ffff04ff09ffff04ffff02ff2effff04ff02ffff04ff0bffff04ffff0bff14ff82afff80ffff04ffff0bff14ff83015fff80ffff04ffff0bff14ff8302dfff80ffff04ffff0bff14ff1580ffff04ffff0bff14ff82017f80ffff04ffff0bff14ff5f80ffff04ffff0bff14ff81bf80ffff04ffff0bff14ff2f80ffff04ffff0bff14ff1780ffff04ffff0bff14ff0b80ffff04ffff02ff3effff04ff02ffff04ffff04ff09ffff04ff829fffff1d8080ff80808080ff808080808080808080808080808080ffff04ffff02ff3effff04ff02ffff04ffff04ff09ffff04ff829fffff1d8080ff80808080ff808080808080ffff04ff830bdfffff80808080808080ffff01ff04ffff04ff28ffff04ff8205ffffff04ffff11ff830bdfffffff010180ff80808080ff82bfff80ffff01ff088080ff0180ffff01ff088080ff0180ffff01ff088080ff0180ffff01ff088080ff0180ffff04ffff01ffffff02ff3304ff01ff01822710ffff02ff20ff02ffff03ff05ffff01ff02ff3affff04ff02ffff04ff0dffff04ffff0bff12ffff0bff14ff3880ffff0bff12ffff0bff12ffff0bff14ff2c80ff0980ffff0bff12ff0bffff0bff14ff8080808080ff8080808080ffff010b80ff0180ffff02ffff03ffff22ffff09ffff0dff0580ff2a80ffff09ffff0dff0b80ff2a80ffff15ff17ffff0181ff8080ffff01ff0bff05ff0bff1780ffff01ff088080ff0180ffff0bff12ffff0bff14ff1080ffff0bff12ffff0bff12ffff0bff14ff2c80ff0580ffff0bff12ffff02ff3affff04ff02ffff04ff07ffff04ffff0bff14ff1480ff8080808080ffff0bff14ff8080808080ff02ffff03ffff07ff0580ffff01ff0bffff0102ffff02ff3effff04ff02ffff04ff09ff80808080ffff02ff3effff04ff02ffff04ff0dff8080808080ffff01ff0bffff0101ff058080ff0180ff018080
diff --git a/chia/wallet/puzzles/dao_proposal_validator.clsp.hex.sha256tree b/chia/wallet/puzzles/dao_proposal_validator.clsp.hex.sha256tree
new file mode 100644
index 000000000..dc8103326
--- /dev/null
+++ b/chia/wallet/puzzles/dao_proposal_validator.clsp.hex.sha256tree
@@ -0,0 +1 @@
+edff0f36ca097ea55c867f8700cc4d48d267b91fd00ccee2db0fab6fe0645c67
diff --git a/chia/wallet/puzzles/dao_resale_prevention_layer.clsp b/chia/wallet/puzzles/dao_resale_prevention_layer.clsp
new file mode 100644
index 000000000..5e5aa6af4
--- /dev/null
+++ b/chia/wallet/puzzles/dao_resale_prevention_layer.clsp
@@ -0,0 +1,27 @@
+; The function of this file is to force the DAO CAT underneath it to stay in locked voting mode for TIMELOCK period of time
+
+(mod (
+    TIMELOCK  ; absolute block height for when this coin should unlock
+    INNERPUZ
+    (@ inner_sol
+      (
+        my_id
+        inner_solution
+        my_amount
+        new_proposal_vote_id_or_removal_id  ; this is enforced as being empty if we're trying to leave locked state
+        proposal_curry_vals
+        vote_info
+      )
+    )
+  )
+  (include condition_codes.clib)
+  (include curry-and-treehash.clib)
+  (include *standard-cl-21*)
+
+
+  ; uncurry innerpuz and add the new vote procedure
+  (if new_proposal_vote_id_or_removal_id
+      (a INNERPUZ inner_sol)  ; not trying to exit
+      (c (list ASSERT_HEIGHT_ABSOLUTE TIMELOCK) (a INNERPUZ inner_sol))  ; trying to exit
+  )
+)
diff --git a/chia/wallet/puzzles/dao_resale_prevention_layer.clsp.hex b/chia/wallet/puzzles/dao_resale_prevention_layer.clsp.hex
new file mode 100644
index 000000000..64a96e00a
--- /dev/null
+++ b/chia/wallet/puzzles/dao_resale_prevention_layer.clsp.hex
@@ -0,0 +1 @@
+ff02ffff01ff02ffff03ff820177ffff01ff02ffff01ff02ff0bff1780ff0180ffff01ff02ffff01ff04ffff04ffff0153ffff04ff05ffff01808080ffff02ff0bff178080ff018080ff0180ffff04ff80ff018080
\ No newline at end of file
diff --git a/chia/wallet/puzzles/dao_resale_prevention_layer.clsp.hex.sha256tree b/chia/wallet/puzzles/dao_resale_prevention_layer.clsp.hex.sha256tree
new file mode 100644
index 000000000..e69de29bb
diff --git a/chia/wallet/puzzles/dao_safe_payment.clsp b/chia/wallet/puzzles/dao_safe_payment.clsp
new file mode 100644
index 000000000..a58c4e856
--- /dev/null
+++ b/chia/wallet/puzzles/dao_safe_payment.clsp
@@ -0,0 +1,24 @@
+(mod (SINGLETON_STRUCT CONDITIONS SPEND_AMOUNT treasury_puzzle_hash treasury_amount)
+
+  (include condition_codes.clib)
+  (include curry-and-treehash.clib)
+  (include *standard-cl-21*)
+
+  (defun-inline calculate_full_puzzle_hash (SINGLETON_STRUCT inner_puzzle_hash)
+    (puzzle-hash-of-curried-function (f SINGLETON_STRUCT)
+      inner_puzzle_hash
+      (sha256tree SINGLETON_STRUCT)
+    )
+  )
+
+  (c
+    (list ASSERT_MY_AMOUNT treasury_amount)
+    (c
+      (list CREATE_COIN treasury_puzzle_hash (- treasury_amount SPEND_AMOUNT))
+      (c
+        (list ASSERT_MY_PUZZLEHASH (calculate_full_puzzle_hash SINGLETON_STRUCT treasury_puzzle_hash))
+        CONDITIONS
+      )
+    )
+  )
+)
diff --git a/chia/wallet/puzzles/dao_safe_payment.clsp.hex b/chia/wallet/puzzles/dao_safe_payment.clsp.hex
new file mode 100644
index 000000000..5da3d0de5
--- /dev/null
+++ b/chia/wallet/puzzles/dao_safe_payment.clsp.hex
@@ -0,0 +1 @@
+ff02ffff01ff04ffff04ffff0149ffff04ff5fffff01808080ffff04ffff04ffff0133ffff04ff2fffff04ffff11ff5fff1780ffff0180808080ffff04ffff04ffff0148ffff04ffff02ff0affff04ff02ffff04ffff05ff0580ffff04ff2fffff04ffff02ff0effff04ff02ffff04ff05ff80808080ff808080808080ffff01808080ff0b808080ffff04ffff01ffff02ffff03ff05ffff01ff02ffff01ff02ff04ffff04ff02ffff04ffff06ff0580ffff04ffff0bffff0102ffff0bffff0101ffff010480ffff0bffff0102ffff0bffff0102ffff0bffff0101ffff010180ffff05ff058080ffff0bffff0102ff0bffff0bffff0101ffff018080808080ff8080808080ff0180ffff01ff02ffff010bff018080ff0180ffff0bffff0102ffff01a0a12871fee210fb8619291eaea194581cbd2531e4b23759d225f6806923f63222ffff0bffff0102ffff0bffff0102ffff01a09dcf97a184f32623d11a73124ceb99a5709b083721e878a16d78f596718ba7b2ff0580ffff0bffff0102ffff02ff04ffff04ff02ffff04ff07ffff01ffa09dcf97a184f32623d11a73124ceb99a5709b083721e878a16d78f596718ba7b280808080ffff01a04bf5122f344554c53bde2ebb8cd2b7e3d1600ad631c385a5d7cce23c7785459a808080ff02ffff03ffff07ff0580ffff01ff02ffff01ff0bffff0102ffff02ff0effff04ff02ffff04ffff05ff0580ff80808080ffff02ff0effff04ff02ffff04ffff06ff0580ff8080808080ff0180ffff01ff02ffff01ff0bffff0101ff0580ff018080ff0180ff018080
diff --git a/chia/wallet/puzzles/dao_spend_p2_singleton.clsp b/chia/wallet/puzzles/dao_spend_p2_singleton.clsp
new file mode 100644
index 000000000..e24f928d6
--- /dev/null
+++ b/chia/wallet/puzzles/dao_spend_p2_singleton.clsp
@@ -0,0 +1,53 @@
+(mod (
+    CONDITIONS
+    P2_SINGLETON_PUZHASH
+    p2_singleton_parent_amount_list
+  )
+  ; NOTE: this code will NOT work for assets which have special layers like CATs and NFTs
+  ; For those you'll need to make a new proposal type
+
+  ; If you're writing a proposal you'll want to use this layer
+  ; if you don't, your proposal might be invalidated if the p2_singleton coins get spent
+
+  (include condition_codes.clib)
+
+  (defun loop_through_list (SPEND_AMOUNT P2_SINGLETON_PUZHASH p2_calculated p2_singleton_list total output)
+    (c
+      (list CREATE_PUZZLE_ANNOUNCEMENT p2_calculated)
+      (c
+        (list ASSERT_COIN_ANNOUNCEMENT (sha256 p2_calculated '$'))
+        (if p2_singleton_list
+            (loop_through_list
+              SPEND_AMOUNT
+              P2_SINGLETON_PUZHASH
+              (sha256 (f (f p2_singleton_list)) P2_SINGLETON_PUZHASH (f (r (f p2_singleton_list))))
+              (r p2_singleton_list)
+              (+ total (f (r (f p2_singleton_list))))
+            )
+            (if (> total SPEND_AMOUNT)
+                (c (list CREATE_COIN P2_SINGLETON_PUZHASH (- total SPEND_AMOUNT)) output)
+                (x)
+            )
+        )
+      )
+    )
+  )
+
+  (defun sum_create_coins (conditions)
+    (if conditions
+        (+ (if (= (f (f conditions)) CREATE_COIN) (f (r (r (f conditions)))) 0) (sum_create_coins (r conditions)))
+        0
+    )
+  )
+
+
+  ; main
+  (loop_through_list
+    (sum_create_coins CONDITIONS)
+    P2_SINGLETON_PUZHASH
+    (sha256 (f (f p2_singleton_parent_amount_list)) P2_SINGLETON_PUZHASH (f (r (f p2_singleton_parent_amount_list))))
+    (r p2_singleton_parent_amount_list)
+    (f (r (f p2_singleton_parent_amount_list)))
+    CONDITIONS
+  )
+)
diff --git a/chia/wallet/puzzles/dao_spend_p2_singleton.clsp.hex b/chia/wallet/puzzles/dao_spend_p2_singleton.clsp.hex
new file mode 100644
index 000000000..086b1d3ad
--- /dev/null
+++ b/chia/wallet/puzzles/dao_spend_p2_singleton.clsp.hex
@@ -0,0 +1 @@
+ff02ffff01ff02ff16ffff04ff02ffff04ffff02ff1effff04ff02ffff04ff05ff80808080ffff04ff0bffff04ffff0bff47ff0bff81a780ffff04ff37ffff04ff81a7ffff04ff05ff808080808080808080ffff04ffff01ffff3d33ff3effff04ffff04ff0affff04ff17ff808080ffff04ffff04ff08ffff04ffff0bff17ffff012480ff808080ffff02ffff03ff2fffff01ff02ff16ffff04ff02ffff04ff05ffff04ff0bffff04ffff0bff818fff0bff82014f80ffff04ff6fffff04ffff10ff5fff82014f80ff8080808080808080ffff01ff02ffff03ffff15ff5fff0580ffff01ff04ffff04ff0cffff04ff0bffff04ffff11ff5fff0580ff80808080ff81bf80ffff01ff088080ff018080ff01808080ff02ffff03ff05ffff01ff10ffff02ffff03ffff09ff11ff0c80ffff0159ff8080ff0180ffff02ff1effff04ff02ffff04ff0dff8080808080ff8080ff0180ff018080
\ No newline at end of file
diff --git a/chia/wallet/puzzles/dao_spend_p2_singleton.clsp.hex.sha256tree b/chia/wallet/puzzles/dao_spend_p2_singleton.clsp.hex.sha256tree
new file mode 100644
index 000000000..33e4a8f0d
--- /dev/null
+++ b/chia/wallet/puzzles/dao_spend_p2_singleton.clsp.hex.sha256tree
@@ -0,0 +1 @@
+54964584da94f665a970e4d8b6e2091c4f2abe447886db82f19583f1a7e43ceb
diff --git a/chia/wallet/puzzles/dao_spend_p2_singleton_v2.clsp b/chia/wallet/puzzles/dao_spend_p2_singleton_v2.clsp
new file mode 100644
index 000000000..726a1a9a0
--- /dev/null
+++ b/chia/wallet/puzzles/dao_spend_p2_singleton_v2.clsp
@@ -0,0 +1,203 @@
+(mod (
+    TREASURY_SINGLETON_STRUCT
+    CAT_MOD_HASH
+    CONDITIONS  ; XCH conditions, to be generated by the treasury
+    LIST_OF_TAILHASH_CONDITIONS  ; the delegated puzzlehash must be curried in to the proposal.
+    ; Puzzlehash is only run in the last coin for that asset
+    ; ((TAIL_HASH CONDITIONS) (TAIL_HASH CONDITIONS)... )
+    P2_SINGLETON_VIA_DELEGATED_PUZZLE_PUZHASH
+    p2_singleton_parent_amount_list  ; for xch this is just a list of (coin_parent coin_amount)
+    p2_singleton_tailhash_parent_amount_list  ; list of ((asset (parent amount) (parent amount)... ) (asset (parent amount)... )... ),
+    ; must match order of curryed asset list
+    ; the last (parent amount) gets given the puzzlehash, the rest get given 0
+    treasury_inner_puzhash
+  )
+  ; we need to track CAT_TYPE and DELEGATED_PUZZLE
+  ; list of (asset_type (parent amount))
+
+  ; If you're writing a proposal you'll want to use this layer
+  ; if you don't, your proposal might be invalidated if the p2_singleton coins get spent
+
+  (include condition_codes.clib)
+  (include curry-and-treehash.clib)
+
+  (defun-inline calculate_singleton_puzzle_hash (PROPOSAL_SINGLETON_STRUCT inner_puzzle_hash)
+    (puzzle-hash-of-curried-function (f PROPOSAL_SINGLETON_STRUCT)
+      inner_puzzle_hash
+      (sha256tree PROPOSAL_SINGLETON_STRUCT)
+    )
+  )
+
+  (defun loop_through_list (
+      SPEND_AMOUNT
+      P2_SINGLETON_PUZHASH
+      p2_calculated
+      p2_singleton_list
+      total
+      output
+    )
+    (c
+      (list CREATE_PUZZLE_ANNOUNCEMENT (sha256tree (list p2_calculated (sha256tree 0))))
+      (c
+        (list ASSERT_COIN_ANNOUNCEMENT (sha256 p2_calculated '$'))
+        (if p2_singleton_list
+            (loop_through_list
+              SPEND_AMOUNT
+              P2_SINGLETON_PUZHASH
+              (calculate_coin_id (f (f p2_singleton_list)) P2_SINGLETON_PUZHASH (f (r (f p2_singleton_list))))
+              (r p2_singleton_list)
+              (+ total (f (r (f p2_singleton_list))))
+            )
+            (if (> total (- SPEND_AMOUNT ONE))
+                (c
+                  (list CREATE_COIN P2_SINGLETON_PUZHASH (- total SPEND_AMOUNT))
+                  output
+                )
+                (x)  ; the coins you've selected do not add up enough to cover the amount - TODO: is this necessary?
+            )
+        )
+      )
+    )
+  )
+
+  (defun add_announcements_to_result (p2_calculated delegated_puzhash output)
+    (c
+      (list CREATE_PUZZLE_ANNOUNCEMENT (sha256tree (list p2_calculated delegated_puzhash)))
+      (c
+        (list ASSERT_COIN_ANNOUNCEMENT (sha256 p2_calculated '$'))
+        output
+      )
+    )
+  )
+
+  (defun sum_create_coins (conditions)
+    (if conditions
+        (+
+          (if
+            (= (f (f conditions)) CREATE_COIN)
+            (if
+              (> (f (r (r (f conditions)))) 0)  ; make an exception for -113 and other magic conditions
+              (f (r (r (f conditions))))
+              0
+            )
+            0
+          )
+          (sum_create_coins (r conditions))
+        )
+        0
+    )
+  )
+
+  (defun-inline calculate_delegated_puzzlehash (CONDITIONS)
+    (sha256tree (c ONE CONDITIONS))  ; this makes (q . CONDITIONS)
+  )
+
+  (defun wrap_in_cat_layer (CAT_MOD_HASH CAT_TAIL_HASH INNERPUZHASH)
+    (puzzle-hash-of-curried-function CAT_MOD_HASH
+      INNERPUZHASH
+      (sha256 ONE CAT_TAIL_HASH)
+      (sha256 ONE CAT_MOD_HASH)
+    )
+  )
+
+  (defun for_each_asset (
+      CAT_MOD_HASH
+      CONDITIONS_FOR_THIS_ASSET_TYPE
+      P2_SINGLETON_PUZHASH
+      tail_hash
+      parent_amount_list
+      total
+      create_coin_sum
+      output
+    )
+    (if (r parent_amount_list)
+        (add_announcements_to_result
+          (sha256 (f (f parent_amount_list)) (wrap_in_cat_layer CAT_MOD_HASH tail_hash P2_SINGLETON_PUZHASH) (f (r (f parent_amount_list))))
+          (sha256tree 0)  ; this is the delegated_puzhash
+          (for_each_asset
+            CAT_MOD_HASH
+            CONDITIONS_FOR_THIS_ASSET_TYPE
+            P2_SINGLETON_PUZHASH
+            tail_hash
+            parent_amount_list
+            (+ total (f (r (f parent_amount_list))))
+            create_coin_sum
+            output
+          )
+        )
+        (if (> (+ total (f (r (f parent_amount_list)))) (- create_coin_sum ONE))
+            (add_announcements_to_result
+              (sha256 (f (f parent_amount_list)) (wrap_in_cat_layer CAT_MOD_HASH tail_hash P2_SINGLETON_PUZHASH) (f (r (f parent_amount_list))))
+              (calculate_delegated_puzzlehash
+                (c
+                  (list CREATE_COIN P2_SINGLETON_PUZHASH (- (+ total (f (r (f parent_amount_list)))) create_coin_sum))
+                  CONDITIONS_FOR_THIS_ASSET_TYPE
+                )
+              )
+              0
+              output
+            )
+            (x)  ; the coins you've selected do not add up enough to cover the amount - TODO: is this necessary?
+        )
+    )
+  )
+
+  (defun for_each_asset_type (
+      CAT_MOD_HASH
+      P2_SINGLETON_PUZHASH
+      LIST_OF_TAILHASH_CONDITIONS
+      p2_singleton_tailhash_parent_amount_list  ; ((tailhash ((parent amount) (parent_amount)... ) (tailhash (parent amount))..)
+      output
+    )
+    (if p2_singleton_tailhash_parent_amount_list
+        (for_each_asset_type
+          CAT_MOD_HASH
+          P2_SINGLETON_PUZHASH
+          (r LIST_OF_TAILHASH_CONDITIONS)
+          (r p2_singleton_tailhash_parent_amount_list)
+          (for_each_asset
+            CAT_MOD_HASH
+            (if
+              (=
+                (f (f LIST_OF_TAILHASH_CONDITIONS))
+                (f (f p2_singleton_tailhash_parent_amount_list))
+              )
+              (f (r (f LIST_OF_TAILHASH_CONDITIONS)))
+              (x)  ; bad solution format
+            )
+            P2_SINGLETON_PUZHASH
+            (f (f p2_singleton_tailhash_parent_amount_list))  ; tail_hash
+            (r (f p2_singleton_tailhash_parent_amount_list))  ; list of ((parent amount) (parent amount)...)
+            0  ; current total - initialise as 0
+            (sum_create_coins (f (r (f LIST_OF_TAILHASH_CONDITIONS))))
+            output  ; add new conditions to previous calculated output conditions
+          )
+        )
+        output  ; at the end of the loop output our calculated conditions
+    )
+  )
+
+
+  ; main
+  (c
+    (list ASSERT_MY_PUZZLEHASH (calculate_singleton_puzzle_hash TREASURY_SINGLETON_STRUCT treasury_inner_puzhash))
+    (c
+      (list CREATE_COIN treasury_inner_puzhash ONE (list (f (r TREASURY_SINGLETON_STRUCT))))
+      (loop_through_list
+        (sum_create_coins CONDITIONS)
+        P2_SINGLETON_VIA_DELEGATED_PUZZLE_PUZHASH
+        (sha256 (f (f p2_singleton_parent_amount_list)) P2_SINGLETON_VIA_DELEGATED_PUZZLE_PUZHASH (f (r (f p2_singleton_parent_amount_list))))
+        (r p2_singleton_parent_amount_list)
+        (f (r (f p2_singleton_parent_amount_list)))
+        (for_each_asset_type
+          CAT_MOD_HASH
+          P2_SINGLETON_VIA_DELEGATED_PUZZLE_PUZHASH
+          LIST_OF_TAILHASH_CONDITIONS
+          p2_singleton_tailhash_parent_amount_list  ; ((tailhash ((parent amount) (parent_amount)... ) (tailhash (parent amount))..)
+          CONDITIONS
+        )
+      )
+    )
+  )
+
+)
diff --git a/chia/wallet/puzzles/dao_spend_p2_singleton_v2.clsp.hex b/chia/wallet/puzzles/dao_spend_p2_singleton_v2.clsp.hex
new file mode 100644
index 000000000..c72ca20be
--- /dev/null
+++ b/chia/wallet/puzzles/dao_spend_p2_singleton_v2.clsp.hex
@@ -0,0 +1 @@
+ff02ffff01ff04ffff04ff30ffff04ffff02ff36ffff04ff02ffff04ff09ffff04ff8202ffffff04ffff02ff2effff04ff02ffff04ff05ff80808080ff808080808080ff808080ffff04ffff04ff58ffff04ff8202ffffff04ff34ffff04ffff04ff15ff8080ff8080808080ffff02ff26ffff04ff02ffff04ffff02ff5effff04ff02ffff04ff17ff80808080ffff04ff5fffff04ffff0bff82023fff5fff82053f80ffff04ff8201bfffff04ff82053fffff04ffff02ff7affff04ff02ffff04ff0bffff04ff5fffff04ff2fffff04ff82017fffff04ff17ff8080808080808080ff8080808080808080808080ffff04ffff01ffffffff3d48ff02ff333effff0401ff01ff02ff04ffff04ff78ffff04ffff02ff2effff04ff02ffff04ffff04ff05ffff04ff0bff808080ff80808080ff808080ffff04ffff04ff20ffff04ffff0bff05ffff012480ff808080ff178080ffffff20ff02ffff03ff05ffff01ff02ff32ffff04ff02ffff04ff0dffff04ffff0bff5cffff0bff34ff2480ffff0bff5cffff0bff5cffff0bff34ff2c80ff0980ffff0bff5cff0bffff0bff34ff8080808080ff8080808080ffff010b80ff0180ffff02ffff03ffff22ffff09ffff0dff0580ff2280ffff09ffff0dff0b80ff2280ffff15ff17ffff0181ff8080ffff01ff0bff05ff0bff1780ffff01ff088080ff0180ffff02ffff03ff81dfffff01ff02ff7cffff04ff02ffff04ffff0bff82011fffff02ff7effff04ff02ffff04ff05ffff04ff2fffff04ff17ff808080808080ff82029f80ffff04ffff02ff2effff04ff02ffff01ff80808080ffff04ffff02ff5affff04ff02ffff04ff05ffff04ff0bffff04ff17ffff04ff2fffff04ff5fffff04ffff10ff81bfff82029f80ffff04ff82017fffff04ff8202ffff8080808080808080808080ff808080808080ffff01ff02ffff03ffff15ffff10ff81bfff82029f80ffff11ff82017fff348080ffff01ff02ff7cffff04ff02ffff04ffff0bff82011fffff02ff7effff04ff02ffff04ff05ffff04ff2fffff04ff17ff808080808080ff82029f80ffff04ffff02ff2effff04ff02ffff04ffff04ff34ffff04ffff04ff58ffff04ff17ffff04ffff11ffff10ff81bfff82029f80ff82017f80ff80808080ff0b8080ff80808080ffff04ff80ffff04ff8202ffff80808080808080ffff01ff088080ff018080ff0180ff02ffff03ff2fffff01ff02ff7affff04ff02ffff04ff05ffff04ff0bffff04ff37ffff04ff6fffff04ffff02ff5affff04ff02ffff04ff05ffff04ffff02ffff03ffff09ff47ff818f80ffff0181a7ffff01ff088080ff0180ffff04ff0bffff04ff818fffff04ff81cfffff04ff80ffff04ffff02ff5effff04ff02ffff04ff81a7ff80808080ffff04ff5fff8080808080808080808080ff8080808080808080ffff015f80ff0180ffffff04ffff04ff78ffff04ffff02ff2effff04ff02ffff04ffff04ff17ffff04ffff02ff2effff04ff02ffff01ff80808080ff808080ff80808080ff808080ffff04ffff04ff20ffff04ffff0bff17ffff012480ff808080ffff02ffff03ff2fffff01ff02ff26ffff04ff02ffff04ff05ffff04ff0bffff04ffff02ff2affff04ff02ffff04ff818fffff04ff0bffff04ff82014fff808080808080ffff04ff6fffff04ffff10ff5fff82014f80ff8080808080808080ffff01ff02ffff03ffff15ff5fffff11ff05ff348080ffff01ff04ffff04ff58ffff04ff0bffff04ffff11ff5fff0580ff80808080ff81bf80ffff01ff088080ff018080ff01808080ff0bff5cffff0bff34ff2880ffff0bff5cffff0bff5cffff0bff34ff2c80ff0580ffff0bff5cffff02ff32ffff04ff02ffff04ff07ffff04ffff0bff34ff3480ff8080808080ffff0bff34ff8080808080ffff02ffff03ffff07ff0580ffff01ff0bffff0102ffff02ff2effff04ff02ffff04ff09ff80808080ffff02ff2effff04ff02ffff04ff0dff8080808080ffff01ff0bffff0101ff058080ff0180ffff02ffff03ff05ffff01ff10ffff02ffff03ffff09ff11ff5880ffff01ff02ffff03ffff15ff59ff8080ffff0159ff8080ff0180ff8080ff0180ffff02ff5effff04ff02ffff04ff0dff8080808080ff8080ff0180ff02ff36ffff04ff02ffff04ff05ffff04ff17ffff04ffff0bff34ff0b80ffff04ffff0bff34ff0580ff80808080808080ff018080
diff --git a/chia/wallet/puzzles/dao_spend_p2_singleton_v2.clsp.hex.sha256tree b/chia/wallet/puzzles/dao_spend_p2_singleton_v2.clsp.hex.sha256tree
new file mode 100644
index 000000000..9cde8be6a
--- /dev/null
+++ b/chia/wallet/puzzles/dao_spend_p2_singleton_v2.clsp.hex.sha256tree
@@ -0,0 +1 @@
+fb3890f672c9df3cc69699e21446b89b55b65071d35bf5c80a49d11c9b79a68f
diff --git a/chia/wallet/puzzles/dao_treasury.clsp b/chia/wallet/puzzles/dao_treasury.clsp
new file mode 100644
index 000000000..30387232a
--- /dev/null
+++ b/chia/wallet/puzzles/dao_treasury.clsp
@@ -0,0 +1,116 @@
+(mod
+  (
+    TREASURY_MOD_HASH
+    PROPOSAL_VALIDATOR  ; this is the curryed proposal validator
+    PROPOSAL_LENGTH
+    PROPOSAL_SOFTCLOSE_LENGTH
+    ATTENDANCE_REQUIRED
+    PASS_MARGIN  ; this is a percentage 0 - 10,000 - 51% would be 5100
+    PROPOSAL_SELF_DESTRUCT_TIME  ; time in seconds after which proposals can be automatically closed
+    ORACLE_SPEND_DELAY  ; timelock delay for oracle spend
+    proposal_flag  ; if this is set then we are closing a proposal
+    (@ proposal_announcement (announcement_source delegated_puzzle_hash announcement_args spend_or_update_flag))
+    proposal_validator_solution
+    delegated_puzzle_reveal  ; this is the reveal of the puzzle announced by the proposal
+    delegated_solution  ; this is not secure unless the delegated puzzle secures it
+    my_singleton_struct
+  )
+  (include utility_macros.clib)
+  (include condition_codes.clib)
+  (include curry-and-treehash.clib)
+
+  (defun-inline recreate_self (
+      TREASURY_MOD_HASH
+      PROPOSAL_VALIDATOR
+      PROPOSAL_LENGTH
+      PROPOSAL_SOFTCLOSE_LENGTH
+      ATTENDANCE_REQUIRED
+      PASS_MARGIN
+      PROPOSAL_SELF_DESTRUCT_TIME
+      ORACLE_SPEND_DELAY
+    )
+    (puzzle-hash-of-curried-function TREASURY_MOD_HASH
+      (sha256 ONE ORACLE_SPEND_DELAY)
+      (sha256 ONE PROPOSAL_SELF_DESTRUCT_TIME)
+      (sha256 ONE PASS_MARGIN)
+      (sha256 ONE ATTENDANCE_REQUIRED)
+      (sha256 ONE PROPOSAL_SOFTCLOSE_LENGTH)
+      (sha256 ONE PROPOSAL_LENGTH)
+      (sha256tree PROPOSAL_VALIDATOR)
+      (sha256 ONE TREASURY_MOD_HASH)
+    )
+  )
+
+  (defun calculate_singleton_puzzle_hash (SINGLETON_STRUCT inner_puzzle_hash)
+    (puzzle-hash-of-curried-function (f SINGLETON_STRUCT)
+      inner_puzzle_hash
+      (sha256tree SINGLETON_STRUCT)
+    )
+  )
+
+  (defun stager (ORACLE_SPEND_DELAY my_inner_puzhash singleton_struct)
+    (c
+      (if singleton_struct
+          (list ASSERT_MY_COIN_ID
+            (sha256
+              (f (r singleton_struct))
+              (calculate_singleton_puzzle_hash singleton_struct my_inner_puzhash)
+              ONE
+            )
+          )
+          (list ASSERT_HEIGHT_RELATIVE ORACLE_SPEND_DELAY)
+      )
+      (list (list CREATE_COIN my_inner_puzhash ONE))
+    )
+  )
+
+  (if proposal_flag
+      ; if we're checking a proposal (testing if it has passed)
+      (if (= (sha256tree delegated_puzzle_reveal) delegated_puzzle_hash)
+          ; Merge the treasury conditions with the proposal validator conditions
+          ; If the update case then the validator returns the new treasury create coin
+          ; If the spend case then we need to recreate the treasury outselves
+          ; treasury specific conditions
+          (c
+            (list CREATE_PUZZLE_ANNOUNCEMENT (f proposal_validator_solution))  ; specify the proposal we're talking about
+            (c
+              ; also announce the oracle info so proposals can close if treasury is being spammed
+              (list CREATE_PUZZLE_ANNOUNCEMENT 0)  ; the arguments are secured implicitly in the puzzle of the treasury
+              (c
+                (list ASSERT_COIN_ANNOUNCEMENT (sha256 announcement_source (sha256tree (list delegated_puzzle_hash announcement_args))))  ; announcement source is validated inside the ProposalValidator
+                (a
+                  PROPOSAL_VALIDATOR
+                  (list
+                    ATTENDANCE_REQUIRED
+                    PASS_MARGIN
+                    proposal_announcement
+                    proposal_validator_solution
+                    (a delegated_puzzle_reveal delegated_solution)
+                  )
+                )
+              )
+            )
+          )
+          (x)
+      )
+      ; no proposal_flag so create the oracle announcement
+      (c
+        ; add announcement attendance required
+        (list CREATE_PUZZLE_ANNOUNCEMENT 0)  ; the arguments are secured implicitly in the puzzle of the treasury
+        (stager
+          ORACLE_SPEND_DELAY
+          (recreate_self
+            TREASURY_MOD_HASH
+            PROPOSAL_VALIDATOR
+            PROPOSAL_LENGTH
+            PROPOSAL_SOFTCLOSE_LENGTH
+            ATTENDANCE_REQUIRED
+            PASS_MARGIN
+            PROPOSAL_SELF_DESTRUCT_TIME
+            ORACLE_SPEND_DELAY
+          )
+          my_singleton_struct
+        )
+      )
+  )
+)
diff --git a/chia/wallet/puzzles/dao_treasury.clsp.hex b/chia/wallet/puzzles/dao_treasury.clsp.hex
new file mode 100644
index 000000000..e3601cbad
--- /dev/null
+++ b/chia/wallet/puzzles/dao_treasury.clsp.hex
@@ -0,0 +1 @@
+ff02ffff01ff02ffff03ff8205ffffff01ff02ffff03ffff09ffff02ff2effff04ff02ffff04ff822fffff80808080ff822bff80ffff01ff04ffff04ff2cffff04ff8227ffff808080ffff04ffff04ff2cffff01ff808080ffff04ffff04ff10ffff04ffff0bff8213ffffff02ff2effff04ff02ffff04ffff04ff822bffffff04ff825bffff808080ff8080808080ff808080ffff02ff0bffff04ff5fffff04ff81bfffff04ff820bffffff04ff8217ffffff04ffff02ff822fffff825fff80ff80808080808080808080ffff01ff088080ff0180ffff01ff04ffff04ff2cffff01ff808080ffff02ff3effff04ff02ffff04ff8202ffffff04ffff02ff36ffff04ff02ffff04ff05ffff04ffff0bff22ff8202ff80ffff04ffff0bff22ff82017f80ffff04ffff0bff22ff81bf80ffff04ffff0bff22ff5f80ffff04ffff0bff22ff2f80ffff04ffff0bff22ff1780ffff04ffff02ff2effff04ff02ffff04ff0bff80808080ffff04ffff0bff22ff0580ff808080808080808080808080ffff04ff82bfffff8080808080808080ff0180ffff04ffff01ffffff3dff5246ffff0233ff3e04ffffff0101ff02ff02ffff03ff05ffff01ff02ff3affff04ff02ffff04ff0dffff04ffff0bff2affff0bff22ff3c80ffff0bff2affff0bff2affff0bff22ff3280ff0980ffff0bff2aff0bffff0bff22ff8080808080ff8080808080ffff010b80ff0180ffffff02ff36ffff04ff02ffff04ff09ffff04ff0bffff04ffff02ff2effff04ff02ffff04ff05ff80808080ff808080808080ff0bff2affff0bff22ff2480ffff0bff2affff0bff2affff0bff22ff3280ff0580ffff0bff2affff02ff3affff04ff02ffff04ff07ffff04ffff0bff22ff2280ff8080808080ffff0bff22ff8080808080ffff02ffff03ffff07ff0580ffff01ff0bffff0102ffff02ff2effff04ff02ffff04ff09ff80808080ffff02ff2effff04ff02ffff04ff0dff8080808080ffff01ff0bffff0101ff058080ff0180ff04ffff02ffff03ff17ffff01ff04ff38ffff04ffff0bff57ffff02ff26ffff04ff02ffff04ff17ffff04ff0bff8080808080ff2280ff808080ffff01ff04ff28ffff04ff05ff80808080ff0180ffff04ffff04ff34ffff04ff0bffff04ff22ff80808080ff808080ff018080
diff --git a/chia/wallet/puzzles/dao_treasury_with_hack.clsp.hex b/chia/wallet/puzzles/dao_treasury_with_hack.clsp.hex
new file mode 100644
index 000000000..018b88fd1
--- /dev/null
+++ b/chia/wallet/puzzles/dao_treasury_with_hack.clsp.hex
@@ -0,0 +1 @@
+ff02ffff01ff02ffff03ff8205ffffff01ff02ffff03ffff09ffff02ff2effff04ff02ffff04ff822fffff80808080ff822bff80ffff01ff04ffff04ff2cffff04ff8227ffff808080ffff04ffff04ff2cffff01ff808080ffff04ffff04ff38ffff04ffff0bff8213ffffff02ff2effff04ff02ffff04ffff04ff822bffffff04ff825bffff808080ff8080808080ff808080ffff02ff0bffff04ff5fffff04ff81bfffff04ff820bffffff04ff8217ffffff04ffff02ff822fffff825fff80ff80808080808080808080ffff01ff088080ff0180ffff01ff04ffff04ff2cffff01ff808080ffff02ff3effff04ff02ffff04ff8202ffffff04ffff02ff36ffff04ff02ffff04ff05ffff04ffff0bff22ff8202ff80ffff04ffff0bff22ff82017f80ffff04ffff0bff22ff81bf80ffff04ffff0bff22ff5f80ffff04ffff0bff22ff2f80ffff04ffff0bff22ff1780ffff04ffff02ff2effff04ff02ffff04ff0bff80808080ffff04ffff0bff22ff0580ff808080808080808080808080ffff04ff82bfffff8080808080808080ff0180ffff04ffff01ffffff52ff463fffff0233ff3e04ffffff0101ff02ff02ffff03ff05ffff01ff02ff3affff04ff02ffff04ff0dffff04ffff0bff2affff0bff22ff3c80ffff0bff2affff0bff2affff0bff22ff3280ff0980ffff0bff2aff0bffff0bff22ff8080808080ff8080808080ffff010b80ff0180ffffff02ff36ffff04ff02ffff04ff09ffff04ff0bffff04ffff02ff2effff04ff02ffff04ff05ff80808080ff808080808080ff0bff2affff0bff22ff2480ffff0bff2affff0bff2affff0bff22ff3280ff0580ffff0bff2affff02ff3affff04ff02ffff04ff07ffff04ffff0bff22ff2280ff8080808080ffff0bff22ff8080808080ffff02ffff03ffff07ff0580ffff01ff0bffff0102ffff02ff2effff04ff02ffff04ff09ff80808080ffff02ff2effff04ff02ffff04ff0dff8080808080ffff01ff0bffff0101ff058080ff0180ff04ffff02ffff03ff17ffff01ff04ff28ffff04ffff0bff57ffff02ff26ffff04ff02ffff04ff17ffff04ff0bff8080808080ff2280ff808080ffff01ff04ff10ffff04ff05ff80808080ff0180ffff04ffff04ff34ffff04ff0bffff04ff22ff80808080ff808080ff018080
diff --git a/chia/wallet/puzzles/dao_update_proposal.clsp b/chia/wallet/puzzles/dao_update_proposal.clsp
new file mode 100644
index 000000000..4333f5a7d
--- /dev/null
+++ b/chia/wallet/puzzles/dao_update_proposal.clsp
@@ -0,0 +1,36 @@
+(mod
+  (
+    TREASURY_MOD_HASH
+    PROPOSAL_VALIDATOR
+    PROPOSAL_LENGTH
+    PROPOSAL_SOFTCLOSE_LENGTH
+    ATTENDANCE_REQUIRED
+    PASS_MARGIN
+    PROPOSAL_SELF_DESTRUCT_TIME
+    ORACLE_SPEND_DELAY
+  )
+  ;; This is a proposal to update treasury conditions for a DAO
+
+
+  (include condition_codes.clib)
+  (include curry-and-treehash.clib)
+  (include *standard-cl-21*)
+  (include utility_macros.clib)
+
+
+  (list
+    (list CREATE_COIN
+      (puzzle-hash-of-curried-function TREASURY_MOD_HASH
+        (sha256 ONE ORACLE_SPEND_DELAY)
+        (sha256 ONE PROPOSAL_SELF_DESTRUCT_TIME)
+        (sha256 ONE PASS_MARGIN)
+        (sha256 ONE ATTENDANCE_REQUIRED)
+        (sha256 ONE PROPOSAL_SOFTCLOSE_LENGTH)
+        (sha256 ONE PROPOSAL_LENGTH)
+        (sha256tree PROPOSAL_VALIDATOR)
+        (sha256 ONE TREASURY_MOD_HASH)
+      )
+      ONE
+    )
+  )
+)
diff --git a/chia/wallet/puzzles/dao_update_proposal.clsp.hex b/chia/wallet/puzzles/dao_update_proposal.clsp.hex
new file mode 100644
index 000000000..672485f55
--- /dev/null
+++ b/chia/wallet/puzzles/dao_update_proposal.clsp.hex
@@ -0,0 +1 @@
+ff02ffff01ff04ffff04ffff0133ffff04ffff02ff0affff04ff02ffff04ff05ffff04ffff0bffff0101ff8202ff80ffff04ffff0bffff0101ff82017f80ffff04ffff0bffff0101ff8200bf80ffff04ffff0bffff0101ff5f80ffff04ffff0bffff0101ff2f80ffff04ffff0bffff0101ff1780ffff04ffff02ff0effff04ff02ffff04ff0bff80808080ffff04ffff0bffff0101ff0580ff808080808080808080808080ffff04ffff0101ffff0180808080ffff018080ffff04ffff01ffff02ffff03ff05ffff01ff02ffff01ff02ff04ffff04ff02ffff04ffff06ff0580ffff04ffff0bffff0102ffff0bffff0101ffff010480ffff0bffff0102ffff0bffff0102ffff0bffff0101ffff010180ffff05ff058080ffff0bffff0102ff0bffff0bffff0101ffff018080808080ff8080808080ff0180ffff01ff02ffff010bff018080ff0180ffff0bffff0102ffff01a0a12871fee210fb8619291eaea194581cbd2531e4b23759d225f6806923f63222ffff0bffff0102ffff0bffff0102ffff01a09dcf97a184f32623d11a73124ceb99a5709b083721e878a16d78f596718ba7b2ff0580ffff0bffff0102ffff02ff04ffff04ff02ffff04ff07ffff01ffa09dcf97a184f32623d11a73124ceb99a5709b083721e878a16d78f596718ba7b280808080ffff01a04bf5122f344554c53bde2ebb8cd2b7e3d1600ad631c385a5d7cce23c7785459a808080ff02ffff03ffff07ff0580ffff01ff02ffff01ff0bffff0102ffff02ff0effff04ff02ffff04ffff05ff0580ff80808080ffff02ff0effff04ff02ffff04ffff06ff0580ff8080808080ff0180ffff01ff02ffff01ff0bffff0101ff0580ff018080ff0180ff018080
diff --git a/chia/wallet/puzzles/deployed_puzzle_hashes.json b/chia/wallet/puzzles/deployed_puzzle_hashes.json
index 96b0cc947..8511a55b5 100644
--- a/chia/wallet/puzzles/deployed_puzzle_hashes.json
+++ b/chia/wallet/puzzles/deployed_puzzle_hashes.json
@@ -7,6 +7,24 @@
     "covenant_layer": "b982796850336aabf9ab17c3f21e299f0c633444117ab5e9ebeafadf1860d9fc",
     "create_nft_launcher_from_did": "7a32d2d9571d3436791c0ad3d7fcfdb9c43ace2b0f0ff13f98d29f0cc093f445",
     "credential_restriction": "2fdfc1f058cfd65e7ec4e253bfeb394da163ecd0036f508df8629b0a2b8fde96",
+    "dao_cat_buy_in": "2421f1375866bd9e27ed35179003018e1e44cbdfee96592f5c6eb62c7ababd8a",
+    "dao_cat_eve": "488f55bedaca5a599544dfd5ab341e2e5c7e6fca67d9b98a3d856f876c52f53e",
+    "dao_cat_launcher": "15eb3382528a5d25af7f2af3942cd31e71dacf41320910698a753179684d970d",
+    "dao_dividend": "e3e4e15e7dd1694d776ba716c21dfff181530852682498220002ae72a8a261b2",
+    "dao_dividend_timer": "f85df70f39c65b836cccfa5c93939452319ab42136f653ffee3bbd795eb022dc",
+    "dao_finished_state": "7f3cc356732907933a8f9b1ccf16f71735d07340eb38c847aa402e97d75eb40b",
+    "dao_lockup": "9fa63e652e131f89a9f8bb6f7abb5ffc6ac485a78dcfb8710cd9df5c368774d9",
+    "dao_proposal": "a27440cdee44f910e80225592e51dc03721a9d819cc358165587fa2b34eef4cd",
+    "dao_proposal_timer": "87f2808340dab6a5fb8194c501b3133f1f850c5a8bf422e7b049762486819813",
+    "dao_proposal_validator": "0737418c68d175fcd5bb7584a6c736f8daca184f69f50bf8ad021592b5e8b538",
+    "dao_resale_prevention_layer": "5940dea172de20b34149f709931057eb27cd0d1e769830102345bb7b1e4751c5",
+    "dao_safe_payment": "3a86a13d78980b4bed1c709834630b47e4d3204125f1e1341be4ca40978649dd",
+    "dao_spend_p2_singleton": "54964584da94f665a970e4d8b6e2091c4f2abe447886db82f19583f1a7e43ceb",
+    "dao_spend_p2_singleton_v2": "5163024ea180c9ee3949da9db3105a0e3b706a1248ae4138ecd7078d77d5b7c9",
+    "dao_treasury": "8db946dbea7db3c6e99f45225b4159bd5f2ed0b53576a5c80aca2fe8ffdd99b6",
+    "dao_treasury_with_before_cond": "f1b1ae5386e9668a4ac2cd3bb34d9e610f0d324189619f5eb0c3c50437bb4d0f",
+    "dao_treasury_with_hack": "32865fb271c24f6092085fecaa3a4fa6d32d7436773be06700a0aa47539ebdcc",
+    "dao_update_proposal": "70567fde4ec4b6ed83a62bc0e92c3a391203b0d6f7a4d4bf3516c95662ba316c",
     "decompress_coin_spend_entry": "9d98ed08770d31be4bd1bde4705dab388db5e7e9c349f5a76fc3c347aa3a0b79",
     "decompress_coin_spend_entry_with_prefix": "92aa4bc8060a8836355a1884075141b4791ce1b67ae6092bb166b2845954bc89",
     "decompress_puzzle": "fe94c58f1117afe315e0450daca1c62460ec1a1c439cd4018d79967a5d7d1370",
@@ -19,6 +37,7 @@
     "exigent_metadata_layer": "d5fd32e069fda83e230ccd8f6a7c4f652231aed5c755514b3d996cbeff4182b8",
     "flag_proofs_checker": "fe2e3c631562fbb9be095297f762bf573705a0197164e9361ad5d50e045ba241",
     "genesis_by_coin_id": "493afb89eed93ab86741b2aa61b8f5de495d33ff9b781dfc8919e602b2afa150",
+    "genesis_by_coin_id_or_singleton": "3bb7d336e4aaee5cd18bb3d8a01e15acfd56c80ff6801261783596c88a16603b",
     "genesis_by_puzzle_hash": "de5a6e06d41518be97ff6365694f4f89475dda773dede267caa33da63b434e36",
     "graftroot_dl_offers": "0893e36a88c064fddfa6f8abdb42c044584a98cb4273b80cccc83b4867b701a1",
     "nft_intermediate_launcher": "7a32d2d9571d3436791c0ad3d7fcfdb9c43ace2b0f0ff13f98d29f0cc093f445",
@@ -31,6 +50,7 @@
     "p2_1_of_n": "46b29fd87fbeb6737600c4543931222a6c1ed3db6fa5601a3ca284a9f4efe780",
     "p2_announced_delegated_puzzle": "c4d24c3c5349376f3e8f3aba202972091713b4ec4915f0f26192ae4ace0bd04d",
     "p2_conditions": "1c77d7d5efde60a7a1d2d27db6d746bc8e568aea1ef8586ca967a0d60b83cc36",
+    "p2_conditions_curryable": "a12871fee210fb8619291eaea194581cbd2531e4b23759d225f6806923f63222",
     "p2_delegated_conditions": "0ff94726f1a8dea5c3f70d3121945190778d3b2b3fcda3735a1f290977e98341",
     "p2_delegated_puzzle": "542cde70d1102cd1b763220990873efc8ab15625ded7eae22cc11e21ef2e2f7c",
     "p2_delegated_puzzle_or_hidden_puzzle": "e9aaa49f45bad5c889b86ee3341550c155cfdd10c3a6757de618d20612fffd52",
@@ -39,6 +59,7 @@
     "p2_puzzle_hash": "13e29a62b42cd2ef72a79e4bacdc59733ca6310d65af83d349360d36ec622363",
     "p2_singleton": "40f828d8dd55603f4ff9fbf6b73271e904e69406982f4fbefae2c8dcceaf9834",
     "p2_singleton_or_delayed_puzhash": "adb656e0211e2ab4f42069a4c5efc80dc907e7062be08bf1628c8e5b6d94d25b",
+    "p2_singleton_via_delegated_puzzle": "231334e31ed4e60867abb640eb904931a4ce248e68091442e3b0b47a2af77d06",
     "pool_member_innerpuz": "a8490702e333ddd831a3ac9c22d0fa26d2bfeaf2d33608deb22f0e0123eb0494",
     "pool_waitingroom_innerpuz": "a317541a765bf8375e1c6e7c13503d0d2cbf56cacad5182befe947e78e2c0307",
     "rom_bootstrap_generator": "161bade1f822dcd62ab712ebaf30f3922a301e48a639e4295c5685f8bece7bd9",
diff --git a/chia/wallet/puzzles/genesis_by_coin_id_or_singleton.clsp b/chia/wallet/puzzles/genesis_by_coin_id_or_singleton.clsp
new file mode 100644
index 000000000..cf81645c1
--- /dev/null
+++ b/chia/wallet/puzzles/genesis_by_coin_id_or_singleton.clsp
@@ -0,0 +1,43 @@
+; This is a TAIL for use with cat.clvm.
+;
+; This checker allows new CATs to be created if they have a particular coin id as parent
+;
+; The genesis_id is curried in, making this lineage_check program unique and giving the CAT it's uniqueness
+(mod (
+    GENESIS_ID
+    MINT_LAUNCHER_PUZZLE_HASH
+    Truths
+    parent_is_cat
+    lineage_proof
+    delta
+    inner_conditions
+    (  ; solution
+      singleton_inner_puzhash
+      parent_parent_id
+      parent_amount
+    )
+  )
+
+  (include cat_truths.clib)
+  (include curry-and-treehash.clib)
+
+  (if delta
+      (x)
+      (if (= (my_parent_cat_truth Truths) GENESIS_ID)
+          ()
+          (if
+            (=
+              (my_parent_cat_truth Truths)
+              (sha256
+                parent_parent_id
+                MINT_LAUNCHER_PUZZLE_HASH
+                parent_amount
+              )
+            )
+            ()
+            (x)
+          )
+      )
+  )
+
+)
diff --git a/chia/wallet/puzzles/genesis_by_coin_id_or_singleton.clsp.hex b/chia/wallet/puzzles/genesis_by_coin_id_or_singleton.clsp.hex
new file mode 100644
index 000000000..d33b5887c
--- /dev/null
+++ b/chia/wallet/puzzles/genesis_by_coin_id_or_singleton.clsp.hex
@@ -0,0 +1 @@
+ff02ffff03ff5fffff01ff0880ffff01ff02ffff03ffff09ff5bff0280ff80ffff01ff02ffff03ffff09ff5bffff0bff82057fff05ff820b7f8080ff80ffff01ff088080ff018080ff018080ff0180
\ No newline at end of file
diff --git a/chia/wallet/puzzles/genesis_by_coin_id_or_singleton.clsp.hex.sha256tree b/chia/wallet/puzzles/genesis_by_coin_id_or_singleton.clsp.hex.sha256tree
new file mode 100644
index 000000000..c4a926f9f
--- /dev/null
+++ b/chia/wallet/puzzles/genesis_by_coin_id_or_singleton.clsp.hex.sha256tree
@@ -0,0 +1 @@
+140c74d3e8c2b66cae5dca30d03cd532df12f71e9fc17f565e5a973930d11b1f
diff --git a/chia/wallet/puzzles/p2_conditions_curryable.clsp b/chia/wallet/puzzles/p2_conditions_curryable.clsp
new file mode 100644
index 000000000..e93d89556
--- /dev/null
+++ b/chia/wallet/puzzles/p2_conditions_curryable.clsp
@@ -0,0 +1,3 @@
+(mod (CONDITIONS_LIST)
+  CONDITIONS_LIST
+)
diff --git a/chia/wallet/puzzles/p2_conditions_curryable.clsp.hex b/chia/wallet/puzzles/p2_conditions_curryable.clsp.hex
new file mode 100644
index 000000000..9e22bcb8e
--- /dev/null
+++ b/chia/wallet/puzzles/p2_conditions_curryable.clsp.hex
@@ -0,0 +1 @@
+02
diff --git a/chia/wallet/puzzles/p2_singleton_via_delegated_puzzle.clsp b/chia/wallet/puzzles/p2_singleton_via_delegated_puzzle.clsp
new file mode 100644
index 000000000..5f0e52474
--- /dev/null
+++ b/chia/wallet/puzzles/p2_singleton_via_delegated_puzzle.clsp
@@ -0,0 +1,85 @@
+(mod (
+    SINGLETON_STRUCT
+    singleton_inner_puzhash
+    delegated_puzzle
+    delegated_solution
+    my_id
+    my_puzhash  ; only needed for merging, set to 0 otherwise
+    list_of_parent_amounts  ; only needed for merging
+    my_amount  ; only needed for merging
+  )
+
+  (include condition_codes.clib)
+  (include curry-and-treehash.clib)
+
+  (defun-inline calculate_full_puzzle_hash (SINGLETON_STRUCT singleton_inner_puzhash)
+    (puzzle-hash-of-curried-function (f SINGLETON_STRUCT)
+      singleton_inner_puzhash
+      (sha256tree SINGLETON_STRUCT)
+    )
+  )
+
+  (defun cons_announcements_to_output(coin_id output)
+    (c
+      (list CREATE_PUZZLE_ANNOUNCEMENT coin_id)
+      (c
+        (list ASSERT_COIN_ANNOUNCEMENT (sha256tree (list coin_id 0)))
+        output
+      )
+    )
+  )
+
+  (defun for_parent_amounts (my_puzhash list_of_parent_amounts total)
+    (if list_of_parent_amounts
+        (cons_announcements_to_output
+          (calculate_coin_id (f (f list_of_parent_amounts)) my_puzhash (f (r (f list_of_parent_amounts))))  ; asserts that all the coins have the same puzzle as me
+          (for_parent_amounts my_puzhash (r list_of_parent_amounts) (+ total (f (r (f list_of_parent_amounts)))))
+        )
+        (list
+          (list ASSERT_HEIGHT_RELATIVE 5)  ; TODO: should this be higher or lower?
+          (list CREATE_COIN my_puzhash total)
+        )
+    )
+  )
+
+  (defun-inline give_self_to_merge (my_puzhash my_id)
+    (list
+      (list ASSERT_PUZZLE_ANNOUNCEMENT (sha256 my_puzhash my_id))
+      (list CREATE_COIN_ANNOUNCEMENT 0)
+    )
+  )
+
+  (if my_puzhash
+      ; we are merging coins to make a larger coin
+      (c
+        (list ASSERT_MY_PUZZLEHASH my_puzhash)
+        (if list_of_parent_amounts
+            ; we are making the output
+            (c
+              (list ASSERT_MY_AMOUNT my_amount)
+              (for_parent_amounts my_puzhash list_of_parent_amounts my_amount)
+            )
+            ; we are letting another coin make the output
+            (give_self_to_merge my_puzhash my_id)
+        )
+      )
+      ; we are being spent by our singleton
+      (c
+        (list
+          ASSERT_PUZZLE_ANNOUNCEMENT
+          (sha256
+            (calculate_full_puzzle_hash SINGLETON_STRUCT singleton_inner_puzhash)
+            (sha256tree (list my_id (sha256tree delegated_puzzle)))
+          )
+        )
+        (c
+          (list CREATE_COIN_ANNOUNCEMENT '$')
+          (c
+            (list ASSERT_MY_COIN_ID my_id)
+            (a delegated_puzzle delegated_solution)
+          )
+        )
+      )
+  )
+
+)
diff --git a/chia/wallet/puzzles/p2_singleton_via_delegated_puzzle.clsp.hex b/chia/wallet/puzzles/p2_singleton_via_delegated_puzzle.clsp.hex
new file mode 100644
index 000000000..09fe7f0a2
--- /dev/null
+++ b/chia/wallet/puzzles/p2_singleton_via_delegated_puzzle.clsp.hex
@@ -0,0 +1 @@
+ff02ffff01ff02ffff03ff81bfffff01ff04ffff04ff78ffff04ff81bfff808080ffff02ffff03ff82017fffff01ff04ffff04ff28ffff04ff8202ffff808080ffff02ff2effff04ff02ffff04ff81bfffff04ff82017fffff04ff8202ffff80808080808080ffff01ff04ffff04ff24ffff04ffff0bff81bfff5f80ff808080ffff04ffff04ff5cffff01ff808080ff80808080ff018080ffff01ff04ffff04ff24ffff04ffff0bffff02ff5effff04ff02ffff04ff09ffff04ff0bffff04ffff02ff7effff04ff02ffff04ff05ff80808080ff808080808080ffff02ff7effff04ff02ffff04ffff04ff5fffff04ffff02ff7effff04ff02ffff04ff17ff80808080ff808080ff8080808080ff808080ffff04ffff04ff5cffff01ff248080ffff04ffff04ff58ffff04ff5fff808080ffff02ff17ff2f8080808080ff0180ffff04ffff01ffffffff3d52ff49ff4648ffff3f02ff33ff3c3effffff0401ff01ff0220ffffff02ffff03ff05ffff01ff02ff26ffff04ff02ffff04ff0dffff04ffff0bff5affff0bff32ff2280ffff0bff5affff0bff5affff0bff32ff2a80ff0980ffff0bff5aff0bffff0bff32ff8080808080ff8080808080ffff010b80ff0180ffff02ffff03ffff22ffff09ffff0dff0580ff7a80ffff09ffff0dff0b80ff7a80ffff15ff17ffff0181ff8080ffff01ff0bff05ff0bff1780ffff01ff088080ff0180ff04ffff04ff7cffff04ff05ff808080ffff04ffff04ff20ffff04ffff02ff7effff04ff02ffff04ffff04ff05ffff01ff808080ff80808080ff808080ff0b8080ffff02ffff03ff0bffff01ff02ff76ffff04ff02ffff04ffff02ff56ffff04ff02ffff04ff23ffff04ff05ffff04ff53ff808080808080ffff04ffff02ff2effff04ff02ffff04ff05ffff04ff1bffff04ffff10ff17ff5380ff808080808080ff8080808080ffff01ff04ffff04ff30ffff01ff058080ffff04ffff04ff2cffff04ff05ffff04ff17ff80808080ff80808080ff0180ffff0bff5affff0bff32ff3480ffff0bff5affff0bff5affff0bff32ff2a80ff0580ffff0bff5affff02ff26ffff04ff02ffff04ff07ffff04ffff0bff32ff3280ff8080808080ffff0bff32ff8080808080ff02ffff03ffff07ff0580ffff01ff0bffff0102ffff02ff7effff04ff02ffff04ff09ff80808080ffff02ff7effff04ff02ffff04ff0dff8080808080ffff01ff0bffff0101ff058080ff0180ff018080
\ No newline at end of file
diff --git a/chia/wallet/puzzles/tails.py b/chia/wallet/puzzles/tails.py
index 603c55b27..f2f6f095f 100644
--- a/chia/wallet/puzzles/tails.py
+++ b/chia/wallet/puzzles/tails.py
@@ -2,6 +2,8 @@ from __future__ import annotations
 
 from typing import Any, Dict, List, Optional, Tuple
 
+from chia_rs import Coin
+
 from chia.types.blockchain_format.program import Program
 from chia.types.blockchain_format.sized_bytes import bytes32
 from chia.types.spend_bundle import SpendBundle
@@ -15,6 +17,7 @@ from chia.wallet.cat_wallet.cat_utils import (
     unsigned_spend_bundle_for_spendable_cats,
 )
 from chia.wallet.cat_wallet.lineage_store import CATLineageStore
+from chia.wallet.dao_wallet.dao_utils import create_cat_launcher_for_singleton_id
 from chia.wallet.lineage_proof import LineageProof
 from chia.wallet.payment import Payment
 from chia.wallet.puzzles.load_clvm import load_clvm_maybe_recompile
@@ -24,6 +27,7 @@ GENESIS_BY_ID_MOD = load_clvm_maybe_recompile("genesis_by_coin_id.clsp")
 GENESIS_BY_PUZHASH_MOD = load_clvm_maybe_recompile("genesis_by_puzzle_hash.clsp")
 EVERYTHING_WITH_SIG_MOD = load_clvm_maybe_recompile("everything_with_signature.clsp")
 DELEGATED_LIMITATIONS_MOD = load_clvm_maybe_recompile("delegated_tail.clsp")
+GENESIS_BY_ID_OR_SINGLETON_MOD = load_clvm_maybe_recompile("genesis_by_coin_id_or_singleton.clsp")
 
 
 class LimitationsProgram:
@@ -191,6 +195,93 @@ class DelegatedLimitations(LimitationsProgram):
         )
 
 
+class GenesisByIdOrSingleton(LimitationsProgram):
+    """
+    This TAIL allows for another TAIL to be used, as long as a signature of that TAIL's puzzlehash is included.
+    """
+
+    @staticmethod
+    def match(uncurried_mod: Program, curried_args: Program) -> Tuple[bool, List[Program]]:
+        if uncurried_mod == GENESIS_BY_ID_OR_SINGLETON_MOD:
+            genesis_id = curried_args.first()
+            return True, [genesis_id.as_atom()]
+        else:
+            return False, []
+
+    @staticmethod
+    def construct(args: List[Program]) -> Program:
+        return GENESIS_BY_ID_OR_SINGLETON_MOD.curry(
+            args[0],
+            args[1],
+        )
+
+    @staticmethod
+    def solve(args: List[Program], solution_dict: Dict) -> Program:
+        pid = hexstr_to_bytes(solution_dict["parent_coin_info"])
+        return Program.to([pid, solution_dict["amount"]])
+
+    @classmethod
+    async def generate_issuance_bundle(
+        cls, wallet, tail_info: Dict, amount: uint64
+    ) -> Tuple[TransactionRecord, SpendBundle]:
+        if "coins" in tail_info:
+            coins: List[Coin] = tail_info["coins"]
+            origin_id = coins.copy().pop().name()
+        else:
+            coins = await wallet.standard_wallet.select_coins(amount)
+
+            origin = coins.copy().pop()
+            origin_id = origin.name()
+
+        cat_inner: Program = await wallet.get_new_inner_puzzle()
+        # GENESIS_ID
+        # TREASURY_SINGLETON_STRUCT  ; (SINGLETON_MOD_HASH, (LAUNCHER_ID, LAUNCHER_PUZZLE_HASH))
+        launcher_puzhash = create_cat_launcher_for_singleton_id(tail_info["treasury_id"]).get_tree_hash()
+        tail: Program = cls.construct(
+            [
+                Program.to(origin_id),
+                Program.to(launcher_puzhash),
+            ]
+        )
+
+        wallet.lineage_store = await CATLineageStore.create(
+            wallet.wallet_state_manager.db_wrapper, tail.get_tree_hash().hex()
+        )
+        await wallet.add_lineage(origin_id, LineageProof())
+
+        minted_cat_puzzle_hash: bytes32 = construct_cat_puzzle(CAT_MOD, tail.get_tree_hash(), cat_inner).get_tree_hash()
+
+        tx_record: TransactionRecord = await wallet.standard_wallet.generate_signed_transaction(
+            amount, minted_cat_puzzle_hash, uint64(0), origin_id=origin_id, coins=set(coins)
+        )
+        assert tx_record.spend_bundle is not None
+        payment = Payment(cat_inner.get_tree_hash(), amount)
+        inner_solution = wallet.standard_wallet.add_condition_to_solution(
+            Program.to([51, 0, -113, tail, []]),
+            wallet.standard_wallet.make_solution(
+                primaries=[payment],
+            ),
+        )
+        eve_spend = unsigned_spend_bundle_for_spendable_cats(
+            CAT_MOD,
+            [
+                SpendableCAT(
+                    list(filter(lambda a: a.amount == amount, tx_record.additions))[0],
+                    tail.get_tree_hash(),
+                    cat_inner,
+                    inner_solution,
+                    limitations_program_reveal=tail,
+                )
+            ],
+        )
+        signed_eve_spend = await wallet.sign(eve_spend)
+
+        if wallet.cat_info.my_tail is None:
+            await wallet.save_info(CATInfo(tail.get_tree_hash(), tail))
+
+        return tx_record, SpendBundle.aggregate([tx_record.spend_bundle, signed_eve_spend])
+
+
 # This should probably be much more elegant than just a dictionary with strings as identifiers
 # Right now this is small and experimental so it can stay like this
 ALL_LIMITATIONS_PROGRAMS: Dict[str, Any] = {
@@ -198,6 +289,7 @@ ALL_LIMITATIONS_PROGRAMS: Dict[str, Any] = {
     "genesis_by_puzhash": GenesisByPuzhash,
     "everything_with_signature": EverythingWithSig,
     "delegated_limitations": DelegatedLimitations,
+    "genesis_by_id_or_singleton": GenesisByIdOrSingleton,
 }
 
 
diff --git a/chia/wallet/settings/__init__.py b/chia/wallet/settings/__init__.py
new file mode 100644
index 000000000..e69de29bb
diff --git a/chia/wallet/singleton.py b/chia/wallet/singleton.py
index 527836df9..5e3ecf6e7 100644
--- a/chia/wallet/singleton.py
+++ b/chia/wallet/singleton.py
@@ -1,9 +1,12 @@
 from __future__ import annotations
 
-from typing import Optional
+from typing import List, Optional, Union
 
+from chia.types.blockchain_format.coin import Coin
 from chia.types.blockchain_format.program import Program
+from chia.types.blockchain_format.serialized_program import SerializedProgram
 from chia.types.blockchain_format.sized_bytes import bytes32
+from chia.types.coin_spend import CoinSpend, compute_additions
 from chia.wallet.puzzles.load_clvm import load_clvm_maybe_recompile
 from chia.wallet.util.curry_and_treehash import calculate_hash_of_quoted_mod_hash, curry_and_treehash
 
@@ -14,7 +17,7 @@ SINGLETON_LAUNCHER_PUZZLE = load_clvm_maybe_recompile("singleton_launcher.clsp")
 SINGLETON_LAUNCHER_PUZZLE_HASH = SINGLETON_LAUNCHER_PUZZLE.get_tree_hash()
 
 
-def get_inner_puzzle_from_singleton(puzzle: Program) -> Optional[Program]:
+def get_inner_puzzle_from_singleton(puzzle: Union[Program, SerializedProgram]) -> Optional[Program]:
     """
     Extract the inner puzzle of a singleton
     :param puzzle: Singleton puzzle
@@ -30,7 +33,23 @@ def get_inner_puzzle_from_singleton(puzzle: Program) -> Optional[Program]:
     return Program(INNER_PUZZLE)
 
 
-def is_singleton(inner_f: Program) -> bool:
+def get_singleton_id_from_puzzle(puzzle: Union[Program, SerializedProgram]) -> Optional[bytes32]:
+    """
+    Extract the singleton ID from a singleton puzzle
+    :param puzzle: Singleton puzzle
+    :return: Inner puzzle
+    """
+    r = puzzle.uncurry()
+    if r is None:
+        return None
+    inner_f, args = r
+    if not is_singleton(inner_f):
+        return None
+    SINGLETON_STRUCT, INNER_PUZZLE = list(args.as_iter())
+    return bytes32(Program(SINGLETON_STRUCT).rest().first().as_atom())
+
+
+def is_singleton(inner_f: Union[Program, SerializedProgram]) -> bool:
     """
     Check if a puzzle is a singleton mod
     :param inner_f: puzzle
@@ -52,7 +71,7 @@ def create_singleton_puzzle_hash(innerpuz_hash: bytes32, launcher_id: bytes32) -
     return curry_and_treehash(SINGLETON_TOP_LAYER_MOD_HASH_QUOTED, singleton_struct.get_tree_hash(), innerpuz_hash)
 
 
-def create_singleton_puzzle(innerpuz: Program, launcher_id: bytes32) -> Program:
+def create_singleton_puzzle(innerpuz: Union[Program, SerializedProgram], launcher_id: bytes32) -> Program:
     """
     Create a full Singleton puzzle
     :param innerpuz: Singleton inner puzzle
@@ -62,3 +81,11 @@ def create_singleton_puzzle(innerpuz: Program, launcher_id: bytes32) -> Program:
     # singleton_struct = (MOD_HASH . (LAUNCHER_ID . LAUNCHER_PUZZLE_HASH))
     singleton_struct = Program.to((SINGLETON_TOP_LAYER_MOD_HASH, (launcher_id, SINGLETON_LAUNCHER_PUZZLE_HASH)))
     return SINGLETON_TOP_LAYER_MOD.curry(singleton_struct, innerpuz)
+
+
+def get_most_recent_singleton_coin_from_coin_spend(coin_sol: CoinSpend) -> Optional[Coin]:
+    additions: List[Coin] = compute_additions(coin_sol)
+    for coin in additions:
+        if coin.amount % 2 == 1:
+            return coin
+    return None
diff --git a/chia/wallet/singleton_record.py b/chia/wallet/singleton_record.py
new file mode 100644
index 000000000..55cfd8df1
--- /dev/null
+++ b/chia/wallet/singleton_record.py
@@ -0,0 +1,30 @@
+from __future__ import annotations
+
+from dataclasses import dataclass
+from typing import Any, Optional
+
+from chia.types.blockchain_format.coin import Coin
+from chia.types.blockchain_format.sized_bytes import bytes32
+from chia.types.coin_spend import CoinSpend
+from chia.util.ints import uint32
+from chia.wallet.lineage_proof import LineageProof
+
+
+@dataclass(frozen=True)
+class SingletonRecord:
+    """
+    These are values that correspond to a singleton in the WalletSingletonStore
+    """
+
+    coin: Coin
+    singleton_id: bytes32
+    wallet_id: uint32
+    parent_coinspend: CoinSpend
+    inner_puzzle_hash: Optional[bytes32]
+    pending: bool
+    removed_height: int
+    lineage_proof: LineageProof
+    custom_data: Optional[Any]
+
+    def name(self) -> bytes32:
+        return self.coin.name()
diff --git a/chia/wallet/trade_manager.py b/chia/wallet/trade_manager.py
index 9599faaab..c7c2418f5 100644
--- a/chia/wallet/trade_manager.py
+++ b/chia/wallet/trade_manager.py
@@ -259,6 +259,12 @@ class TradeManager:
                     ignore_max_send_amount=True,
                 )
                 all_txs.append(tx)
+            elif wallet.type() == WalletType.CAT:
+                # ATTENTION: new_wallets
+                txs = await wallet.generate_signed_transactions(
+                    [coin.amount], [new_ph], fee=fee_to_pay, coins={coin}, ignore_max_send_amount=True
+                )
+                all_txs.extend(txs)
             else:
                 # ATTENTION: new_wallets
                 txs = await wallet.generate_signed_transaction(
@@ -340,6 +346,15 @@ class TradeManager:
                     if tx is not None and tx.spend_bundle is not None:
                         bundles.append(tx.spend_bundle)
                         all_txs.append(dataclasses.replace(tx, spend_bundle=None))
+                elif wallet.type() == WalletType.CAT:
+                    # ATTENTION: new_wallets
+                    txs = await wallet.generate_signed_transactions(
+                        [coin.amount], [new_ph], fee=fee_to_pay, coins={coin}, ignore_max_send_amount=True
+                    )
+                    for tx in txs:
+                        if tx is not None and tx.spend_bundle is not None:
+                            bundles.append(tx.spend_bundle)
+                            all_txs.append(dataclasses.replace(tx, spend_bundle=None))
                 else:
                     # ATTENTION: new_wallets
                     txs = await wallet.generate_signed_transaction(
@@ -601,6 +616,17 @@ class TradeManager:
                         reuse_puzhash=reuse_puzhash,
                     )
                     all_transactions.extend(txs)
+                elif wallet.type() == WalletType.CAT:
+                    # ATTENTION: new_wallets
+                    txs = await wallet.generate_signed_transactions(
+                        [abs(offer_dict[id])],
+                        [OFFER_MOD_OLD_HASH if old else Offer.ph()],
+                        fee=fee_left_to_pay,
+                        coins=set(selected_coins),
+                        puzzle_announcements_to_consume=announcements_to_assert,
+                        reuse_puzhash=reuse_puzhash,
+                    )
+                    all_transactions.extend(txs)
                 else:
                     # ATTENTION: new_wallets
                     txs = await wallet.generate_signed_transaction(
diff --git a/chia/wallet/util/debug_spend_bundle.py b/chia/wallet/util/debug_spend_bundle.py
index d670d1ab3..bde103d8c 100644
--- a/chia/wallet/util/debug_spend_bundle.py
+++ b/chia/wallet/util/debug_spend_bundle.py
@@ -70,7 +70,8 @@ def debug_spend_bundle(spend_bundle, agg_sig_additional_data=DEFAULT_CONSTANTS.A
             continue
 
         print(f"consuming coin {dump_coin(coin)}")
-        print(f"  with id {coin_name.hex()}")
+        print(f"  with id {coin_name}")
+        print(f"  ID in hex is {coin_name.hex()}")
         print()
         print(f"\nbrun -y main.sym '{bu_disassemble(puzzle_reveal)}' '{bu_disassemble(solution)}'")
         conditions = conditions_dict_for_solution(puzzle_reveal, solution, INFINITE_COST)
diff --git a/chia/wallet/util/wallet_types.py b/chia/wallet/util/wallet_types.py
index 08263bb63..73a44990e 100644
--- a/chia/wallet/util/wallet_types.py
+++ b/chia/wallet/util/wallet_types.py
@@ -26,6 +26,8 @@ class WalletType(IntEnum):
     DATA_LAYER = 11
     DATA_LAYER_OFFER = 12
     VC = 13
+    DAO = 14
+    DAO_CAT = 15
 
 
 class CoinType(IntEnum):
diff --git a/chia/wallet/wallet_coin_store.py b/chia/wallet/wallet_coin_store.py
index 72d29dd5f..4a6efdf34 100644
--- a/chia/wallet/wallet_coin_store.py
+++ b/chia/wallet/wallet_coin_store.py
@@ -29,7 +29,7 @@ class CoinRecordOrder(IntEnum):
 @dataclass(frozen=True)
 class GetCoinRecords(Streamable):
     offset: uint32 = uint32(0)
-    limit: uint32 = uint32.MAXIMUM
+    limit: uint32 = uint32(uint32.MAXIMUM_EXCLUSIVE - 1)
     wallet_id: Optional[uint32] = None
     wallet_type: Optional[uint8] = None  # WalletType
     coin_type: Optional[uint8] = None  # CoinType
@@ -188,7 +188,7 @@ class WalletCoinStore:
         self,
         *,
         offset: uint32 = uint32(0),
-        limit: uint32 = uint32.MAXIMUM,
+        limit: uint32 = uint32(uint32.MAXIMUM_EXCLUSIVE - 1),
         wallet_id: Optional[uint32] = None,
         wallet_type: Optional[WalletType] = None,
         coin_type: Optional[CoinType] = None,
@@ -237,7 +237,7 @@ class WalletCoinStore:
 
         where_sql = "WHERE " + " AND ".join(conditions) if len(conditions) > 0 else ""
         order_sql = f"ORDER BY {order.name} {'DESC' if reverse else 'ASC'}, rowid"
-        limit_sql = f"LIMIT {offset}, {limit}" if offset > 0 or limit < uint32.MAXIMUM else ""
+        limit_sql = f"LIMIT {offset}, {limit}" if offset > 0 or limit < uint32.MAXIMUM_EXCLUSIVE - 1 else ""
         query_sql = f"{where_sql} {order_sql} {limit_sql}"
 
         async with self.db_wrapper.reader_no_transaction() as conn:
diff --git a/chia/wallet/wallet_interested_store.py b/chia/wallet/wallet_interested_store.py
index a52cdcfd2..3bc2067f4 100644
--- a/chia/wallet/wallet_interested_store.py
+++ b/chia/wallet/wallet_interested_store.py
@@ -49,11 +49,6 @@ class WalletInterestedStore:
             cursor = await conn.execute("INSERT OR REPLACE INTO interested_coins VALUES (?)", (coin_id.hex(),))
             await cursor.close()
 
-    async def remove_interested_coin_id(self, coin_id: bytes32) -> None:
-        async with self.db_wrapper.writer_maybe_transaction() as conn:
-            cursor = await conn.execute("DELETE FROM interested_coins WHERE coin_name=?", (coin_id.hex(),))
-            await cursor.close()
-
     async def get_interested_puzzle_hashes(self) -> List[Tuple[bytes32, int]]:
         async with self.db_wrapper.reader_no_transaction() as conn:
             cursor = await conn.execute("SELECT puzzle_hash, wallet_id FROM interested_puzzle_hashes")
diff --git a/chia/wallet/wallet_singleton_store.py b/chia/wallet/wallet_singleton_store.py
new file mode 100644
index 000000000..5254d65cd
--- /dev/null
+++ b/chia/wallet/wallet_singleton_store.py
@@ -0,0 +1,230 @@
+from __future__ import annotations
+
+import json
+import logging
+from sqlite3 import Row
+from typing import List, Type, TypeVar
+
+from clvm.casts import int_from_bytes
+
+from chia.consensus.default_constants import DEFAULT_CONSTANTS
+from chia.types.blockchain_format.coin import Coin
+from chia.types.blockchain_format.sized_bytes import bytes32
+from chia.types.coin_spend import CoinSpend
+from chia.types.condition_opcodes import ConditionOpcode
+from chia.util.condition_tools import conditions_dict_for_solution
+from chia.util.db_wrapper import DBWrapper2
+from chia.util.ints import uint32
+from chia.wallet import singleton
+from chia.wallet.lineage_proof import LineageProof
+from chia.wallet.singleton import get_inner_puzzle_from_singleton, get_singleton_id_from_puzzle
+from chia.wallet.singleton_record import SingletonRecord
+
+log = logging.getLogger(__name__)
+_T_WalletSingletonStore = TypeVar("_T_WalletSingletonStore", bound="WalletSingletonStore")
+
+
+class WalletSingletonStore:
+    db_wrapper: DBWrapper2
+
+    @classmethod
+    async def create(cls: Type[_T_WalletSingletonStore], wrapper: DBWrapper2) -> _T_WalletSingletonStore:
+        self = cls()
+        self.db_wrapper = wrapper
+
+        async with self.db_wrapper.writer_maybe_transaction() as conn:
+            await conn.execute(
+                (
+                    "CREATE TABLE IF NOT EXISTS singletons("
+                    "coin_id blob PRIMARY KEY,"
+                    " coin text,"
+                    " singleton_id blob,"
+                    " wallet_id int,"
+                    " parent_coin_spend blob,"
+                    " inner_puzzle_hash blob,"
+                    " pending tinyint,"
+                    " removed_height int,"
+                    " lineage_proof blob,"
+                    " custom_data blob)"
+                )
+            )
+
+            await conn.execute("CREATE INDEX IF NOT EXISTS removed_height_index on singletons(removed_height)")
+
+        return self
+
+    async def save_singleton(self, record: SingletonRecord) -> None:
+        singleton_id = singleton.get_singleton_id_from_puzzle(record.parent_coinspend.puzzle_reveal)
+        if singleton_id is None:
+            raise RuntimeError(
+                "Failed to derive Singleton ID from puzzle reveal in parent spend %s", record.parent_coinspend
+            )
+        pending_int = 0
+        if record.pending:
+            pending_int = 1
+        async with self.db_wrapper.writer_maybe_transaction() as conn:
+            columns = (
+                "coin_id, coin, singleton_id, wallet_id, parent_coin_spend, inner_puzzle_hash, "
+                "pending, removed_height, lineage_proof, custom_data"
+            )
+            await conn.execute(
+                f"INSERT or REPLACE INTO singletons ({columns}) VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
+                (
+                    record.coin.name().hex(),
+                    json.dumps(record.coin.to_json_dict()),
+                    singleton_id.hex(),
+                    record.wallet_id,
+                    bytes(record.parent_coinspend),
+                    record.inner_puzzle_hash,
+                    pending_int,
+                    record.removed_height,
+                    bytes(record.lineage_proof),
+                    record.custom_data,
+                ),
+            )
+
+    async def add_spend(
+        self,
+        wallet_id: uint32,
+        coin_state: CoinSpend,
+        block_height: uint32 = uint32(0),
+        pending: bool = True,
+    ) -> None:
+        """Given a coin spend of a singleton, attempt to calculate the child coin and details
+        for the new singleton record. Add the new record to the store and remove the old record
+        if it exists
+        """
+        # get singleton_id from puzzle_reveal
+        singleton_id = get_singleton_id_from_puzzle(coin_state.puzzle_reveal)
+        if not singleton_id:
+            raise RuntimeError("Coin to add is not a valid singleton")
+
+        # get details for singleton record
+        conditions = conditions_dict_for_solution(
+            coin_state.puzzle_reveal.to_program(),
+            coin_state.solution.to_program(),
+            DEFAULT_CONSTANTS.MAX_BLOCK_COST_CLVM,
+        )
+        if conditions is None:
+            raise RuntimeError("Failed to add spend for coin: %s ", coin_state.coin.name())
+
+        cc_cond = [cond for cond in conditions[ConditionOpcode.CREATE_COIN] if int_from_bytes(cond.vars[1]) % 2 == 1][0]
+
+        coin = Coin(coin_state.coin.name(), cc_cond.vars[0], int_from_bytes(cc_cond.vars[1]))
+        inner_puz = get_inner_puzzle_from_singleton(coin_state.puzzle_reveal)
+        if inner_puz is None:
+            raise RuntimeError("Could not get inner puzzle from puzzle reveal in coin spend %s", coin_state)
+
+        lineage_bytes = [x.as_atom() for x in coin_state.solution.to_program().first().as_iter()]
+        if len(lineage_bytes) == 2:
+            lineage_proof = LineageProof(lineage_bytes[0], None, int_from_bytes(lineage_bytes[1]))
+        else:
+            lineage_proof = LineageProof(lineage_bytes[0], lineage_bytes[1], int_from_bytes(lineage_bytes[2]))
+        # Create and save the new singleton record
+        new_record = SingletonRecord(
+            coin, singleton_id, wallet_id, coin_state, inner_puz.get_tree_hash(), pending, 0, lineage_proof, None
+        )
+        await self.save_singleton(new_record)
+        # check if coin is in DB and mark deleted if found
+        current_records = await self.get_records_by_coin_id(coin_state.coin.name())
+        if len(current_records) > 0:
+            await self.delete_singleton_by_coin_id(coin_state.coin.name(), block_height)
+        return
+
+    def _to_singleton_record(self, row: Row) -> SingletonRecord:
+        return SingletonRecord(
+            coin=Coin.from_json_dict(json.loads(row[1])),
+            singleton_id=bytes32.from_hexstr(row[2]),
+            wallet_id=uint32(row[3]),
+            parent_coinspend=CoinSpend.from_bytes(row[4]),
+            inner_puzzle_hash=bytes32.from_bytes(row[5]),  # inner puz hash
+            pending=True if row[6] == 1 else False,
+            removed_height=uint32(row[7]),
+            lineage_proof=LineageProof.from_bytes(row[8]),
+            custom_data=row[9],
+        )
+
+    async def delete_singleton_by_singleton_id(self, singleton_id: bytes32, height: uint32) -> bool:
+        """Tries to mark a given singleton as deleted at specific height
+
+        This is due to how re-org works
+        Returns `True` if singleton was found and marked deleted or `False` if not."""
+        async with self.db_wrapper.writer_maybe_transaction() as conn:
+            # Remove NFT in the users_nfts table
+            cursor = await conn.execute(
+                "UPDATE singletons SET removed_height=? WHERE singleton_id=?", (int(height), singleton_id.hex())
+            )
+            return cursor.rowcount > 0
+
+    async def delete_singleton_by_coin_id(self, coin_id: bytes32, height: uint32) -> bool:
+        """Tries to mark a given singleton as deleted at specific height
+
+        This is due to how re-org works
+        Returns `True` if singleton was found and marked deleted or `False` if not."""
+        async with self.db_wrapper.writer_maybe_transaction() as conn:
+            # Remove NFT in the users_nfts table
+            cursor = await conn.execute(
+                "UPDATE singletons SET removed_height=? WHERE coin_id=?", (int(height), coin_id.hex())
+            )
+            if cursor.rowcount > 0:
+                log.info("Deleted singleton with coin id: %s", coin_id.hex())
+                return True
+            log.warning("Couldn't find singleton with coin id to delete: %s", coin_id)
+            return False
+
+    async def update_pending_transaction(self, coin_id: bytes32, pending: bool) -> bool:
+        async with self.db_wrapper.writer_maybe_transaction() as conn:
+            c = await conn.execute(
+                "UPDATE singletons SET pending=? WHERE coin_id = ?",
+                (pending, coin_id.hex()),
+            )
+            return c.rowcount > 0
+
+    async def get_records_by_wallet_id(self, wallet_id: int) -> List[SingletonRecord]:
+        """
+        Retrieves all entries for a wallet ID.
+        """
+
+        async with self.db_wrapper.reader_no_transaction() as conn:
+            rows = await conn.execute_fetchall(
+                "SELECT * FROM singletons WHERE wallet_id = ? ORDER BY removed_height",
+                (wallet_id,),
+            )
+        return [self._to_singleton_record(row) for row in rows]
+
+    async def get_records_by_coin_id(self, coin_id: bytes32) -> List[SingletonRecord]:
+        """
+        Retrieves all entries for a coin ID.
+        """
+
+        async with self.db_wrapper.reader_no_transaction() as conn:
+            rows = await conn.execute_fetchall(
+                "SELECT * FROM singletons WHERE coin_id = ?",
+                (coin_id.hex(),),
+            )
+        return [self._to_singleton_record(row) for row in rows]
+
+    async def get_records_by_singleton_id(self, singleton_id: bytes32) -> List[SingletonRecord]:
+        """
+        Retrieves all entries for a singleton ID.
+        """
+
+        async with self.db_wrapper.reader_no_transaction() as conn:
+            rows = await conn.execute_fetchall(
+                "SELECT * FROM singletons WHERE singleton_id = ? ORDER BY removed_height",
+                (singleton_id.hex(),),
+            )
+        return [self._to_singleton_record(row) for row in rows]
+
+    async def rollback(self, height: int, wallet_id_arg: int) -> None:
+        """
+        Rollback removes all entries which have entry_height > height passed in. Note that this is not committed to the
+        DB until db_wrapper.commit() is called. However, it is written to the cache, so it can be fetched with
+        get_all_state_transitions.
+        """
+
+        async with self.db_wrapper.writer_maybe_transaction() as conn:
+            cursor = await conn.execute(
+                "DELETE FROM singletons WHERE removed_height>? AND wallet_id=?", (height, wallet_id_arg)
+            )
+            await cursor.close()
diff --git a/chia/wallet/wallet_state_manager.py b/chia/wallet/wallet_state_manager.py
index b5b340813..915162d5d 100644
--- a/chia/wallet/wallet_state_manager.py
+++ b/chia/wallet/wallet_state_manager.py
@@ -8,7 +8,20 @@ import traceback
 from contextlib import asynccontextmanager
 from pathlib import Path
 from secrets import token_bytes
-from typing import TYPE_CHECKING, Any, AsyncIterator, Callable, Dict, Iterator, List, Optional, Set, Type, TypeVar
+from typing import (
+    TYPE_CHECKING,
+    Any,
+    AsyncIterator,
+    Callable,
+    Dict,
+    Iterator,
+    List,
+    Optional,
+    Set,
+    Type,
+    TypeVar,
+    Union,
+)
 
 import aiosqlite
 from blspy import G1Element, G2Element, PrivateKey
@@ -49,6 +62,15 @@ from chia.util.path import path_from_root
 from chia.wallet.cat_wallet.cat_constants import DEFAULT_CATS
 from chia.wallet.cat_wallet.cat_utils import CAT_MOD, CAT_MOD_HASH, construct_cat_puzzle, match_cat_puzzle
 from chia.wallet.cat_wallet.cat_wallet import CATWallet
+from chia.wallet.cat_wallet.dao_cat_wallet import DAOCATWallet
+from chia.wallet.dao_wallet.dao_utils import (
+    get_new_puzzle_from_treasury_solution,
+    match_dao_cat_puzzle,
+    match_funding_puzzle,
+    match_proposal_puzzle,
+    match_treasury_puzzle,
+)
+from chia.wallet.dao_wallet.dao_wallet import DAOWallet
 from chia.wallet.db_wallet.db_wallet_puzzles import MIRROR_PUZZLE_HASH
 from chia.wallet.derivation_record import DerivationRecord
 from chia.wallet.derive_keys import (
@@ -71,7 +93,7 @@ from chia.wallet.payment import Payment
 from chia.wallet.puzzle_drivers import PuzzleInfo
 from chia.wallet.puzzles.clawback.drivers import generate_clawback_spend_bundle, match_clawback_puzzle
 from chia.wallet.puzzles.clawback.metadata import ClawbackMetadata, ClawbackVersion
-from chia.wallet.singleton import create_singleton_puzzle
+from chia.wallet.singleton import create_singleton_puzzle, get_singleton_id_from_puzzle
 from chia.wallet.trade_manager import TradeManager
 from chia.wallet.trading.trade_status import TradeStatus
 from chia.wallet.transaction_record import TransactionRecord
@@ -86,6 +108,7 @@ from chia.wallet.util.wallet_sync_utils import (
     PeerRequestException,
     fetch_coin_spend_for_coin_state,
     last_change_height_cs,
+    subscribe_to_coin_updates,
 )
 from chia.wallet.util.wallet_types import CoinType, WalletIdentifier, WalletType
 from chia.wallet.vc_wallet.vc_drivers import VerifiedCredential
@@ -102,6 +125,7 @@ from chia.wallet.wallet_pool_store import WalletPoolStore
 from chia.wallet.wallet_protocol import WalletProtocol
 from chia.wallet.wallet_puzzle_store import WalletPuzzleStore
 from chia.wallet.wallet_retry_store import WalletRetryStore
+from chia.wallet.wallet_singleton_store import WalletSingletonStore
 from chia.wallet.wallet_transaction_store import WalletTransactionStore
 from chia.wallet.wallet_user_store import WalletUserStore
 
@@ -115,6 +139,8 @@ PendingTxCallback = Callable[[], None]
 
 
 class WalletStateManager:
+    interested_ph_cache: Dict[bytes32, List[int]] = {}
+    interested_coin_cache: Dict[bytes32, List[int]] = {}
     constants: ConsensusConstants
     config: Dict[str, Any]
     tx_store: WalletTransactionStore
@@ -153,6 +179,7 @@ class WalletStateManager:
     wallet_node: WalletNode
     pool_store: WalletPoolStore
     dl_store: DataLayerStore
+    singleton_store: WalletSingletonStore
     default_cats: Dict[str, Any]
     asset_to_wallet_map: Dict[AssetType, Any]
     initial_num_public_keys: int
@@ -169,6 +196,7 @@ class WalletStateManager:
         wallet_node: WalletNode,
     ) -> WalletStateManager:
         self = WalletStateManager()
+
         self.config = config
         self.constants = constants
         self.server = server
@@ -207,6 +235,7 @@ class WalletStateManager:
         self.dl_store = await DataLayerStore.create(self.db_wrapper)
         self.interested_store = await WalletInterestedStore.create(self.db_wrapper)
         self.retry_store = await WalletRetryStore.create(self.db_wrapper)
+        self.singleton_store = await WalletSingletonStore.create(self.db_wrapper)
         self.default_cats = DEFAULT_CATS
 
         self.wallet_node = wallet_node
@@ -262,7 +291,22 @@ class WalletStateManager:
                     wallet_info,
                 )
             elif wallet_type == WalletType.DATA_LAYER:
-                wallet = await DataLayerWallet.create(self, wallet_info)
+                wallet = await DataLayerWallet.create(
+                    self,
+                    wallet_info,
+                )
+            elif wallet_type == WalletType.DAO:
+                wallet = await DAOWallet.create(
+                    self,
+                    self.main_wallet,
+                    wallet_info,
+                )
+            elif wallet_type == WalletType.DAO_CAT:
+                wallet = await DAOCATWallet.create(
+                    self,
+                    self.main_wallet,
+                    wallet_info,
+                )
             elif wallet_type == WalletType.VC:  # pragma: no cover
                 wallet = await VCWallet.create(
                     self,
@@ -647,7 +691,6 @@ class WalletStateManager:
             or self.is_farmer_reward(uint32(coin_state.created_height), coin_state.coin)
         ):
             return None
-
         response: List[CoinState] = await self.wallet_node.get_coin_state(
             [coin_state.coin.parent_coin_info], peer=peer, fork_height=fork_height
         )
@@ -662,9 +705,27 @@ class WalletStateManager:
             return None
 
         puzzle = Program.from_bytes(bytes(coin_spend.puzzle_reveal))
+        solution = Program.from_bytes(bytes(coin_spend.solution))
 
         uncurried = uncurry_puzzle(puzzle)
 
+        # Check if the coin is a DAO Treasury
+        dao_curried_args = match_treasury_puzzle(uncurried.mod, uncurried.args)
+        if dao_curried_args is not None:
+            return await self.handle_dao_treasury(dao_curried_args, parent_coin_state, coin_state, coin_spend)
+        # Check if the coin is a Proposal and that it isn't the timer coin (amount == 0)
+        dao_curried_args = match_proposal_puzzle(uncurried.mod, uncurried.args)
+        if (dao_curried_args is not None) and (coin_state.coin.amount != 0):
+            return await self.handle_dao_proposal(dao_curried_args, parent_coin_state, coin_state, coin_spend)
+        # Check if the coin is a DAO CAT
+        dao_cat_args = match_dao_cat_puzzle(uncurried)
+        if dao_cat_args:
+            return await self.handle_dao_cat(dao_cat_args, parent_coin_state, coin_state, coin_spend)
+
+        funding_puzzle_check = match_funding_puzzle(uncurried, solution)
+        if funding_puzzle_check:
+            return await self.get_dao_wallet_from_coinspend_hint(coin_spend)
+
         # Check if the coin is a CAT
         cat_curried_args = match_cat_puzzle(uncurried)
         if cat_curried_args is not None:
@@ -776,6 +837,8 @@ class WalletStateManager:
                 )
                 coin_spend: CoinSpend = generate_clawback_spend_bundle(coin, metadata, inner_puzzle, inner_solution)
                 coin_spends.append(coin_spend)
+                # Update incoming tx to prevent double spend and mark it is pending
+                await self.tx_store.increment_sent(incoming_tx.name, "", MempoolInclusionStatus.PENDING, None)
             except Exception as e:
                 self.log.error(f"Failed to create clawback spend bundle for {coin.name().hex()}: {e}")
         if len(coin_spends) == 0:
@@ -807,9 +870,6 @@ class WalletStateManager:
             memos=list(compute_memos(spend_bundle).items()),
         )
         await self.add_pending_transaction(tx_record)
-        # Update incoming tx to prevent double spend and mark it is pending
-        for coin_spend in coin_spends:
-            await self.tx_store.increment_sent(coin_spend.coin.name(), "", MempoolInclusionStatus.PENDING, None)
         return [tx_record.name]
 
     async def filter_spam(self, new_coin_state: List[CoinState]) -> List[CoinState]:
@@ -846,6 +906,25 @@ class WalletStateManager:
         wallet_identifier = await self.get_wallet_identifier_for_puzzle_hash(coin_state.coin.puzzle_hash)
         return wallet_identifier is not None and wallet_identifier.type == WalletType.STANDARD_WALLET
 
+    async def handle_dao_cat(
+        self,
+        curried_args: Iterator[Program],
+        parent_coin_state: CoinState,
+        coin_state: CoinState,
+        coin_spend: CoinSpend,
+    ) -> Optional[WalletIdentifier]:
+        """
+        Handle the new coin when it is a DAO CAT
+        """
+        mod_hash, tail_hash, inner_puzzle = curried_args
+        asset_id: bytes32 = bytes32(bytes(tail_hash)[1:])
+        for wallet in self.wallets.values():
+            if wallet.type() == WalletType.DAO_CAT:
+                assert isinstance(wallet, DAOCATWallet)
+                if wallet.dao_cat_info.limitations_program_hash == asset_id:
+                    return WalletIdentifier.create(wallet)
+        return None
+
     async def handle_cat(
         self,
         curried_args: Iterator[Program],
@@ -871,7 +950,6 @@ class WalletStateManager:
             derivation_record = await self.puzzle_store.get_derivation_record_for_puzzle_hash(bytes32(hint))
             if derivation_record is not None:
                 break
-
         if derivation_record is None:
             self.log.info(f"Received state for the coin that doesn't belong to us {coin_state}")
             return None
@@ -936,6 +1014,7 @@ class WalletStateManager:
         if derivation_record is None:
             self.log.info(f"Received state for the coin that doesn't belong to us {coin_state}")
             # Check if it was owned by us
+            # If the puzzle inside is no longer recognised then delete the wallet associated
             removed_wallet_ids = []
             for wallet in self.wallets.values():
                 if not isinstance(wallet, DIDWallet):
@@ -1033,6 +1112,74 @@ class WalletStateManager:
                 minter_did = bytes32(bytes(singleton_struct.rest().first())[1:])
         return minter_did
 
+    async def handle_dao_treasury(
+        self,
+        uncurried_args: Iterator[Program],
+        parent_coin_state: CoinState,
+        coin_state: CoinState,
+        coin_spend: CoinSpend,
+    ) -> Optional[WalletIdentifier]:
+        self.log.info("Entering dao_treasury handling in WalletStateManager")
+        singleton_id = get_singleton_id_from_puzzle(coin_spend.puzzle_reveal)
+        for wallet in self.wallets.values():
+            if wallet.type() == WalletType.DAO:
+                assert isinstance(wallet, DAOWallet)
+                if wallet.dao_info.treasury_id == singleton_id:
+                    return WalletIdentifier.create(wallet)
+
+        inner_puzzle = get_new_puzzle_from_treasury_solution(
+            coin_spend.puzzle_reveal.to_program(), coin_spend.solution.to_program()
+        )
+        # If we can't find the wallet for this DAO but we've got here because we're subscribed, then create the wallet
+        assert isinstance(inner_puzzle, Program)
+        assert isinstance(singleton_id, bytes32)
+        dao_wallet = await DAOWallet.create_new_dao_wallet_for_existing_dao(
+            self,
+            self.main_wallet,
+            singleton_id,
+        )
+        assert dao_wallet is not None
+        return None
+
+    async def handle_dao_proposal(
+        self,
+        uncurried_args: Iterator[Program],
+        parent_coin_state: CoinState,
+        coin_state: CoinState,
+        coin_spend: CoinSpend,
+    ) -> Optional[WalletIdentifier]:
+        (
+            SINGLETON_STRUCT,  # (SINGLETON_MOD_HASH, (SINGLETON_ID, LAUNCHER_PUZZLE_HASH))
+            PROPOSAL_MOD_HASH,
+            PROPOSAL_TIMER_MOD_HASH,
+            CAT_MOD_HASH,
+            TREASURY_MOD_HASH,
+            LOCKUP_MOD_HASH,
+            CAT_TAIL_HASH,
+            TREASURY_ID,
+            YES_VOTES,  # yes votes are +1, no votes don't tally - we compare yes_votes/total_votes at the end
+            TOTAL_VOTES,  # how many people responded
+            INNERPUZHASH,
+        ) = uncurried_args
+        for wallet in self.wallets.values():
+            if wallet.type() == WalletType.DAO:
+                assert isinstance(wallet, DAOWallet)
+                if wallet.dao_info.treasury_id == TREASURY_ID.as_atom():
+                    assert isinstance(coin_state.created_height, int)
+                    await wallet.add_or_update_proposal_info(coin_spend, uint32(coin_state.created_height))
+                    return WalletIdentifier.create(wallet)
+        return None
+
+    async def get_dao_wallet_from_coinspend_hint(self, coin_spend: CoinSpend) -> Optional[WalletIdentifier]:
+        hint_list = compute_coin_hints(coin_spend)
+        if hint_list:
+            for wallet in self.wallets.values():
+                if wallet.type() == WalletType.DAO.value:
+                    assert isinstance(wallet, DAOWallet)
+                    if wallet.dao_info.treasury_id in hint_list:
+                        return WalletIdentifier.create(wallet)
+        return None
+
     async def handle_nft(
         self, coin_spend: CoinSpend, uncurried_nft: UncurriedNFT, parent_coin_state: CoinState, coin_state: CoinState
     ) -> Optional[WalletIdentifier]:
@@ -1159,7 +1306,7 @@ class WalletStateManager:
             self.log.info("Found Clawback merkle coin %s as the recipient.", coin_state.coin.name().hex())
             is_recipient = True
             # For the recipient we need to manually subscribe the merkle coin
-            await self.add_interested_coin_ids([coin_state.coin.name()])
+            await subscribe_to_coin_updates([coin_state.coin.name()], peer, uint32(0))
         if is_recipient is not None:
             spend_bundle = SpendBundle([coin_spend], G2Element())
             memos = compute_memos(spend_bundle)
@@ -1185,9 +1332,9 @@ class WalletStateManager:
                 to_puzzle_hash=metadata.recipient_puzzle_hash,
                 amount=uint64(coin_state.coin.amount),
                 fee_amount=uint64(0),
-                confirmed=False,
+                confirmed=True,
                 sent=uint32(0),
-                spend_bundle=None,
+                spend_bundle=spend_bundle,
                 additions=[coin_state.coin],
                 removals=[coin_spend.coin],
                 wallet_id=uint32(1),
@@ -1452,23 +1599,13 @@ class WalletStateManager:
                                     await self.tx_store.add_transaction_record(tx_record)
                         else:
                             await self.coin_store.set_spent(coin_name, uint32(coin_state.spent_height))
-                            if record.coin_type == CoinType.CLAWBACK:
-                                await self.interested_store.remove_interested_coin_id(coin_state.coin.name())
-                            confirmed_tx_records: List[TransactionRecord] = []
+                            rem_tx_records: List[TransactionRecord] = []
                             for tx_record in all_unconfirmed:
-                                if tx_record.type in {
-                                    TransactionType.INCOMING_CLAWBACK_SEND.value,
-                                    TransactionType.INCOMING_CLAWBACK_RECEIVE.value,
-                                }:
-                                    for add_coin in tx_record.additions:
-                                        if add_coin == coin_state.coin:
-                                            confirmed_tx_records.append(tx_record)
-                                else:
-                                    for rem_coin in tx_record.removals:
-                                        if rem_coin == coin_state.coin:
-                                            confirmed_tx_records.append(tx_record)
+                                for rem_coin in tx_record.removals:
+                                    if rem_coin == coin_state.coin:
+                                        rem_tx_records.append(tx_record)
 
-                            for tx_record in confirmed_tx_records:
+                            for tx_record in rem_tx_records:
                                 await self.tx_store.set_confirmed(tx_record.name, uint32(coin_state.spent_height))
                         for unconfirmed_record in all_unconfirmed:
                             for rem_coin in unconfirmed_record.removals:
@@ -1478,14 +1615,17 @@ class WalletStateManager:
                                         unconfirmed_record.name, uint32(coin_state.spent_height)
                                     )
 
-                        if record.wallet_type == WalletType.POOLING_WALLET:
+                        if record.wallet_type in [WalletType.POOLING_WALLET, WalletType.DAO]:
+                            wallet_type_to_class = {WalletType.POOLING_WALLET: PoolWallet, WalletType.DAO: DAOWallet}
                             if coin_state.spent_height is not None and coin_state.coin.amount == uint64(1):
-                                pool_wallet = self.get_wallet(id=uint32(record.wallet_id), required_type=PoolWallet)
+                                singleton_wallet: Union[PoolWallet, DAOWallet] = self.get_wallet(
+                                    id=uint32(record.wallet_id), required_type=wallet_type_to_class[record.wallet_type]
+                                )
                                 curr_coin_state: CoinState = coin_state
 
                                 while curr_coin_state.spent_height is not None:
-                                    cs = await fetch_coin_spend_for_coin_state(curr_coin_state, peer)
-                                    success = await pool_wallet.apply_state_transition(
+                                    cs: CoinSpend = await fetch_coin_spend_for_coin_state(curr_coin_state, peer)
+                                    success = await singleton_wallet.apply_state_transition(
                                         cs, uint32(curr_coin_state.spent_height)
                                     )
                                     if not success:
@@ -1537,7 +1677,7 @@ class WalletStateManager:
                         for child in children:
                             if child.coin.puzzle_hash != SINGLETON_LAUNCHER_HASH:
                                 continue
-                            if await self.have_a_pool_wallet_with_launched_id(child.coin.name()):
+                            if await self.have_a_pool_wallet_with_launched_id(child.coin.name()):  # xxx
                                 continue
                             if child.spent_height is None:
                                 # TODO handle spending launcher later block
@@ -1575,7 +1715,7 @@ class WalletStateManager:
                                 self.log.debug("solution_to_pool_state returned None, ignore and continue")
                                 continue
 
-                            pool_wallet = await PoolWallet.create(
+                            pool_wallet = await PoolWallet.create(  # xxx TODO ctrl-f pool_wallet
                                 self,
                                 self.main_wallet,
                                 child.coin.name(),
@@ -1747,10 +1887,14 @@ class WalletStateManager:
         coin_record: WalletCoinRecord = WalletCoinRecord(
             coin, height, uint32(0), False, coinbase, wallet_type, wallet_id
         )
+
         await self.coin_store.add_coin_record(coin_record, coin_name)
 
         await self.wallets[wallet_id].coin_added(coin, height, peer)
 
+        if wallet_type == WalletType.DAO:
+            return
+
         await self.create_more_puzzle_hashes()
 
     async def add_pending_transaction(self, tx_record: TransactionRecord) -> None:
@@ -1974,22 +2118,43 @@ class WalletStateManager:
         return filtered
 
     async def new_peak(self, peak: NewPeakWallet) -> None:
+        valid_list = [WalletType.POOLING_WALLET, WalletType.DAO]
         for wallet_id, wallet in self.wallets.items():
-            if wallet.type() == WalletType.POOLING_WALLET:
-                assert isinstance(wallet, PoolWallet)
-                await wallet.new_peak(uint64(peak.height))
+            if wallet.type() in valid_list:
+                valid = isinstance(wallet, PoolWallet) or isinstance(wallet, DAOWallet)
+                assert valid
+                await wallet.new_peak(uint64(peak.height))  # type: ignore[attr-defined]
         current_time = int(time.time())
 
         if self.wallet_node.last_wallet_tx_resend_time < current_time - self.wallet_node.wallet_tx_resend_timeout_secs:
             self.tx_pending_changed()
 
     async def add_interested_puzzle_hashes(self, puzzle_hashes: List[bytes32], wallet_ids: List[int]) -> None:
+        # TODO: It's unclear if the intended use for this is that each puzzle hash should store all
+        # the elements of wallet_ids. It only stores one wallet_id per puzzle hash in the interested_store
+        # but the coin_cache keeps all wallet_ids for each puzzle hash
+        for puzzle_hash in puzzle_hashes:
+            if puzzle_hash in self.interested_coin_cache:
+                wallet_ids_to_add = list(
+                    set([w for w in wallet_ids if w not in self.interested_coin_cache[puzzle_hash]])
+                )
+                self.interested_coin_cache[puzzle_hash].extend(wallet_ids_to_add)
+            else:
+                self.interested_coin_cache[puzzle_hash] = list(set(wallet_ids))
         for puzzle_hash, wallet_id in zip(puzzle_hashes, wallet_ids):
             await self.interested_store.add_interested_puzzle_hash(puzzle_hash, wallet_id)
         if len(puzzle_hashes) > 0:
             await self.wallet_node.new_peak_queue.subscribe_to_puzzle_hashes(puzzle_hashes)
 
-    async def add_interested_coin_ids(self, coin_ids: List[bytes32]) -> None:
+    async def add_interested_coin_ids(self, coin_ids: List[bytes32], wallet_ids: List[int] = []) -> None:
+        # TODO: FIX: wallet_ids is sometimes populated unexpectedly when called from add_pending_transaction
+        for coin_id in coin_ids:
+            if coin_id in self.interested_coin_cache:
+                # prevent repeated wallet_ids from appearing in the coin cache
+                wallet_ids_to_add = list(set([w for w in wallet_ids if w not in self.interested_coin_cache[coin_id]]))
+                self.interested_coin_cache[coin_id].extend(wallet_ids_to_add)
+            else:
+                self.interested_coin_cache[coin_id] = list(set(wallet_ids))
         for coin_id in coin_ids:
             await self.interested_store.add_interested_coin_id(coin_id)
         if len(coin_ids) > 0:
diff --git a/pytest.ini b/pytest.ini
index 87e2b1521..fb40b4ab8 100644
--- a/pytest.ini
+++ b/pytest.ini
@@ -2,7 +2,7 @@
 ; logging options
 log_cli = False
 addopts = --verbose --tb=short -n auto -p no:monitor
-log_level = WARNING
+log_level = INFO
 console_output_style = count
 log_format = %(asctime)s %(name)s: %(levelname)s %(message)s
 asyncio_mode = strict
diff --git a/state.json b/state.json
new file mode 100644
index 000000000..b72f2ae3d
--- /dev/null
+++ b/state.json
@@ -0,0 +1 @@
+{"daos": [ {"dao_id": "84e0c0eafaa95a34c293f278ac52e45ce537bab5e752a00e6959a13ae103b65a", "dao_name": "Meta DAO"}, {"dao_id": "0d6ba19b62531ccb0deb8804313eca283c69560f66f1b7b8a2c1592ae8c35c6b", "dao_name": "Chia Corporate DAO"}]}
diff --git a/tests/core/custom_types/test_proof_of_space.py b/tests/core/custom_types/test_proof_of_space.py
index 7ba1df432..2546f65ad 100644
--- a/tests/core/custom_types/test_proof_of_space.py
+++ b/tests/core/custom_types/test_proof_of_space.py
@@ -1,108 +1,10 @@
 from __future__ import annotations
 
-from dataclasses import dataclass
 from secrets import token_bytes
-from typing import Optional
-
-import pytest
-from blspy import G1Element
 
 from chia.consensus.default_constants import DEFAULT_CONSTANTS
-from chia.types.blockchain_format.proof_of_space import ProofOfSpace, passes_plot_filter, verify_and_get_quality_string
-from chia.types.blockchain_format.sized_bytes import bytes32, bytes48
-from chia.util.ints import uint8
-from tests.util.misc import Marks, datacases
-
-
-@dataclass
-class ProofOfSpaceCase:
-    id: str
-    pos_challenge: bytes32
-    plot_size: uint8
-    plot_public_key: G1Element
-    pool_public_key: Optional[G1Element] = None
-    pool_contract_puzzle_hash: Optional[bytes32] = None
-    expected_error: Optional[str] = None
-    marks: Marks = ()
-
-
-@datacases(
-    ProofOfSpaceCase(
-        id="Neither pool public key nor pool contract puzzle hash",
-        pos_challenge=bytes32(b"1" * 32),
-        plot_size=uint8(0),
-        plot_public_key=G1Element(),
-        expected_error="Expected pool public key or pool contract puzzle hash but got neither",
-    ),
-    ProofOfSpaceCase(
-        id="Both pool public key and pool contract puzzle hash",
-        pos_challenge=bytes32(b"1" * 32),
-        plot_size=uint8(0),
-        plot_public_key=G1Element(),
-        pool_public_key=G1Element(),
-        pool_contract_puzzle_hash=bytes32(b"1" * 32),
-        expected_error="Expected pool public key or pool contract puzzle hash but got both",
-    ),
-    ProofOfSpaceCase(
-        id="Lower than minimum plot size",
-        pos_challenge=bytes32(b"1" * 32),
-        plot_size=uint8(31),
-        plot_public_key=G1Element(),
-        pool_public_key=G1Element(),
-        expected_error="Plot size is lower than the minimum",
-    ),
-    ProofOfSpaceCase(
-        id="Higher than maximum plot size",
-        pos_challenge=bytes32(b"1" * 32),
-        plot_size=uint8(51),
-        plot_public_key=G1Element(),
-        pool_public_key=G1Element(),
-        expected_error="Plot size is higher than the maximum",
-    ),
-    ProofOfSpaceCase(
-        id="Different challenge",
-        pos_challenge=bytes32(b"1" * 32),
-        plot_size=uint8(42),
-        pool_public_key=G1Element(),
-        plot_public_key=G1Element(),
-        expected_error="Calculated pos challenge doesn't match the provided one",
-    ),
-    ProofOfSpaceCase(
-        id="Not passing the plot filter",
-        pos_challenge=bytes32.from_hexstr("08b23cc2844dfb92d2eedaa705a1ce665d571ee753bd81cbb67b92caa6d34722"),
-        plot_size=uint8(42),
-        pool_public_key=G1Element.from_bytes_unchecked(
-            bytes48.from_hexstr(
-                "b6449c2c68df97c19e884427e42ee7350982d4020571ead08732615ff39bd216bfd630b6460784982bec98b49fea79d0"
-            )
-        ),
-        plot_public_key=G1Element.from_bytes_unchecked(
-            bytes48.from_hexstr(
-                "b17d368f5400230b2b01464807825bf4163c5c159bd7d4465f935912e538ac9fb996dd9a9c479bd8aa6256bdca1fed96"
-            )
-        ),
-        expected_error="Did not pass the plot filter",
-    ),
-)
-def test_verify_and_get_quality_string(caplog: pytest.LogCaptureFixture, case: ProofOfSpaceCase) -> None:
-    pos = ProofOfSpace(
-        challenge=case.pos_challenge,
-        pool_public_key=case.pool_public_key,
-        pool_contract_puzzle_hash=case.pool_contract_puzzle_hash,
-        plot_public_key=case.plot_public_key,
-        size=case.plot_size,
-        proof=b"1",
-    )
-    quality_string = verify_and_get_quality_string(
-        pos=pos,
-        constants=DEFAULT_CONSTANTS,
-        original_challenge_hash=bytes32.from_hexstr(
-            "0x73490e166d0b88347c37d921660b216c27316aae9a3450933d3ff3b854e5831a"
-        ),
-        signage_point=bytes32.from_hexstr("0x7b3e23dbd438f9aceefa9827e2c5538898189987f49b06eceb7a43067e77b531"),
-    )
-    assert quality_string is None
-    assert len(caplog.text) == 0 if case.expected_error is None else case.expected_error in caplog.text
+from chia.types.blockchain_format.proof_of_space import passes_plot_filter
+from chia.types.blockchain_format.sized_bytes import bytes32
 
 
 class TestProofOfSpace:
diff --git a/tests/core/full_node/stores/test_coin_store.py b/tests/core/full_node/stores/test_coin_store.py
index e4f654ffa..c31d5b5a1 100644
--- a/tests/core/full_node/stores/test_coin_store.py
+++ b/tests/core/full_node/stores/test_coin_store.py
@@ -446,24 +446,6 @@ class TestCoinStoreWithBlocks:
             assert len(await coin_store.get_coin_states_by_ids(True, coins, 300)) == 302
             assert len(await coin_store.get_coin_states_by_ids(True, coins, 603)) == 0
             assert len(await coin_store.get_coin_states_by_ids(True, bad_coins, 0)) == 0
-            # Test max_height
-            assert len(await coin_store.get_coin_states_by_ids(True, coins, max_height=uint32(603))) == 600
-            assert len(await coin_store.get_coin_states_by_ids(True, coins, max_height=uint32(602))) == 600
-            assert len(await coin_store.get_coin_states_by_ids(True, coins, max_height=uint32(599))) == 598
-            assert len(await coin_store.get_coin_states_by_ids(True, coins, max_height=uint32(400))) == 400
-            assert len(await coin_store.get_coin_states_by_ids(True, coins, max_height=uint32(301))) == 300
-            assert len(await coin_store.get_coin_states_by_ids(True, coins, max_height=uint32(300))) == 300
-            assert len(await coin_store.get_coin_states_by_ids(True, coins, max_height=uint32(299))) == 298
-            assert len(await coin_store.get_coin_states_by_ids(True, coins, max_height=uint32(0))) == 0
-            # Test min_height + max_height
-            assert len(await coin_store.get_coin_states_by_ids(True, coins, uint32(300), max_height=uint32(603))) == 302
-            assert len(await coin_store.get_coin_states_by_ids(True, coins, uint32(300), max_height=uint32(602))) == 302
-            assert len(await coin_store.get_coin_states_by_ids(True, coins, uint32(300), max_height=uint32(599))) == 300
-            assert len(await coin_store.get_coin_states_by_ids(True, coins, uint32(300), max_height=uint32(400))) == 102
-            assert len(await coin_store.get_coin_states_by_ids(True, coins, uint32(300), max_height=uint32(301))) == 2
-            assert len(await coin_store.get_coin_states_by_ids(True, coins, uint32(300), max_height=uint32(300))) == 2
-            assert len(await coin_store.get_coin_states_by_ids(True, coins, uint32(300), max_height=uint32(299))) == 0
-            assert len(await coin_store.get_coin_states_by_ids(True, coins, uint32(300), max_height=uint32(0))) == 0
 
             # test max_items limit
             for limit in [0, 1, 42, 300]:
diff --git a/tests/pools/test_pool_puzzles_lifecycle.py b/tests/pools/test_pool_puzzles_lifecycle.py
index a032b713a..d4e05d51f 100644
--- a/tests/pools/test_pool_puzzles_lifecycle.py
+++ b/tests/pools/test_pool_puzzles_lifecycle.py
@@ -16,7 +16,6 @@ from chia.pools.pool_puzzles import (
     create_travel_spend,
     create_waiting_room_inner_puzzle,
     get_delayed_puz_info_from_launcher_spend,
-    get_most_recent_singleton_coin_from_coin_spend,
     get_pubkey_from_member_inner_puzzle,
     get_seconds_and_delayed_puzhash_from_p2_singleton_puzzle,
     is_pool_singleton_inner_puzzle,
@@ -39,6 +38,7 @@ from chia.wallet.puzzles.p2_delegated_puzzle_or_hidden_puzzle import (
     puzzle_for_pk,
     solution_for_conditions,
 )
+from chia.wallet.singleton import get_most_recent_singleton_coin_from_coin_spend
 from tests.clvm.coin_store import BadSpendBundleError, CoinStore, CoinTimestamp
 from tests.clvm.test_puzzles import public_key_for_index, secret_exponent_for_index
 from tests.util.key_tool import KeyTool
diff --git a/tests/util/build_network_protocol_files.py b/tests/util/build_network_protocol_files.py
index e1031e225..63470d203 100644
--- a/tests/util/build_network_protocol_files.py
+++ b/tests/util/build_network_protocol_files.py
@@ -255,7 +255,7 @@ def test_protocol_json() -> None:
     return result
 
 
-def main() -> None:
+if __name__ == "__main__":
     get_network_protocol_filename().write_bytes(get_protocol_bytes())
 
     name_to_function = {
@@ -275,7 +275,3 @@ def main() -> None:
             check=True,
             cwd=tests_dir,
         )
-
-
-if __name__ == "__main__":
-    main()
diff --git a/tests/util/test_build_network_protocol_files.py b/tests/util/test_build_network_protocol_files.py
deleted file mode 100644
index c22c89073..000000000
--- a/tests/util/test_build_network_protocol_files.py
+++ /dev/null
@@ -1,7 +0,0 @@
-from __future__ import annotations
-
-from tests.util.build_network_protocol_files import main
-
-
-def test_build_network_protocol_files() -> None:
-    main()
diff --git a/tests/util/test_struct_stream.py b/tests/util/test_struct_stream.py
index a72360019..002636c09 100644
--- a/tests/util/test_struct_stream.py
+++ b/tests/util/test_struct_stream.py
@@ -41,7 +41,7 @@ class Good:
     size: int
     bits: int
     signed: bool
-    maximum: int
+    maximum_exclusive: int
     minimum: int
 
     @classmethod
@@ -50,7 +50,7 @@ class Good:
         name: str,
         size: int,
         signed: bool,
-        maximum: int,
+        maximum_exclusive: int,
         minimum: int,
     ) -> Good:
         raw_class: Type[StructStream] = type(name, (StructStream,), {})
@@ -61,30 +61,30 @@ class Good:
             size=size,
             bits=size * 8,
             signed=signed,
-            maximum=maximum,
+            maximum_exclusive=maximum_exclusive,
             minimum=minimum,
         )
 
 
 good_classes = [
-    Good.create(name="uint8", size=1, signed=False, maximum=0xFF, minimum=0),
-    Good.create(name="int8", size=1, signed=True, maximum=0x7F, minimum=-0x80),
-    Good.create(name="uint16", size=2, signed=False, maximum=0xFFFF, minimum=0),
-    Good.create(name="int16", size=2, signed=True, maximum=0x7FFF, minimum=-0x8000),
-    Good.create(name="uint24", size=3, signed=False, maximum=0xFFFFFF, minimum=0),
-    Good.create(name="int24", size=3, signed=True, maximum=0x7FFFFF, minimum=-0x800000),
+    Good.create(name="uint8", size=1, signed=False, maximum_exclusive=0xFF + 1, minimum=0),
+    Good.create(name="int8", size=1, signed=True, maximum_exclusive=0x80, minimum=-0x80),
+    Good.create(name="uint16", size=2, signed=False, maximum_exclusive=0xFFFF + 1, minimum=0),
+    Good.create(name="int16", size=2, signed=True, maximum_exclusive=0x8000, minimum=-0x8000),
+    Good.create(name="uint24", size=3, signed=False, maximum_exclusive=0xFFFFFF + 1, minimum=0),
+    Good.create(name="int24", size=3, signed=True, maximum_exclusive=0x800000, minimum=-0x800000),
     Good.create(
         name="uint128",
         size=16,
         signed=False,
-        maximum=0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF,
+        maximum_exclusive=0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF + 1,
         minimum=0,
     ),
     Good.create(
         name="int128",
         size=16,
         signed=True,
-        maximum=0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF,
+        maximum_exclusive=0x80000000000000000000000000000000,
         minimum=-0x80000000000000000000000000000000,
     ),
 ]
@@ -145,9 +145,6 @@ class TestStructStream:
             with pytest.raises(struct.error):
                 struct.pack(struct_format, upper_boundary + 1)
 
-        assert type(cls.MINIMUM) == cls
-        assert type(cls.MAXIMUM) == cls
-
     def test_int512(self) -> None:
         # int512 is special. it uses 65 bytes to allow positive and negative
         # "uint512"
@@ -248,7 +245,7 @@ class TestStructStream:
         assert uint32(b"273") == 273
 
     def test_struct_stream_cannot_be_instantiated_directly(self) -> None:
-        with pytest.raises(AttributeError, match="object has no attribute"):
+        with pytest.raises(ValueError, match="does not fit"):
             StructStream(0)
 
     @pytest.mark.parametrize(
@@ -284,7 +281,7 @@ class TestStructStream:
         assert good.cls.SIGNED == good.signed
 
     def test_parse_metadata_from_name_correct_maximum(self, good: Good) -> None:
-        assert good.cls.MAXIMUM == good.maximum
+        assert good.cls.MAXIMUM_EXCLUSIVE == good.maximum_exclusive
 
     def test_parse_metadata_from_name_correct_minimum(self, good: Good) -> None:
         assert good.cls.MINIMUM == good.minimum
diff --git a/tests/wallet/cat_wallet/test_cat_wallet.py b/tests/wallet/cat_wallet/test_cat_wallet.py
index fa4a0ad15..085e626bf 100644
--- a/tests/wallet/cat_wallet/test_cat_wallet.py
+++ b/tests/wallet/cat_wallet/test_cat_wallet.py
@@ -208,7 +208,7 @@ class TestCATWallet:
         assert cat_wallet.cat_info.limitations_program_hash == cat_wallet_2.cat_info.limitations_program_hash
 
         cat_2_hash = await cat_wallet_2.get_new_inner_hash()
-        tx_records = await cat_wallet.generate_signed_transaction([uint64(60)], [cat_2_hash], fee=uint64(1))
+        tx_records = await cat_wallet.generate_signed_transactions([uint64(60)], [cat_2_hash], fee=uint64(1))
         tx_id = None
         for tx_record in tx_records:
             await wallet.wallet_state_manager.add_pending_transaction(tx_record)
@@ -241,7 +241,7 @@ class TestCATWallet:
         assert len(memos[tx_id]) == 2
         assert list(memos[tx_id].values())[0][0] == cat_2_hash.hex()
         cat_hash = await cat_wallet.get_new_inner_hash()
-        tx_records = await cat_wallet_2.generate_signed_transaction([uint64(15)], [cat_hash])
+        tx_records = await cat_wallet_2.generate_signed_transactions([uint64(15)], [cat_hash])
         for tx_record in tx_records:
             await wallet.wallet_state_manager.add_pending_transaction(tx_record)
 
@@ -315,7 +315,7 @@ class TestCATWallet:
         assert cat_wallet.cat_info.limitations_program_hash == cat_wallet_2.cat_info.limitations_program_hash
 
         cat_2_hash = await cat_wallet_2.get_new_inner_hash()
-        tx_records = await cat_wallet.generate_signed_transaction(
+        tx_records = await cat_wallet.generate_signed_transactions(
             [uint64(60)], [cat_2_hash], fee=uint64(1), reuse_puzhash=True
         )
         for tx_record in tx_records:
@@ -345,7 +345,7 @@ class TestCATWallet:
         await time_out_assert(30, cat_wallet_2.get_unconfirmed_balance, 60)
 
         cat_hash = await cat_wallet.get_new_inner_hash()
-        tx_records = await cat_wallet_2.generate_signed_transaction([uint64(15)], [cat_hash])
+        tx_records = await cat_wallet_2.generate_signed_transactions([uint64(15)], [cat_hash])
         for tx_record in tx_records:
             await wallet.wallet_state_manager.add_pending_transaction(tx_record)
 
@@ -471,7 +471,7 @@ class TestCATWallet:
         assert cat_wallet.cat_info.limitations_program_hash == cat_wallet_2.cat_info.limitations_program_hash
 
         cat_2_hash = await cat_wallet_2.get_new_inner_hash()
-        tx_records = await cat_wallet.generate_signed_transaction([uint64(60)], [cat_2_hash], fee=uint64(1))
+        tx_records = await cat_wallet.generate_signed_transactions([uint64(60)], [cat_2_hash], fee=uint64(1))
         for tx_record in tx_records:
             await wallet.wallet_state_manager.add_pending_transaction(tx_record)
         await full_node_api.process_transaction_records(records=tx_records)
@@ -568,7 +568,7 @@ class TestCATWallet:
         cat_1_hash = await cat_wallet_1.get_new_inner_hash()
         cat_2_hash = await cat_wallet_2.get_new_inner_hash()
 
-        tx_records = await cat_wallet_0.generate_signed_transaction([uint64(60), uint64(20)], [cat_1_hash, cat_2_hash])
+        tx_records = await cat_wallet_0.generate_signed_transactions([uint64(60), uint64(20)], [cat_1_hash, cat_2_hash])
         for tx_record in tx_records:
             await wallet_0.wallet_state_manager.add_pending_transaction(tx_record)
         await full_node_api.process_transaction_records(records=tx_records)
@@ -584,11 +584,11 @@ class TestCATWallet:
 
         cat_hash = await cat_wallet_0.get_new_inner_hash()
 
-        tx_records = await cat_wallet_1.generate_signed_transaction([uint64(15)], [cat_hash])
+        tx_records = await cat_wallet_1.generate_signed_transactions([uint64(15)], [cat_hash])
         for tx_record in tx_records:
             await wallet_1.wallet_state_manager.add_pending_transaction(tx_record)
 
-        tx_records_2 = await cat_wallet_2.generate_signed_transaction([uint64(20)], [cat_hash])
+        tx_records_2 = await cat_wallet_2.generate_signed_transactions([uint64(20)], [cat_hash])
         for tx_record in tx_records_2:
             await wallet_2.wallet_state_manager.add_pending_transaction(tx_record)
 
@@ -606,11 +606,11 @@ class TestCATWallet:
         txs = await wallet_1.wallet_state_manager.tx_store.get_transactions_between(cat_wallet_1.id(), 0, 100000)
         print(len(txs))
         # Test with Memo
-        tx_records_3: TransactionRecord = await cat_wallet_1.generate_signed_transaction(
+        tx_records_3: TransactionRecord = await cat_wallet_1.generate_signed_transactions(
             [uint64(30)], [cat_hash], memos=[[b"Markus Walburg"]]
         )
         with pytest.raises(ValueError):
-            await cat_wallet_1.generate_signed_transaction(
+            await cat_wallet_1.generate_signed_transactions(
                 [uint64(30)], [cat_hash], memos=[[b"too"], [b"many"], [b"memos"]]
             )
 
@@ -682,7 +682,7 @@ class TestCATWallet:
             amounts.append(uint64(i))
             puzzle_hashes.append(cat_2_hash)
         spent_coint = (await cat_wallet.get_cat_spendable_coins())[0].coin
-        tx_records = await cat_wallet.generate_signed_transaction(amounts, puzzle_hashes, coins={spent_coint})
+        tx_records = await cat_wallet.generate_signed_transactions(amounts, puzzle_hashes, coins={spent_coint})
         for tx_record in tx_records:
             await wallet.wallet_state_manager.add_pending_transaction(tx_record)
         await full_node_api.process_transaction_records(records=tx_records)
@@ -708,7 +708,7 @@ class TestCATWallet:
         max_sent_amount = await cat_wallet.get_max_send_amount()
 
         # 1) Generate transaction that is under the limit
-        [transaction_record] = await cat_wallet.generate_signed_transaction(
+        [transaction_record] = await cat_wallet.generate_signed_transactions(
             [max_sent_amount - 1],
             [ph],
         )
@@ -716,7 +716,7 @@ class TestCATWallet:
         assert transaction_record.amount == uint64(max_sent_amount - 1)
 
         # 2) Generate transaction that is equal to limit
-        [transaction_record] = await cat_wallet.generate_signed_transaction(
+        [transaction_record] = await cat_wallet.generate_signed_transactions(
             [max_sent_amount],
             [ph],
         )
@@ -725,7 +725,7 @@ class TestCATWallet:
 
         # 3) Generate transaction that is greater than limit
         with pytest.raises(ValueError):
-            await cat_wallet.generate_signed_transaction(
+            await cat_wallet.generate_signed_transactions(
                 [max_sent_amount + 1],
                 [ph],
             )
@@ -786,7 +786,7 @@ class TestCATWallet:
         assert cat_wallet.cat_info.limitations_program_hash is not None
 
         cat_2_hash = await wallet2.get_new_puzzlehash()
-        tx_records = await cat_wallet.generate_signed_transaction([uint64(60)], [cat_2_hash], memos=[[cat_2_hash]])
+        tx_records = await cat_wallet.generate_signed_transactions([uint64(60)], [cat_2_hash], memos=[[cat_2_hash]])
 
         for tx_record in tx_records:
             await wallet.wallet_state_manager.add_pending_transaction(tx_record)
@@ -816,7 +816,7 @@ class TestCATWallet:
         }
 
         # Then we send another transaction
-        tx_records = await cat_wallet.generate_signed_transaction([uint64(10)], [cat_2_hash], memos=[[cat_2_hash]])
+        tx_records = await cat_wallet.generate_signed_transactions([uint64(10)], [cat_2_hash], memos=[[cat_2_hash]])
 
         for tx_record in tx_records:
             await wallet.wallet_state_manager.add_pending_transaction(tx_record)
@@ -835,7 +835,7 @@ class TestCATWallet:
         await time_out_assert(30, cat_wallet_2.get_unconfirmed_balance, 70)
 
         cat_hash = await cat_wallet.get_new_inner_hash()
-        tx_records = await cat_wallet_2.generate_signed_transaction([uint64(5)], [cat_hash])
+        tx_records = await cat_wallet_2.generate_signed_transactions([uint64(5)], [cat_hash])
         for tx_record in tx_records:
             await wallet.wallet_state_manager.add_pending_transaction(tx_record)
 
diff --git a/tests/wallet/dao_wallet/test_dao_cat_wallet.py b/tests/wallet/dao_wallet/test_dao_cat_wallet.py
new file mode 100644
index 000000000..bf271a4bf
--- /dev/null
+++ b/tests/wallet/dao_wallet/test_dao_cat_wallet.py
@@ -0,0 +1,213 @@
+from __future__ import annotations
+
+import asyncio
+
+# mypy: ignore-errors
+from typing import List
+
+import pytest
+
+from chia.consensus.block_rewards import calculate_base_farmer_reward, calculate_pool_reward
+from chia.full_node.mempool_manager import MempoolManager
+from chia.simulator.setup_nodes import SimulatorsAndWallets
+from chia.simulator.simulator_protocol import FarmNewBlockProtocol, ReorgProtocol
+from chia.simulator.time_out_assert import time_out_assert
+from chia.types.blockchain_format.program import Program
+from chia.types.blockchain_format.sized_bytes import bytes32
+from chia.types.peer_info import PeerInfo
+from chia.util.ints import uint16, uint32, uint64
+from chia.wallet.cat_wallet.cat_wallet import CATWallet
+from chia.wallet.cat_wallet.dao_cat_wallet import DAOCATWallet
+from chia.wallet.dao_wallet.dao_info import DAORules
+from chia.wallet.dao_wallet.dao_wallet import DAOWallet
+
+# from chia.wallet.puzzles.cat_loader import CAT_MOD
+from chia.wallet.puzzles.load_clvm import load_clvm
+from chia.wallet.transaction_record import TransactionRecord
+
+SINGLETON_MOD: Program = load_clvm("singleton_top_layer_v1_1.clsp")
+SINGLETON_LAUNCHER: Program = load_clvm("singleton_launcher.clsp")
+DAO_LOCKUP_MOD: Program = load_clvm("dao_lockup.clvm")
+DAO_PROPOSAL_TIMER_MOD: Program = load_clvm("dao_proposal_timer.clvm")
+DAO_PROPOSAL_MOD: Program = load_clvm("dao_proposal.clvm")
+DAO_TREASURY_MOD: Program = load_clvm("dao_treasury.clvm")
+P2_SINGLETON_MOD: Program = load_clvm("p2_singleton_or_delayed_puzhash.clsp")
+
+
+async def tx_in_pool(mempool: MempoolManager, tx_id: bytes32) -> bool:
+    tx = mempool.get_spendbundle(tx_id)
+    if tx is None:
+        return False
+    return True
+
+
+puzzle_hash_0 = bytes32(32 * b"0")
+puzzle_hash_1 = bytes32(32 * b"1")
+
+
+@pytest.mark.parametrize(
+    "trusted",
+    [True, False],
+)
+@pytest.mark.asyncio
+async def test_fund_dao_cat(self_hostname: str, two_wallet_nodes: SimulatorsAndWallets, trusted: bool) -> None:
+    num_blocks = 3
+    full_nodes, wallets, _ = two_wallet_nodes
+    full_node_api = full_nodes[0]
+    full_node_server = full_node_api.server
+    wallet_node, server_2 = wallets[0]
+    wallet_node_2, server_3 = wallets[1]
+    wallet = wallet_node.wallet_state_manager.main_wallet
+    wallet2 = wallet_node_2.wallet_state_manager.main_wallet
+
+    ph = await wallet.get_new_puzzlehash()
+    if trusted:
+        wallet_node.config["trusted_peers"] = {full_node_server.node_id.hex(): full_node_server.node_id.hex()}
+        wallet_node_2.config["trusted_peers"] = {full_node_server.node_id.hex(): full_node_server.node_id.hex()}
+    else:
+        wallet_node.config["trusted_peers"] = {}
+        wallet_node_2.config["trusted_peers"] = {}
+    await server_2.start_client(PeerInfo(self_hostname, uint16(full_node_server._port)), None)
+    await server_3.start_client(PeerInfo(self_hostname, uint16(full_node_server._port)), None)
+
+    for i in range(0, num_blocks):
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(ph))
+    await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    funds = sum(
+        [calculate_pool_reward(uint32(i)) + calculate_base_farmer_reward(uint32(i)) for i in range(1, num_blocks + 1)]
+    )
+
+    await time_out_assert(20, wallet.get_confirmed_balance, funds)
+
+    async with wallet_node.wallet_state_manager.lock:
+        cat_wallet: CATWallet = await CATWallet.create_new_cat_wallet(
+            wallet_node.wallet_state_manager, wallet, {"identifier": "genesis_by_id"}, uint64(100)
+        )
+    tx_queue: List[TransactionRecord] = await wallet_node.wallet_state_manager.tx_store.get_not_sent()
+    tx_record = tx_queue[0]
+    assert tx_record.spend_bundle
+    await time_out_assert(15, tx_in_pool, True, full_node_api.full_node.mempool_manager, tx_record.spend_bundle.name())
+
+    for i in range(1, num_blocks):
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    await time_out_assert(20, cat_wallet.get_confirmed_balance, 100)
+    await time_out_assert(20, cat_wallet.get_unconfirmed_balance, 100)
+
+    assert cat_wallet.cat_info.limitations_program_hash is not None
+    asset_id = cat_wallet.get_asset_id()
+
+    cat_wallet_2: CATWallet = await CATWallet.get_or_create_wallet_for_cat(
+        wallet_node_2.wallet_state_manager, wallet2, asset_id
+    )
+
+    assert cat_wallet.cat_info.limitations_program_hash == cat_wallet_2.cat_info.limitations_program_hash
+
+    cat_2_hash = await cat_wallet_2.get_new_inner_hash()
+    tx_records = await cat_wallet.generate_signed_transactions([uint64(60)], [cat_2_hash], fee=uint64(1))
+    for tx_record in tx_records:
+        await wallet.wallet_state_manager.add_pending_transaction(tx_record)
+        if tx_record.spend_bundle is not None:
+            await time_out_assert(
+                15, tx_in_pool, True, full_node_api.full_node.mempool_manager, tx_record.spend_bundle.name()
+            )
+        if tx_record.wallet_id is cat_wallet.id():
+            assert tx_record.to_puzzle_hash == cat_2_hash
+
+    await time_out_assert(20, cat_wallet.get_pending_change_balance, 40)
+
+    for i in range(1, num_blocks):
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    await time_out_assert(30, wallet.get_confirmed_balance, funds - 101)
+
+    await time_out_assert(20, cat_wallet.get_confirmed_balance, 40)
+    await time_out_assert(20, cat_wallet.get_unconfirmed_balance, 40)
+
+    await time_out_assert(30, cat_wallet_2.get_confirmed_balance, 60)
+    await time_out_assert(30, cat_wallet_2.get_unconfirmed_balance, 60)
+
+    cat_hash = await cat_wallet.get_new_inner_hash()
+    tx_records = await cat_wallet_2.generate_signed_transactions([uint64(15)], [cat_hash])
+    for tx_record in tx_records:
+        assert tx_record.spend_bundle
+        await wallet.wallet_state_manager.add_pending_transaction(tx_record)
+        await time_out_assert(
+            15, tx_in_pool, True, full_node_api.full_node.mempool_manager, tx_record.spend_bundle.name()
+        )
+
+    await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(ph))
+
+    await time_out_assert(20, cat_wallet.get_confirmed_balance, 55)
+    await time_out_assert(20, cat_wallet.get_unconfirmed_balance, 55)
+
+    height = full_node_api.full_node.blockchain.get_peak_height()
+    assert height
+    await full_node_api.reorg_from_index_to_new_index(ReorgProtocol(height - 1, height + 1, puzzle_hash_1, None))
+    await time_out_assert(20, cat_wallet.get_confirmed_balance, 40)
+
+    dao_rules = DAORules(
+        proposal_timelock=uint64(10),
+        soft_close_length=uint64(5),
+        attendance_required=uint64(30),  # 10%
+        pass_percentage=uint64(5100),  # 51%
+        self_destruct_length=uint64(20),
+        oracle_spend_delay=uint64(10),
+    )
+
+    dao_wallet = await DAOWallet.create_new_dao_for_existing_cat(
+        wallet_node.wallet_state_manager,
+        wallet,
+        bytes.fromhex(asset_id),
+        dao_rules,
+    )
+
+    dao_cat_wallet = await DAOCATWallet.get_or_create_wallet_for_cat(
+        wallet_node.wallet_state_manager,
+        wallet,
+        asset_id,
+    )
+    assert dao_wallet is not None
+    assert dao_cat_wallet is not None
+
+    # cat wallet balance is 55
+    for i in range(1, num_blocks):
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    await time_out_assert(20, cat_wallet.get_confirmed_balance, 55)
+    await time_out_assert(20, dao_cat_wallet.get_votable_balance, 55)
+    await time_out_assert(20, dao_cat_wallet.get_votable_balance, 0, include_free_cats=False)
+
+    txs, new_cats = await dao_cat_wallet.create_new_dao_cats(35, push=True)
+    await time_out_assert(15, tx_in_pool, True, full_node_api.full_node.mempool_manager, txs[0].spend_bundle.name())
+    for i in range(1, num_blocks):
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+    # coins = await cat_wallet.select_coins(55)
+
+    await time_out_assert(20, cat_wallet.get_spendable_balance, 20)
+    await time_out_assert(20, cat_wallet.get_confirmed_balance, 20)
+    await time_out_assert(20, dao_cat_wallet.get_votable_balance, 55)
+    await time_out_assert(20, dao_cat_wallet.get_votable_balance, 35, include_free_cats=False)
+
+    proposed_puzzle = dao_wallet.generate_simple_proposal_innerpuz(ph, 10)
+    tx = await dao_wallet.generate_new_proposal(proposed_puzzle, 35, push=True)
+    assert tx is not None
+
+    await time_out_assert(15, tx_in_pool, True, full_node_api.full_node.mempool_manager, tx.name())
+
+    for i in range(1, 5):
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+    await asyncio.sleep(1)
+    funding_tx = await dao_wallet.create_add_money_to_treasury_spend(5000)
+    await time_out_assert(15, tx_in_pool, True, full_node_api.full_node.mempool_manager, funding_tx.spend_bundle.name())
+    await full_node_api.process_transaction_records(records=[funding_tx])
+
+    if not trusted:
+        await asyncio.sleep(1)
+    for i in range(1, 5):
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    proposal_info = dao_wallet.dao_info.proposals_list[0]
+    assert proposal_info is not None
+    tx = await dao_wallet.create_proposal_close_spend(proposal_info.proposal_id)
diff --git a/tests/wallet/dao_wallet/test_dao_clvm.py b/tests/wallet/dao_wallet/test_dao_clvm.py
new file mode 100644
index 000000000..a4eaa20c8
--- /dev/null
+++ b/tests/wallet/dao_wallet/test_dao_clvm.py
@@ -0,0 +1,977 @@
+from __future__ import annotations
+
+# mypy: ignore-errors
+from clvm.casts import int_to_bytes
+
+# from chia.types.blockchain_format.coin import Coin
+from chia.types.blockchain_format.program import INFINITE_COST, Program
+from chia.types.blockchain_format.sized_bytes import bytes32
+from chia.types.condition_opcodes import ConditionOpcode
+from chia.util.condition_tools import conditions_dict_for_solution
+from chia.util.hash import std_hash
+from chia.util.ints import uint64
+from chia.wallet.puzzles.cat_loader import CAT_MOD
+from chia.wallet.puzzles.load_clvm import load_clvm
+
+CAT_MOD_HASH: bytes32 = CAT_MOD.get_tree_hash()
+SINGLETON_MOD: Program = load_clvm("singleton_top_layer_v1_1.clsp")
+SINGLETON_MOD_HASH: bytes32 = SINGLETON_MOD.get_tree_hash()
+SINGLETON_LAUNCHER: Program = load_clvm("singleton_launcher.clsp")
+SINGLETON_LAUNCHER_HASH: bytes32 = SINGLETON_LAUNCHER.get_tree_hash()
+DAO_LOCKUP_MOD: Program = load_clvm("dao_lockup.clsp")
+DAO_LOCKUP_MOD_HASH: bytes32 = DAO_LOCKUP_MOD.get_tree_hash()
+DAO_PROPOSAL_TIMER_MOD: Program = load_clvm("dao_proposal_timer.clsp")
+DAO_PROPOSAL_TIMER_MOD_HASH: bytes32 = DAO_PROPOSAL_TIMER_MOD.get_tree_hash()
+DAO_PROPOSAL_MOD: Program = load_clvm("dao_proposal.clsp")
+DAO_PROPOSAL_MOD_HASH: bytes32 = DAO_PROPOSAL_MOD.get_tree_hash()
+DAO_PROPOSAL_VALIDATOR_MOD: Program = load_clvm("dao_proposal_validator.clsp")
+DAO_PROPOSAL_VALIDATOR_MOD_HASH: bytes32 = DAO_PROPOSAL_VALIDATOR_MOD.get_tree_hash()
+DAO_TREASURY_MOD: Program = load_clvm("dao_treasury.clsp")
+DAO_TREASURY_MOD_HASH: bytes32 = DAO_TREASURY_MOD.get_tree_hash()
+SPEND_P2_SINGLETON_MOD: Program = load_clvm("dao_spend_p2_singleton.clsp")
+SPEND_P2_SINGLETON_MOD_HASH: bytes32 = SPEND_P2_SINGLETON_MOD.get_tree_hash()
+DAO_FINISHED_STATE: Program = load_clvm("dao_finished_state.clsp")
+DAO_FINISHED_STATE_HASH: bytes32 = DAO_FINISHED_STATE.get_tree_hash()
+DAO_RESALE_PREVENTION: Program = load_clvm("dao_resale_prevention_layer.clsp")
+DAO_RESALE_PREVENTION_HASH: bytes32 = DAO_RESALE_PREVENTION.get_tree_hash()
+DAO_CAT_TAIL: Program = load_clvm("genesis_by_coin_id_or_singleton.clsp")
+DAO_CAT_TAIL_HASH: bytes32 = DAO_CAT_TAIL.get_tree_hash()
+P2_CONDITIONS_MOD: Program = load_clvm("p2_conditions_curryable.clsp")
+P2_CONDITIONS_MOD_HASH: bytes32 = P2_CONDITIONS_MOD.get_tree_hash()
+DAO_SAFE_PAYMENT_MOD: Program = load_clvm("dao_safe_payment.clsp")
+DAO_SAFE_PAYMENT_MOD_HASH: bytes32 = DAO_SAFE_PAYMENT_MOD.get_tree_hash()
+P2_SINGLETON_MOD: Program = load_clvm("p2_singleton_via_delegated_puzzle.clsp")
+P2_SINGLETON_MOD_HASH: bytes32 = P2_SINGLETON_MOD.get_tree_hash()
+DAO_UPDATE_MOD: Program = load_clvm("dao_update_proposal.clsp")
+DAO_UPDATE_MOD_HASH: bytes32 = DAO_UPDATE_MOD.get_tree_hash()
+
+
+def test_finished_state() -> None:
+    proposal_id: Program = Program.to("proposal_id").get_tree_hash()
+    singleton_struct: Program = Program.to(
+        (SINGLETON_MOD.get_tree_hash(), (proposal_id, SINGLETON_LAUNCHER.get_tree_hash()))
+    )
+    finished_inner_puz = DAO_FINISHED_STATE.curry(singleton_struct, DAO_FINISHED_STATE_HASH)
+    finished_full_puz = SINGLETON_MOD.curry(singleton_struct, finished_inner_puz)
+    inner_sol = Program.to([1])
+
+    conds = finished_inner_puz.run(inner_sol).as_python()
+    assert conds[0][1] == finished_full_puz.get_tree_hash()
+    assert conds[2][1] == finished_inner_puz.get_tree_hash()
+
+    lineage = Program.to([proposal_id, finished_inner_puz.get_tree_hash(), 1])
+    full_sol = Program.to([lineage, 1, inner_sol])
+
+    conds = conditions_dict_for_solution(finished_full_puz, full_sol, INFINITE_COST)
+    assert conds[ConditionOpcode.ASSERT_MY_PUZZLEHASH][0].vars[0] == finished_full_puz.get_tree_hash()
+    assert conds[ConditionOpcode.CREATE_COIN][0].vars[0] == finished_full_puz.get_tree_hash()
+
+
+def test_proposal() -> None:
+    proposal_pass_percentage: uint64 = uint64(5100)
+    CAT_TAIL_HASH: Program = Program.to("tail").get_tree_hash()
+    treasury_id: Program = Program.to("treasury").get_tree_hash()
+    singleton_id: Program = Program.to("singleton_id").get_tree_hash()
+    singleton_struct: Program = Program.to(
+        (SINGLETON_MOD.get_tree_hash(), (singleton_id, SINGLETON_LAUNCHER.get_tree_hash()))
+    )
+    self_destruct_time = 1000  # number of blocks
+    oracle_spend_delay = 10
+    active_votes_list = [0xFADEDDAB]  # are the the ids of previously voted on proposals?
+    acs: Program = Program.to(1)
+    acs_ph: bytes32 = acs.get_tree_hash()
+
+    # make a lockup puz for the dao cat
+    lockup_puz = DAO_LOCKUP_MOD.curry(
+        DAO_PROPOSAL_MOD_HASH,
+        SINGLETON_MOD_HASH,
+        SINGLETON_LAUNCHER_HASH,
+        DAO_LOCKUP_MOD_HASH,
+        CAT_MOD_HASH,
+        CAT_TAIL_HASH,
+        active_votes_list,
+        acs,  # innerpuz
+    )
+
+    dao_cat_puz: Program = CAT_MOD.curry(CAT_MOD_HASH, CAT_TAIL_HASH, lockup_puz)
+    dao_cat_puzhash: bytes32 = dao_cat_puz.get_tree_hash()
+
+    # Test Voting
+    current_yes_votes = 20
+    current_total_votes = 100
+    full_proposal: Program = DAO_PROPOSAL_MOD.curry(
+        singleton_struct,
+        DAO_PROPOSAL_MOD_HASH,
+        DAO_PROPOSAL_TIMER_MOD_HASH,
+        CAT_MOD_HASH,
+        DAO_TREASURY_MOD_HASH,
+        DAO_LOCKUP_MOD_HASH,
+        CAT_TAIL_HASH,
+        treasury_id,
+        current_yes_votes,
+        current_total_votes,
+        acs_ph,
+    )
+
+    vote_amount = 10
+    vote_type = 1  # yes vote
+    vote_coin_id = Program.to("vote_coin").get_tree_hash()
+    solution: Program = Program.to(
+        [
+            [vote_amount],  # vote amounts
+            vote_type,  # vote type (yes)
+            [vote_coin_id],  # vote coin ids
+            [active_votes_list],  # previous votes
+            [acs_ph],  # lockup inner puz hash
+            0,  # inner puz reveal
+            0,  # soft close len
+            self_destruct_time,
+            oracle_spend_delay,
+            0,
+        ]
+    )
+
+    # Run the proposal and check its conditions
+    conditions = conditions_dict_for_solution(full_proposal, solution, INFINITE_COST)
+
+    # Puzzle Announcement of vote_coin_ids
+    assert conditions[ConditionOpcode.CREATE_PUZZLE_ANNOUNCEMENT][0].vars[0] == vote_coin_id
+
+    # Assert puzzle announcement from dao_cat of proposal_id and all vote details
+    apa_msg = Program.to([singleton_id, vote_amount, vote_type, vote_coin_id]).get_tree_hash()
+    assert conditions[ConditionOpcode.ASSERT_PUZZLE_ANNOUNCEMENT][0].vars[0] == std_hash(dao_cat_puzhash + apa_msg)
+
+    # Check that the proposal recreates itself with updated vote amounts
+    next_proposal: Program = DAO_PROPOSAL_MOD.curry(
+        singleton_struct,
+        DAO_PROPOSAL_MOD_HASH,
+        DAO_PROPOSAL_TIMER_MOD_HASH,
+        CAT_MOD_HASH,
+        DAO_TREASURY_MOD_HASH,
+        DAO_LOCKUP_MOD_HASH,
+        CAT_TAIL_HASH,
+        treasury_id,
+        current_yes_votes + vote_amount,
+        current_total_votes + vote_amount,
+        acs_ph,
+    )
+    assert conditions[ConditionOpcode.CREATE_COIN][0].vars[0] == next_proposal.get_tree_hash()
+    assert conditions[ConditionOpcode.CREATE_COIN][0].vars[1] == int_to_bytes(1)
+
+    # Test Launch
+    current_yes_votes = 0
+    current_total_votes = 0
+    launch_proposal: Program = DAO_PROPOSAL_MOD.curry(
+        singleton_struct,
+        DAO_PROPOSAL_MOD_HASH,
+        DAO_PROPOSAL_TIMER_MOD_HASH,
+        CAT_MOD_HASH,
+        DAO_TREASURY_MOD_HASH,
+        DAO_LOCKUP_MOD_HASH,
+        CAT_TAIL_HASH,
+        treasury_id,
+        current_yes_votes,
+        current_total_votes,
+        acs_ph,
+    )
+    vote_amount = 10
+    vote_type = 1  # yes vote
+    vote_coin_id = Program.to("vote_coin").get_tree_hash()
+    solution: Program = Program.to(
+        [
+            [vote_amount],  # vote amounts
+            vote_type,  # vote type (yes)
+            [vote_coin_id],  # vote coin ids
+            # TODO: Check whether previous votes should be 0 in the first spend since
+            # proposal looks at (f previous_votes) during loop_over_vote_coins
+            [0],  # previous votes
+            [acs_ph],  # lockup inner puz hash
+            acs,  # inner puz reveal
+            0,  # soft close len
+            self_destruct_time,
+            oracle_spend_delay,
+            0,
+        ]
+    )
+    # Run the proposal and check its conditions
+    conditions = conditions_dict_for_solution(launch_proposal, solution, INFINITE_COST)
+    # check that the timer is created
+    timer_puz = DAO_PROPOSAL_TIMER_MOD.curry(
+        DAO_PROPOSAL_MOD_HASH,
+        DAO_PROPOSAL_TIMER_MOD_HASH,
+        DAO_LOCKUP_MOD_HASH,
+        CAT_MOD_HASH,
+        CAT_TAIL_HASH,
+        singleton_struct,
+        treasury_id,
+    )
+    timer_puzhash = timer_puz.get_tree_hash()
+    assert conditions[ConditionOpcode.CREATE_COIN][1].vars[0] == timer_puzhash
+
+    # Test exits
+
+    # Test attempt to close a passing proposal
+    current_yes_votes = 200
+    current_total_votes = 350
+    full_proposal: Program = DAO_PROPOSAL_MOD.curry(
+        singleton_struct,
+        DAO_PROPOSAL_MOD_HASH,
+        DAO_PROPOSAL_TIMER_MOD_HASH,
+        CAT_MOD_HASH,
+        DAO_TREASURY_MOD_HASH,
+        DAO_LOCKUP_MOD_HASH,
+        CAT_TAIL_HASH,
+        treasury_id,
+        current_yes_votes,
+        current_total_votes,
+        acs_ph,
+    )
+    attendance_required = 200
+    proposal_timelock = 20
+    soft_close_length = 5
+    solution = Program.to(
+        [
+            Program.to("validator_hash").get_tree_hash(),
+            0,
+            # Program.to("receiver_hash").get_tree_hash(), # not needed anymore?
+            proposal_timelock,
+            proposal_pass_percentage,
+            attendance_required,
+            0,
+            soft_close_length,
+            self_destruct_time,
+            oracle_spend_delay,
+            0,
+        ]
+    )
+
+    conds = conditions_dict_for_solution(full_proposal, solution, INFINITE_COST)
+
+    # make a matching treasury puzzle for the APA
+    treasury_inner: Program = DAO_TREASURY_MOD.curry(
+        DAO_TREASURY_MOD_HASH,
+        Program.to("validator_hash"),
+        proposal_timelock,
+        soft_close_length,
+        attendance_required,
+        proposal_pass_percentage,
+        self_destruct_time,
+        oracle_spend_delay,
+    )
+    treasury: Program = SINGLETON_MOD.curry(
+        Program.to((SINGLETON_MOD_HASH, (treasury_id, SINGLETON_LAUNCHER_HASH))),
+        treasury_inner,
+    )
+    treasury_puzhash = treasury.get_tree_hash()
+    apa_msg = singleton_id
+
+    timer_apa = std_hash(timer_puzhash + singleton_id)
+    assert conds[ConditionOpcode.ASSERT_PUZZLE_ANNOUNCEMENT][0].vars[0] == timer_apa
+    assert conds[ConditionOpcode.ASSERT_PUZZLE_ANNOUNCEMENT][1].vars[0] == std_hash(treasury_puzhash + apa_msg)
+
+    # close a failed proposal
+    full_proposal: Program = DAO_PROPOSAL_MOD.curry(
+        singleton_struct,
+        DAO_PROPOSAL_MOD_HASH,
+        DAO_PROPOSAL_TIMER_MOD_HASH,
+        CAT_MOD_HASH,
+        DAO_TREASURY_MOD_HASH,
+        DAO_LOCKUP_MOD_HASH,
+        CAT_TAIL_HASH,
+        treasury_id,
+        20,  # failing number of yes votes
+        current_total_votes,
+        acs_ph,
+    )
+    solution = Program.to(
+        [
+            Program.to("validator_hash").get_tree_hash(),
+            0,
+            # Program.to("receiver_hash").get_tree_hash(), # not needed anymore?
+            proposal_timelock,
+            proposal_pass_percentage,
+            attendance_required,
+            0,
+            soft_close_length,
+            self_destruct_time,
+            oracle_spend_delay,
+            0,
+        ]
+    )
+    conds = conditions_dict_for_solution(full_proposal, solution, INFINITE_COST)
+    apa_msg = int_to_bytes(0)
+    assert conds[ConditionOpcode.ASSERT_PUZZLE_ANNOUNCEMENT][1].vars[0] == std_hash(treasury_puzhash + apa_msg)
+    assert conds[ConditionOpcode.ASSERT_PUZZLE_ANNOUNCEMENT][0].vars[0] == timer_apa
+
+    finished_puz = DAO_FINISHED_STATE.curry(singleton_struct, DAO_FINISHED_STATE_HASH)
+    assert conds[ConditionOpcode.CREATE_COIN][0].vars[0] == finished_puz.get_tree_hash()
+
+    # self destruct a proposal
+    attendance_required = 200
+    solution = Program.to(
+        [
+            Program.to("validator_hash").get_tree_hash(),
+            0,
+            # Program.to("receiver_hash").get_tree_hash(), # not needed anymore?
+            proposal_timelock,
+            proposal_pass_percentage,
+            attendance_required,
+            0,
+            soft_close_length,
+            self_destruct_time,
+            oracle_spend_delay,
+            1,
+        ]
+    )
+    conds = conditions_dict_for_solution(full_proposal, solution, INFINITE_COST)
+    assert conds[ConditionOpcode.ASSERT_PUZZLE_ANNOUNCEMENT][0].vars[0] == std_hash(treasury_puzhash + apa_msg)
+    assert conds[ConditionOpcode.CREATE_COIN][0].vars[0] == finished_puz.get_tree_hash()
+
+
+def test_proposal_timer() -> None:
+    CAT_TAIL: Program = Program.to("tail").get_tree_hash()
+    treasury_id: Program = Program.to("treasury").get_tree_hash()
+    # LOCKUP_TIME: uint64 = uint64(200)
+    singleton_id: Program = Program.to("singleton_id").get_tree_hash()
+    singleton_struct: Program = Program.to(
+        (SINGLETON_MOD.get_tree_hash(), (singleton_id, SINGLETON_LAUNCHER.get_tree_hash()))
+    )
+    # PROPOSAL_MOD_HASH
+    # PROPOSAL_TIMER_MOD_HASH
+    # CAT_MOD_HASH
+    # CAT_TAIL_HASH
+    # (@ MY_PARENT_SINGLETON_STRUCT (SINGLETON_MOD_HASH SINGLETON_ID . LAUNCHER_PUZZLE_HASH))
+    # TREASURY_ID
+    proposal_timer_full: Program = DAO_PROPOSAL_TIMER_MOD.curry(
+        DAO_PROPOSAL_MOD_HASH,
+        DAO_PROPOSAL_TIMER_MOD_HASH,
+        DAO_LOCKUP_MOD_HASH,
+        CAT_MOD_HASH,
+        CAT_TAIL,
+        singleton_struct,
+        treasury_id,
+    )
+
+    # proposal_yes_votes
+    # proposal_total_votes
+    # proposal_innerpuzhash
+    # proposal_parent_id
+    # proposal_amount
+    # proposal_timelock
+    # parent_parent
+
+    solution: Program = Program.to(
+        [
+            140,
+            180,
+            Program.to(1).get_tree_hash(),
+            Program.to("parent").get_tree_hash(),
+            23,
+            200,
+            Program.to("parent_parent").get_tree_hash(),
+        ]
+    )
+    conds: Program = proposal_timer_full.run(solution)
+    assert len(conds.as_python()) == 4
+
+
+def test_validator() -> None:
+    # SINGLETON_STRUCT  ; (SINGLETON_MOD_HASH (SINGLETON_ID . LAUNCHER_PUZZLE_HASH))
+    # PROPOSAL_MOD_HASH
+    # PROPOSAL_TIMER_MOD_HASH
+    # CAT_MOD_HASH
+    # LOCKUP_MOD_HASH
+    # TREASURY_MOD_HASH
+    # CAT_TAIL_HASH
+    # ATTENDANCE_REQUIRED
+    # PASS_MARGIN
+    singleton_id: Program = Program.to("singleton_id").get_tree_hash()
+    singleton_struct: Program = Program.to(
+        (SINGLETON_MOD.get_tree_hash(), (singleton_id, SINGLETON_LAUNCHER.get_tree_hash()))
+    )
+    CAT_TAIL_HASH: Program = Program.to("tail").get_tree_hash()
+
+    # treasury_puzzle_hash = Program.to("treasury").get_tree_hash()
+
+    p2_singleton = P2_SINGLETON_MOD.curry(singleton_struct)
+    p2_singleton_puzhash = p2_singleton.get_tree_hash()
+    parent_id = Program.to("parent").get_tree_hash()
+    locked_amount = 100000
+    spend_amount = 1100
+    conditions = [[51, 0xDABBAD00, 1000], [51, 0xCAFEF00D, 100]]
+
+    spend_p2_singleton = SPEND_P2_SINGLETON_MOD.curry(conditions, p2_singleton_puzhash)
+    spend_p2_singleton_puzhash = spend_p2_singleton.get_tree_hash()
+    spend_p2_singleton_solution = Program.to([[[parent_id, locked_amount]]])
+    output_conds = spend_p2_singleton.run(spend_p2_singleton_solution)
+
+    proposal_validator = DAO_PROPOSAL_VALIDATOR_MOD.curry(
+        singleton_struct,
+        DAO_PROPOSAL_MOD_HASH,
+        DAO_PROPOSAL_TIMER_MOD_HASH,
+        CAT_MOD_HASH,
+        DAO_LOCKUP_MOD_HASH,
+        DAO_TREASURY_MOD_HASH,
+        CAT_TAIL_HASH,
+    )
+
+    # SINGLETON_STRUCT  ; (SINGLETON_MOD_HASH (SINGLETON_ID . LAUNCHER_PUZZLE_HASH))
+    # PROPOSAL_MOD_HASH
+    # PROPOSAL_TIMER_MOD_HASH ; proposal timer needs to know which proposal created it, AND
+    # CAT_MOD_HASH
+    # TREASURY_MOD_HASH
+    # LOCKUP_MOD_HASH
+    # CAT_TAIL_HASH
+    # TREASURY_ID
+    # YES_VOTES  ; yes votes are +1, no votes don't tally - we compare yes_votes/total_votes at the end
+    # TOTAL_VOTES  ; how many people responded
+    # SPEND_OR_UPDATE_FLAG  ; this is one of 's', 'u', 'd' - other types may be added in the future
+    # PROPOSED_PUZ_HASH  ; this is what runs if this proposal is successful - the inner puzzle of this proposal
+    proposal: Program = DAO_PROPOSAL_MOD.curry(
+        singleton_struct,
+        DAO_PROPOSAL_MOD_HASH,
+        DAO_PROPOSAL_TIMER_MOD_HASH,
+        CAT_MOD_HASH,
+        DAO_TREASURY_MOD_HASH,
+        DAO_LOCKUP_MOD_HASH,
+        CAT_TAIL_HASH,
+        singleton_id,
+        950,
+        1200,
+        "s",
+        spend_p2_singleton_puzhash,
+    )
+    full_proposal = SINGLETON_MOD.curry(singleton_struct, proposal)
+    solution = Program.to(
+        [
+            1000,
+            5100,
+            [full_proposal.get_tree_hash(), spend_p2_singleton_puzhash, 0, "s"],
+            [singleton_id, 1200, 950, spend_amount],
+            output_conds.as_python(),
+        ]
+    )
+    conds: Program = proposal_validator.run(solution)
+    assert len(conds.as_python()) == 3 + len(conditions)
+
+    # test update
+    proposal: Program = DAO_PROPOSAL_MOD.curry(
+        singleton_struct,
+        DAO_PROPOSAL_MOD_HASH,
+        DAO_PROPOSAL_TIMER_MOD_HASH,
+        CAT_MOD_HASH,
+        DAO_TREASURY_MOD_HASH,
+        DAO_LOCKUP_MOD_HASH,
+        CAT_TAIL_HASH,
+        singleton_id,
+        950,
+        1200,
+        "u",
+        Program.to(1).get_tree_hash(),
+    )
+    full_proposal = SINGLETON_MOD.curry(singleton_struct, proposal)
+    solution = Program.to(
+        [
+            1000,
+            5100,
+            [full_proposal.get_tree_hash(), Program.to(1).get_tree_hash(), 0, "u"],
+            [singleton_id, 1200, 950, spend_amount],
+            [[51, 0xCAFE00D, spend_amount]],
+        ]
+    )
+    conds: Program = proposal_validator.run(solution)
+    assert len(conds.as_python()) == 2
+
+    return
+
+
+def test_merge_p2_singleton() -> None:
+    singleton_id: Program = Program.to("singleton_id").get_tree_hash()
+
+    singleton_struct: Program = Program.to((SINGLETON_MOD_HASH, (singleton_id, SINGLETON_LAUNCHER_HASH)))
+
+    # Test that p2_singleton_via_delegated_puzzle will run
+    p2_singleton = P2_SINGLETON_MOD.curry(singleton_struct)
+    # singleton_inner_puzhash
+    # delegated_puzzle
+    # delegated_solution
+    # my_id
+    # my_puzhash
+    # list_of_parent_amounts
+    # my_amount
+    conds = p2_singleton.run(Program.to([0, 0, 0, singleton_id, p2_singleton.get_tree_hash(), 0]))
+    assert len(conds.as_python()) == 3
+    fake_parent_id = Program.to("fake_parent").get_tree_hash()
+    # fake_coin = Coin(fake_parent_id, p2_singleton.get_tree_hash(), 200)
+    conds = p2_singleton.run(
+        Program.to([0, 0, 0, singleton_id, p2_singleton.get_tree_hash(), [[fake_parent_id, 200]], 100])
+    )
+    assert len(conds.as_python()) == 6
+    assert conds.rest().rest().rest().rest().rest().first().rest().rest().first().as_int() == 300
+    return
+
+
+def test_spend_p2_singleton() -> None:
+    singleton_id: Program = Program.to("singleton_id").get_tree_hash()
+    singleton_struct: Program = Program.to((SINGLETON_MOD_HASH, (singleton_id, SINGLETON_LAUNCHER_HASH)))
+
+    # Test that p2_singleton_via_delegated_puzzle will run
+    p2_singleton = P2_SINGLETON_MOD.curry(singleton_struct)
+    p2_singleton_puzhash = p2_singleton.get_tree_hash()
+    parent_id = Program.to("parent").get_tree_hash()
+    locked_amount = 100000
+    singleton_inner_hash = Program.to(1).get_tree_hash()
+    deleg_puz = Program.to(1)
+    deleg_conds = Program.to([[51, 0xCAFEF00D, 1000]])
+    # singleton_inner_puzhash
+    # delegated_puzzle
+    # delegated_solution
+    # my_id
+    p2_singleton_id = Program.to("p2_singleton_coin").get_tree_hash()
+    conds = p2_singleton.run(Program.to([singleton_inner_hash, deleg_puz, deleg_conds, p2_singleton_id, 0, 0]))
+    assert len(conds.as_python()) == 4
+
+    spend_amount = 1100
+    conditions = [[51, 0xDABBAD00, 1000], [51, 0xCAFEF00D, 100]]
+
+    spend_p2_singleton = SPEND_P2_SINGLETON_MOD.curry(conditions, p2_singleton_puzhash)
+    spend_p2_singleton_puzhash = spend_p2_singleton.get_tree_hash()
+    solution = Program.to([[[parent_id, locked_amount]]])
+
+    output_conditions = spend_p2_singleton.run(solution)
+    assert len(output_conditions.as_python()) == 5
+
+    # now use the p2_singleton with the proposal validator
+    total_votes = 1200
+    yes_votes = 950
+    attendance_required = 1000
+    pass_margin = 5100
+    CAT_TAIL_HASH: Program = Program.to("tail").get_tree_hash()
+    proposal_validator = DAO_PROPOSAL_VALIDATOR_MOD.curry(
+        singleton_struct,
+        DAO_PROPOSAL_MOD_HASH,
+        DAO_PROPOSAL_TIMER_MOD_HASH,
+        CAT_MOD_HASH,
+        DAO_LOCKUP_MOD_HASH,
+        DAO_TREASURY_MOD_HASH,
+        CAT_TAIL_HASH,
+    )
+    proposal: Program = DAO_PROPOSAL_MOD.curry(
+        singleton_struct,
+        DAO_PROPOSAL_MOD_HASH,
+        DAO_PROPOSAL_TIMER_MOD_HASH,
+        CAT_MOD_HASH,
+        DAO_TREASURY_MOD_HASH,
+        DAO_LOCKUP_MOD_HASH,
+        CAT_TAIL_HASH,
+        singleton_id,
+        yes_votes,
+        total_votes,
+        "s",
+        spend_p2_singleton_puzhash,
+    )
+    full_proposal = SINGLETON_MOD.curry(singleton_struct, proposal)
+    validator_solution = Program.to(
+        [
+            attendance_required,
+            pass_margin,
+            [full_proposal.get_tree_hash(), spend_p2_singleton_puzhash, 0, "s"],
+            [singleton_id, total_votes, yes_votes, spend_amount],
+            output_conditions,
+        ]
+    )
+    conds = proposal_validator.run(validator_solution)
+    assert len(conds.as_python()) == 3 + len(conditions)
+
+
+def test_treasury() -> None:
+    CAT_TAIL_HASH: Program = Program.to("tail").get_tree_hash()
+    singleton_id: Program = Program.to("singleton_id").get_tree_hash()
+    singleton_struct: Program = Program.to((SINGLETON_MOD_HASH, (singleton_id, SINGLETON_LAUNCHER_HASH)))
+    p2_singleton = P2_SINGLETON_MOD.curry(singleton_struct)
+    p2_singleton_puzhash = p2_singleton.get_tree_hash()
+    parent_id = Program.to("parent").get_tree_hash()
+    locked_amount = 100000
+    oracle_spend_delay = 10
+    spend_amount = 1100
+    conditions = [[51, 0xDABBAD00, 1000], [51, 0xCAFEF00D, 100]]
+
+    spend_p2_singleton = SPEND_P2_SINGLETON_MOD.curry(conditions, p2_singleton_puzhash)
+    spend_p2_singleton_puzhash = spend_p2_singleton.get_tree_hash()
+    spend_p2_singleton_solution = Program.to([[[parent_id, locked_amount]]])
+
+    proposal_validator = DAO_PROPOSAL_VALIDATOR_MOD.curry(
+        singleton_struct,
+        DAO_PROPOSAL_MOD_HASH,
+        DAO_PROPOSAL_TIMER_MOD_HASH,
+        CAT_MOD_HASH,
+        DAO_LOCKUP_MOD_HASH,
+        DAO_TREASURY_MOD_HASH,
+        CAT_TAIL_HASH,
+    )
+
+    # TREASURY_MOD_HASH
+    # PROPOSAL_VALIDATOR
+    # PROPOSAL_LENGTH
+    # PROPOSAL_SOFTCLOSE_LENGTH
+    # ATTENDANCE_REQUIRED
+    # PASS_MARGIN  ; this is a percentage 0 - 10,000 - 51% would be 5100
+    # PROPOSAL_SELF_DESTRUCT_TIME ; time in seconds after which proposals can be automatically closed
+    # ORACLE_SPEND_DELAY  ; timelock delay for oracle spend
+    self_destruct_time = 1000
+    full_treasury_puz: Program = DAO_TREASURY_MOD.curry(
+        DAO_TREASURY_MOD.get_tree_hash(),
+        proposal_validator,
+        40,
+        5,
+        1000,
+        5100,
+        self_destruct_time,
+        oracle_spend_delay,
+    )
+
+    # treasury_puzzle_hash = full_treasury_puz.get_tree_hash()
+
+    # (@ proposal_announcement (announcement_source delegated_puzzle_hash announcement_args spend_or_update_flag))
+    # proposal_validator_solution
+    # delegated_puzzle_reveal  ; this is the reveal of the puzzle announced by the proposal
+    # delegated_solution  ; this is not secure unless the delegated puzzle secures it
+
+    # Curry vals:
+    # SINGLETON_STRUCT  ; (SINGLETON_MOD_HASH (SINGLETON_ID . LAUNCHER_PUZZLE_HASH))
+    # PROPOSAL_MOD_HASH
+    # PROPOSAL_TIMER_MOD_HASH ; proposal timer needs to know which proposal created it, AND
+    # CAT_MOD_HASH
+    # TREASURY_MOD_HASH
+    # LOCKUP_MOD_HASH
+    # CAT_TAIL_HASH
+    # TREASURY_ID
+    # YES_VOTES  ; yes votes are +1, no votes don't tally - we compare yes_votes/total_votes at the end
+    # TOTAL_VOTES  ; how many people responded
+    # SPEND_OR_UPDATE_FLAG  ; this is one of 's', 'u', 'd' - other types may be added in the future
+    # PROPOSED_PUZ_HASH  ; this is what runs if this proposal is successful - the inner puzzle of this proposal
+    proposal: Program = DAO_PROPOSAL_MOD.curry(
+        singleton_struct,
+        DAO_PROPOSAL_MOD_HASH,
+        DAO_PROPOSAL_TIMER_MOD_HASH,
+        CAT_MOD_HASH,
+        DAO_TREASURY_MOD_HASH,
+        DAO_LOCKUP_MOD_HASH,
+        CAT_TAIL_HASH,
+        singleton_id,
+        950,
+        1200,
+        "s",
+        spend_p2_singleton_puzhash,
+    )
+    full_proposal = SINGLETON_MOD.curry(singleton_struct, proposal)
+
+    # Oracle spend
+    solution: Program = Program.to([0])
+    conds: Program = full_treasury_puz.run(solution)
+    assert len(conds.as_python()) == 3
+
+    # Run a passed proposal spend
+    # (@ proposal_announcement (announcement_source delegated_puzzle_hash announcement_args spend_or_update_flag))
+    # proposal_validator_solution
+    # delegated_puzzle_reveal  ; this is the reveal of the puzzle announced by the proposal
+    # delegated_solution  ; this is not secure unless the delegated puzzle secures it
+    solution: Program = Program.to(
+        [
+            "p",
+            [full_proposal.get_tree_hash(), spend_p2_singleton_puzhash, 0, "s"],
+            [singleton_id, 1200, 950, spend_amount],
+            spend_p2_singleton,
+            spend_p2_singleton_solution,
+        ]
+    )
+    conds = full_treasury_puz.run(solution)
+    assert len(conds.as_python()) == 6 + len(conditions)
+
+
+def test_lockup() -> None:
+    # PROPOSAL_MOD_HASH
+    # SINGLETON_MOD_HASH
+    # SINGLETON_LAUNCHER_PUZHASH
+    # LOCKUP_MOD_HASH
+    # CAT_MOD_HASH
+    # CAT_TAIL
+    # PREVIOUS_VOTES
+    # LOCKUP_TIME
+    # PUBKEY
+    CAT_TAIL: Program = Program.to("tail").get_tree_hash()
+
+    INNERPUZ = Program.to(1)
+    previous_votes = [0xFADEDDAB]
+
+    full_lockup_puz: Program = DAO_LOCKUP_MOD.curry(
+        DAO_PROPOSAL_MOD_HASH,
+        SINGLETON_MOD_HASH,
+        SINGLETON_LAUNCHER_HASH,
+        DAO_LOCKUP_MOD_HASH,
+        CAT_MOD_HASH,
+        CAT_TAIL,
+        previous_votes,
+        INNERPUZ,
+    )
+
+    # my_id  ; if my_id is 0 we do the return to return_address (exit voting mode) spend case
+    # innersolution
+    # my_amount
+    # new_proposal_vote_id_or_return_address
+    # vote_info
+    # proposal_curry_vals
+    my_id = Program.to("my_id").get_tree_hash()
+    lockup_coin_amount = 20
+    new_proposal = 0xBADDADAB
+    previous_votes = [new_proposal, 0xFADEDDAB]
+    child_puzhash = DAO_LOCKUP_MOD.curry(
+        DAO_PROPOSAL_MOD_HASH,
+        SINGLETON_MOD_HASH,
+        SINGLETON_LAUNCHER_HASH,
+        DAO_LOCKUP_MOD_HASH,
+        CAT_MOD_HASH,
+        CAT_TAIL,
+        previous_votes,
+        INNERPUZ,
+    ).get_tree_hash()
+    message = Program.to([new_proposal, lockup_coin_amount, 1, my_id]).get_tree_hash()
+    generated_conditions = [[51, child_puzhash, lockup_coin_amount], [62, message]]
+    # my_id  ; if my_id is 0 we do the return to return_address (exit voting mode) spend case
+    # inner_solution
+    # my_amount
+    # new_proposal_vote_id_or_return_address
+    # vote_info
+    # proposal_curry_vals
+    solution: Program = Program.to(
+        [
+            my_id,
+            generated_conditions,
+            20,
+            new_proposal,
+            [1, 2, 3, 4, 5, 6, 7, 8, 9, 0],
+            1,
+            20,
+            child_puzhash,
+            0,
+        ]
+    )
+    conds: Program = full_lockup_puz.run(solution)
+    assert len(conds.as_python()) == 6
+
+    solution = Program.to(
+        [
+            0,
+            generated_conditions,
+            20,
+            0xFADEDDAB,
+            [1, 2, 3, 4, 5, 6, 7, 8, 9, 0],
+        ]
+    )
+    conds = full_lockup_puz.run(solution)
+    assert len(conds.as_python()) == 3
+
+
+def test_proposal_innerpuz() -> None:
+    proposal_pass_percentage: uint64 = uint64(5100)
+    attendance_required: uint64 = uint64(1000)
+    proposal_timelock = 40
+    soft_close_length = 5
+    self_destruct_time = 1000
+    CAT_TAIL_HASH: Program = Program.to("tail").get_tree_hash()
+    # LOCKUP_TIME: uint64 = uint64(200)
+    oracle_spend_delay = 10
+
+    # Setup the treasury
+    treasury_id: Program = Program.to("treasury_id").get_tree_hash()
+    treasury_singleton_struct: Program = Program.to((SINGLETON_MOD_HASH, (treasury_id, SINGLETON_LAUNCHER_HASH)))
+    treasury_amount = 1
+
+    # setup the p2_singleton
+    p2_singleton = P2_SINGLETON_MOD.curry(treasury_singleton_struct)
+    p2_singleton_puzhash = p2_singleton.get_tree_hash()
+    parent_id = Program.to("parent").get_tree_hash()
+    locked_amount = 100001
+    spend_amount = 1100
+    conditions = [[51, 0xDABBAD00, 1000], [51, 0xCAFEF00D, 100]]
+    spend_p2_singleton = SPEND_P2_SINGLETON_MOD.curry(conditions, p2_singleton_puzhash)
+    spend_p2_singleton_puzhash = spend_p2_singleton.get_tree_hash()
+    spend_p2_singleton_solution = Program.to([[[parent_id, locked_amount]]])
+
+    proposal_validator = DAO_PROPOSAL_VALIDATOR_MOD.curry(
+        treasury_singleton_struct,
+        DAO_PROPOSAL_MOD_HASH,
+        DAO_PROPOSAL_TIMER_MOD_HASH,
+        CAT_MOD_HASH,
+        DAO_LOCKUP_MOD_HASH,
+        DAO_TREASURY_MOD_HASH,
+        CAT_TAIL_HASH,
+    )
+
+    treasury_inner_puz: Program = DAO_TREASURY_MOD.curry(
+        DAO_TREASURY_MOD_HASH,
+        proposal_validator,
+        proposal_timelock,
+        soft_close_length,
+        attendance_required,
+        proposal_pass_percentage,
+        self_destruct_time,
+        oracle_spend_delay,
+    )
+    treasury_inner_puzhash = treasury_inner_puz.get_tree_hash()
+
+    full_treasury_puz = SINGLETON_MOD.curry(treasury_singleton_struct, treasury_inner_puz)
+    full_treasury_puzhash = full_treasury_puz.get_tree_hash()
+
+    # Setup Proposal
+    proposal_id: Program = Program.to("proposal_id").get_tree_hash()
+    proposal_singleton_struct: Program = Program.to((SINGLETON_MOD_HASH, (proposal_id, SINGLETON_LAUNCHER_HASH)))
+
+    current_votes = 1200
+    yes_votes = 950
+    proposal: Program = DAO_PROPOSAL_MOD.curry(
+        proposal_singleton_struct,
+        DAO_PROPOSAL_MOD_HASH,
+        DAO_PROPOSAL_TIMER_MOD_HASH,
+        CAT_MOD_HASH,
+        DAO_TREASURY_MOD_HASH,
+        DAO_LOCKUP_MOD_HASH,
+        CAT_TAIL_HASH,
+        treasury_id,
+        yes_votes,
+        current_votes,
+        "s",
+        spend_p2_singleton_puzhash,
+    )
+    full_proposal: Program = SINGLETON_MOD.curry(proposal_singleton_struct, proposal)
+    full_proposal_puzhash: bytes32 = full_proposal.get_tree_hash()
+
+    treasury_solution: Program = Program.to(
+        [
+            "p",
+            [full_proposal_puzhash, spend_p2_singleton_puzhash, 0, "s"],
+            [proposal_id, current_votes, yes_votes, spend_amount],
+            spend_p2_singleton,
+            spend_p2_singleton_solution,
+        ]
+    )
+
+    proposal_solution = Program.to(
+        [
+            proposal_validator.get_tree_hash(),
+            0,
+            proposal_timelock,
+            proposal_pass_percentage,
+            attendance_required,
+            0,
+            soft_close_length,
+            self_destruct_time,
+            oracle_spend_delay,
+            0,
+        ]
+    )
+
+    # lineage_proof my_amount inner_solution
+    lineage_proof = [treasury_id, treasury_inner_puzhash, treasury_amount]
+    full_treasury_solution = Program.to([lineage_proof, treasury_amount, treasury_solution])
+    full_proposal_solution = Program.to([lineage_proof, 1, proposal_solution])
+
+    # Run the puzzles
+    treasury_conds: Program = conditions_dict_for_solution(full_treasury_puz, full_treasury_solution, INFINITE_COST)[1]
+    proposal_conds: Program = conditions_dict_for_solution(full_proposal, full_proposal_solution, INFINITE_COST)[1]
+
+    # Announcements
+    # Proposal CPA (proposal_timelock) <-> Treasury APA
+    # Proposal APA (proposal_id, proposal_timelock, soft_close_length) <-> Treasury CPA
+    treasury_apa = treasury_conds[ConditionOpcode.ASSERT_PUZZLE_ANNOUNCEMENT][0].vars[0]
+    proposal_cpa = proposal_conds[ConditionOpcode.CREATE_PUZZLE_ANNOUNCEMENT][0].vars[0]
+    assert std_hash(full_proposal_puzhash + proposal_cpa) == treasury_apa
+
+    treasury_cpas = [
+        std_hash(full_treasury_puzhash + cond.vars[0])
+        for cond in treasury_conds[ConditionOpcode.CREATE_PUZZLE_ANNOUNCEMENT]
+    ]
+    proposal_apas = [cond.vars[0] for cond in proposal_conds[ConditionOpcode.ASSERT_PUZZLE_ANNOUNCEMENT]]
+    assert treasury_cpas[0] == proposal_apas[1]
+
+    # Test Proposal to update treasury
+    # Set up new treasury params
+    new_proposal_pass_percentage: uint64 = uint64(2500)
+    new_attendance_required: uint64 = uint64(500)
+    new_proposal_timelock = 900
+    new_soft_close_length = 10
+    new_self_destruct_time = 1000
+    new_oracle_spend_delay = 20
+
+    update_proposal = DAO_UPDATE_MOD.curry(
+        DAO_TREASURY_MOD_HASH,
+        proposal_validator,
+        new_proposal_timelock,
+        new_soft_close_length,
+        new_attendance_required,
+        new_proposal_pass_percentage,
+        new_self_destruct_time,
+        new_oracle_spend_delay,
+    )
+    update_proposal_puzhash = update_proposal.get_tree_hash()
+    update_proposal_sol = Program.to([])
+
+    proposal: Program = DAO_PROPOSAL_MOD.curry(
+        proposal_singleton_struct,
+        DAO_PROPOSAL_MOD_HASH,
+        DAO_PROPOSAL_TIMER_MOD_HASH,
+        CAT_MOD_HASH,
+        DAO_TREASURY_MOD_HASH,
+        DAO_LOCKUP_MOD_HASH,
+        CAT_TAIL_HASH,
+        treasury_id,
+        yes_votes,
+        current_votes,
+        "u",
+        update_proposal_puzhash,
+    )
+    full_proposal: Program = SINGLETON_MOD.curry(proposal_singleton_struct, proposal)
+    full_proposal_puzhash: bytes32 = full_proposal.get_tree_hash()
+
+    treasury_solution: Program = Program.to(
+        [
+            "p",
+            [full_proposal_puzhash, update_proposal_puzhash, 0, "u"],
+            [proposal_id, current_votes, yes_votes, spend_amount],
+            update_proposal,
+            update_proposal_sol,
+        ]
+    )
+
+    proposal_solution = Program.to(
+        [
+            proposal_validator.get_tree_hash(),
+            0,
+            proposal_timelock,
+            proposal_pass_percentage,
+            attendance_required,
+            0,
+            soft_close_length,
+            self_destruct_time,
+            oracle_spend_delay,
+            0,
+        ]
+    )
+
+    lineage_proof = [treasury_id, treasury_inner_puzhash, treasury_amount]
+    full_treasury_solution = Program.to([lineage_proof, treasury_amount, treasury_solution])
+    full_proposal_solution = Program.to([lineage_proof, 1, proposal_solution])
+
+    treasury_conds: Program = conditions_dict_for_solution(full_treasury_puz, full_treasury_solution, INFINITE_COST)[1]
+    proposal_conds: Program = conditions_dict_for_solution(full_proposal, full_proposal_solution, INFINITE_COST)[1]
+
+    treasury_apa = treasury_conds[ConditionOpcode.ASSERT_PUZZLE_ANNOUNCEMENT][0].vars[0]
+    proposal_cpa = proposal_conds[ConditionOpcode.CREATE_PUZZLE_ANNOUNCEMENT][0].vars[0]
+    assert std_hash(full_proposal_puzhash + proposal_cpa) == treasury_apa
+
+    treasury_cpas = [
+        std_hash(full_treasury_puzhash + cond.vars[0])
+        for cond in treasury_conds[ConditionOpcode.CREATE_PUZZLE_ANNOUNCEMENT]
+    ]
+    proposal_apas = [cond.vars[0] for cond in proposal_conds[ConditionOpcode.ASSERT_PUZZLE_ANNOUNCEMENT]]
+    assert treasury_cpas[0] == proposal_apas[1]
diff --git a/tests/wallet/dao_wallet/test_dao_spendbundles.py b/tests/wallet/dao_wallet/test_dao_spendbundles.py
new file mode 100644
index 000000000..bc2295e80
--- /dev/null
+++ b/tests/wallet/dao_wallet/test_dao_spendbundles.py
@@ -0,0 +1,375 @@
+# type: ignore
+
+from __future__ import annotations
+
+from typing import List
+
+from blspy import AugSchemeMPL, G1Element, G2Element, PrivateKey
+
+from chia.types.blockchain_format.coin import Coin
+from chia.types.blockchain_format.program import Program
+from chia.types.blockchain_format.sized_bytes import bytes32
+from chia.types.coin_spend import CoinSpend
+from chia.types.spend_bundle import SpendBundle
+from chia.util.ints import uint64
+from chia.wallet.cat_wallet.cat_utils import SpendableCAT, unsigned_spend_bundle_for_spendable_cats
+from chia.wallet.lineage_proof import LineageProof
+from chia.wallet.puzzles.cat_loader import CAT_MOD
+from chia.wallet.puzzles.load_clvm import load_clvm
+from chia.wallet.puzzles.p2_delegated_puzzle_or_hidden_puzzle import puzzle_for_pk, solution_for_conditions
+
+SINGLETON_MOD: Program = load_clvm("singleton_top_layer_v1_1.clsp")
+SINGLETON_LAUNCHER: Program = load_clvm("singleton_launcher.clsp")
+DAO_LOCKUP_MOD: Program = load_clvm("dao_lockup.clvm")
+DAO_PROPOSAL_TIMER_MOD: Program = load_clvm("dao_proposal_timer.clvm")
+DAO_PROPOSAL_MOD: Program = load_clvm("dao_proposal.clvm")
+DAO_TREASURY_MOD: Program = load_clvm("dao_treasury.clvm")
+P2_SINGLETON_MOD: Program = load_clvm("p2_singleton_or_delayed_puzhash.clvm")
+
+CAT_MOD_HASH: bytes32 = CAT_MOD.get_tree_hash()
+
+
+def test_vote_from_locked_state():
+    current_cat_issuance: uint64 = uint64(1000)
+    proposal_pass_percentage: uint64 = uint64(15)
+    CAT_TAIL: Program = Program.to("tail").get_tree_hash()
+    treasury_id: Program = Program.to("treasury").get_tree_hash()
+    LOCKUP_TIME: uint64 = uint64(200)
+    PREVIOUS_VOTES: List[bytes] = [0xFADEDDAB]
+
+    proposal_id: Program = Program.to("singleton_id").get_tree_hash()
+    singleton_struct: Program = Program.to(
+        (SINGLETON_MOD.get_tree_hash(), (proposal_id, SINGLETON_LAUNCHER.get_tree_hash()))
+    )
+
+    current_votes: uint64 = uint64(0)
+    total_votes: uint64 = uint64(0)
+    proposal_innerpuz: Program = Program.to(1)
+
+    # SINGLETON_STRUCT
+    # PROPOSAL_MOD_HASH
+    # PROPOSAL_TIMER_MOD_HASH
+    # CAT_MOD_HASH
+    # TREASURY_MOD_HASH
+    # LOCKUP_MOD_HASH  ; this is the mod already curried with what it needs - should still be a constant
+    # CAT_TAIL
+    # CURRENT_CAT_ISSUANCE
+    # PROPOSAL_PASS_PERCENTAGE
+    # TREASURY_ID
+    # PROPOSAL_TIMELOCK
+    # VOTES_SUM  ; yes votes are +1, no votes are -1
+    # TOTAL_VOTES  ; how many people responded
+    # INNERPUZ  ; this is what runs if this proposal is successful
+
+    full_proposal: Program = DAO_PROPOSAL_MOD.curry(
+        singleton_struct,
+        DAO_PROPOSAL_MOD.get_tree_hash(),
+        DAO_PROPOSAL_TIMER_MOD.get_tree_hash(),
+        CAT_MOD.get_tree_hash(),
+        DAO_TREASURY_MOD.get_tree_hash(),
+        DAO_LOCKUP_MOD.get_tree_hash(),
+        CAT_TAIL,
+        current_cat_issuance,
+        proposal_pass_percentage,
+        treasury_id,
+        LOCKUP_TIME,
+        current_votes,
+        total_votes,
+        proposal_innerpuz,
+    )
+
+    # Example seed, used to generate private key. Taken from the github readme.
+    seed: bytes = bytes(
+        [
+            0,
+            50,
+            6,
+            244,
+            24,
+            199,
+            1,
+            25,
+            52,
+            88,
+            192,
+            19,
+            18,
+            12,
+            89,
+            6,
+            220,
+            18,
+            102,
+            58,
+            209,
+            82,
+            12,
+            62,
+            89,
+            110,
+            182,
+            9,
+            44,
+            20,
+            254,
+            22,
+        ]
+    )
+    sk: PrivateKey = AugSchemeMPL.key_gen(seed)
+    pk: G1Element = sk.get_g1()
+
+    # PROPOSAL_MOD_HASH
+    # SINGLETON_MOD_HASH
+    # SINGLETON_LAUNCHER_PUZHASH
+    # LOCKUP_MOD_HASH
+    # CAT_MOD_HASH
+    # CAT_TAIL
+    # PREVIOUS_VOTES
+    # LOCKUP_TIME
+    # PUBKEY
+
+    innerpuz = puzzle_for_pk(pk)
+    full_lockup_puz: Program = DAO_LOCKUP_MOD.curry(
+        DAO_PROPOSAL_MOD.get_tree_hash(),
+        SINGLETON_MOD.get_tree_hash(),
+        SINGLETON_LAUNCHER.get_tree_hash(),
+        DAO_LOCKUP_MOD.get_tree_hash(),
+        CAT_MOD.get_tree_hash(),
+        CAT_TAIL,
+        PREVIOUS_VOTES,
+        LOCKUP_TIME,
+        innerpuz,
+    )
+
+    lockup_coin_amount: uint64 = uint64(200)
+    lockup_parent_id: bytes32 = Coin(
+        Program.to("fake_parent").get_tree_hash(),
+        CAT_MOD.curry(CAT_MOD_HASH, CAT_TAIL, Program.to(1)).get_tree_hash(),
+        lockup_coin_amount,
+    ).name()
+
+    cat_lockup_puzzlehash: bytes32 = CAT_MOD.curry(CAT_MOD_HASH, CAT_TAIL, full_lockup_puz)
+    lockup_coin: Coin = Coin(lockup_parent_id, cat_lockup_puzzlehash.get_tree_hash(), lockup_coin_amount)
+
+    # TREASURY_MOD_HASH
+    # PROPOSAL_TIMER_MOD_HASH
+    # CURRENT_CAT_ISSUANCE
+    # PROPOSAL_PASS_PERCENTAGE
+    # TREASURY_ID
+    # PROPOSAL_TIMELOCK
+    # SUM_VOTES
+    # TOTAL_VOTES
+    # INNERPUZHASH
+
+    proposal_curry_vals: List = [
+        DAO_TREASURY_MOD.get_tree_hash(),
+        DAO_PROPOSAL_TIMER_MOD.get_tree_hash(),
+        current_cat_issuance,
+        proposal_pass_percentage,
+        treasury_id,
+        LOCKUP_TIME,
+        current_votes,
+        total_votes,
+        proposal_innerpuz.get_tree_hash(),
+    ]
+
+    # my_id  ; if my_id is 0 we do the return to return_address (exit voting mode) spend case
+    # inner_solution
+    # my_amount
+    # new_proposal_vote_id
+    # vote_info
+    # proposal_curry_vals
+    NEW_PREVIOUS_VOTES = [proposal_id, 0xFADEDDAB]
+    child_puzhash: Program = DAO_LOCKUP_MOD.curry(
+        DAO_PROPOSAL_MOD.get_tree_hash(),
+        SINGLETON_MOD.get_tree_hash(),
+        SINGLETON_LAUNCHER.get_tree_hash(),
+        DAO_LOCKUP_MOD.get_tree_hash(),
+        CAT_MOD.get_tree_hash(),
+        CAT_TAIL,
+        NEW_PREVIOUS_VOTES,  # this is the important line
+        LOCKUP_TIME,
+        innerpuz,
+    ).get_tree_hash()
+    message = Program.to([proposal_id, lockup_coin_amount, 1, lockup_coin.name()]).get_tree_hash()
+    conditions = [[51, child_puzhash, lockup_coin_amount], [62, message]]
+    inner_sol = solution_for_conditions(conditions)
+
+    solution: Program = Program.to(
+        [
+            lockup_coin.name(),
+            inner_sol,
+            lockup_coin_amount,
+            proposal_id,
+            proposal_curry_vals,
+            1,
+        ]
+    )
+
+    sc_list: List[SpendableCAT] = [
+        SpendableCAT(
+            coin=lockup_coin,
+            limitations_program_hash=CAT_TAIL,
+            inner_puzzle=full_lockup_puz,
+            inner_solution=solution,
+            lineage_proof=LineageProof(
+                Program.to("fake_parent").get_tree_hash(), Program.to(1).get_tree_hash(), lockup_coin_amount
+            ),
+        )
+    ]
+
+    singleton_proposal_puzzle: Program = SINGLETON_MOD.curry(singleton_struct, full_proposal)
+
+    proposal_parent: Coin = Coin(
+        Program.to("prop_parent").get_tree_hash(),
+        SINGLETON_MOD.curry(singleton_struct, Program.to(1)).get_tree_hash(),
+        1,
+    )
+    proposal_coin: Coin = Coin(proposal_parent.name(), singleton_proposal_puzzle.get_tree_hash(), 1)
+    # vote_amount_or_solution
+    # vote_info_or_p2_singleton_mod_hash
+    # vote_coin_id  ; set this to 0 if we have passed
+    # previous_votes
+    # pubkey
+    proposal_solution: Program = Program.to(
+        [lockup_coin_amount, 1, lockup_coin.name(), PREVIOUS_VOTES, innerpuz.get_tree_hash()]
+    )
+    singleton_solution: Program = Program.to(
+        [[Program.to("prop_parent").get_tree_hash(), Program.to(1).get_tree_hash(), 1], 1, proposal_solution]
+    )
+    cs_list: List[CoinSpend] = [(CoinSpend(proposal_coin, singleton_proposal_puzzle, singleton_solution))]
+
+    #     (sha256tree (list
+    # new_proposal_vote_id_or_return_address
+    # vote_info
+    # )
+    # )
+    usb: SpendBundle = unsigned_spend_bundle_for_spendable_cats(CAT_MOD, sc_list)
+    sig: G2Element = AugSchemeMPL.sign(sk, bytes(lockup_coin.name() + Program.to([proposal_id, 1]).get_tree_hash()))
+    spend_bundle: SpendBundle = SpendBundle(cs_list, sig)
+    spend_bundle: SpendBundle = usb.aggregate([usb, spend_bundle])
+    raise "unfinished"
+    # breakpoint()
+    # TODO: add asserts here
+
+
+def test_close_proposal():
+    current_cat_issuance: uint64 = uint64(1000)
+    proposal_pass_percentage: uint64 = uint64(15)
+    CAT_TAIL: Program = Program.to("tail").get_tree_hash()
+    treasury_id: Program = Program.to("treasury").get_tree_hash()
+    LOCKUP_TIME: uint64 = uint64(200)
+    # PREVIOUS_VOTES: List[bytes] = [0xFADEDDAB]
+
+    proposal_id: Program = Program.to("singleton_id").get_tree_hash()
+    singleton_struct: Program = Program.to(
+        (SINGLETON_MOD.get_tree_hash(), (proposal_id, SINGLETON_LAUNCHER.get_tree_hash()))
+    )
+
+    current_votes: uint64 = uint64(0)
+    total_votes: uint64 = uint64(0)
+    proposal_innerpuz: Program = Program.to(1)
+
+    # SINGLETON_STRUCT
+    # PROPOSAL_MOD_HASH
+    # PROPOSAL_TIMER_MOD_HASH
+    # CAT_MOD_HASH
+    # TREASURY_MOD_HASH
+    # LOCKUP_MOD_HASH  ; this is the mod already curried with what it needs - should still be a constant
+    # CAT_TAIL
+    # CURRENT_CAT_ISSUANCE
+    # PROPOSAL_PASS_PERCENTAGE
+    # TREASURY_ID
+    # PROPOSAL_TIMELOCK
+    # VOTES_SUM  ; yes votes are +1, no votes are -1
+    # TOTAL_VOTES  ; how many people responded
+    # INNERPUZ  ; this is what runs if this proposal is successful
+
+    full_proposal: Program = DAO_PROPOSAL_MOD.curry(
+        singleton_struct,
+        DAO_PROPOSAL_MOD.get_tree_hash(),
+        DAO_PROPOSAL_TIMER_MOD.get_tree_hash(),
+        CAT_MOD.get_tree_hash(),
+        DAO_TREASURY_MOD.get_tree_hash(),
+        DAO_LOCKUP_MOD.get_tree_hash(),
+        CAT_TAIL,
+        current_cat_issuance,
+        proposal_pass_percentage,
+        treasury_id,
+        LOCKUP_TIME,
+        current_votes,
+        total_votes,
+        proposal_innerpuz,
+    )
+
+    # Proposal spend
+
+    singleton_struct: Program = Program.to(
+        (SINGLETON_MOD.get_tree_hash(), (treasury_id, SINGLETON_LAUNCHER.get_tree_hash()))
+    )
+
+    full_treasury_puz = DAO_TREASURY_MOD.curry(
+        singleton_struct,
+        DAO_PROPOSAL_MOD.get_tree_hash(),
+        DAO_PROPOSAL_TIMER_MOD.get_tree_hash(),
+        P2_SINGLETON_MOD,
+        CAT_MOD_HASH,
+        CAT_TAIL,
+        current_cat_issuance,
+        proposal_pass_percentage,
+        LOCKUP_TIME,
+    )
+
+    singleton_treasury: Program = SINGLETON_MOD.curry(singleton_struct, full_treasury_puz)
+
+    treasury_parent: Coin = Coin(
+        Program.to("treasury_parent").get_tree_hash(),
+        SINGLETON_MOD.curry(singleton_struct, Program.to(1)).get_tree_hash(),
+        5001,
+    )
+
+    treasury_coin: Coin = Coin(
+        treasury_parent.name(),
+        singleton_treasury.get_tree_hash(),
+        5001,
+    )
+
+    # Proposal Timer spend
+
+    timer_puz = DAO_PROPOSAL_TIMER_MOD.curry(
+        DAO_PROPOSAL_MOD.get_tree_hash(),
+        DAO_PROPOSAL_TIMER_MOD.get_tree_hash(),
+        CAT_MOD_HASH,
+        CAT_TAIL,
+        current_cat_issuance,
+        LOCKUP_TIME,
+        proposal_pass_percentage,
+        singleton_struct,
+        treasury_id,
+    )
+
+    # Proposal spend
+
+    singleton_proposal_puzzle: Program = SINGLETON_MOD.curry(singleton_struct, full_proposal)
+
+    proposal_parent: Coin = Coin(
+        Program.to("prop_parent").get_tree_hash(),
+        SINGLETON_MOD.curry(singleton_struct, Program.to(1)).get_tree_hash(),
+        1,
+    )
+    proposal_coin: Coin = Coin(proposal_parent.name(), singleton_proposal_puzzle.get_tree_hash(), 1)
+    # vote_amount_or_solution
+    # vote_info_or_p2_singleton_mod_hash
+    # vote_coin_id  ; set this to 0 if we have passed
+    # previous_votes
+    # pubkey
+    payout_solution = Program.to([])
+    proposal_solution: Program = Program.to(
+        [
+            payout_solution,
+            P2_SINGLETON_MOD.get_tree_hash(),
+            0,
+        ]
+    )
+
+    raise RuntimeError("TODO: ", treasury_coin, timer_puz, proposal_coin, proposal_solution)
diff --git a/tests/wallet/dao_wallet/test_dao_wallets.py b/tests/wallet/dao_wallet/test_dao_wallets.py
new file mode 100644
index 000000000..1260c5330
--- /dev/null
+++ b/tests/wallet/dao_wallet/test_dao_wallets.py
@@ -0,0 +1,1766 @@
+from __future__ import annotations
+
+# mypy: ignore-errors
+import asyncio
+import time
+from typing import Any, Awaitable, Callable, Dict, List, Optional, Tuple
+
+import pytest
+from blspy import G1Element
+
+from chia.consensus.block_rewards import calculate_base_farmer_reward, calculate_pool_reward
+from chia.rpc.wallet_rpc_api import WalletRpcApi
+from chia.rpc.wallet_rpc_client import WalletRpcClient
+from chia.simulator.setup_nodes import SimulatorsAndWallets, SimulatorsAndWalletsServices
+from chia.simulator.simulator_protocol import FarmNewBlockProtocol
+from chia.simulator.time_out_assert import adjusted_timeout, time_out_assert, time_out_assert_not_none
+from chia.types.blockchain_format.program import Program
+from chia.types.blockchain_format.sized_bytes import bytes32
+from chia.types.peer_info import PeerInfo
+from chia.util.bech32m import encode_puzzle_hash
+from chia.util.ints import uint16, uint32, uint64
+from chia.wallet.dao_wallet.dao_info import DAORules
+from chia.wallet.dao_wallet.dao_wallet import DAOWallet
+from chia.wallet.transaction_record import TransactionRecord
+from tests.util.rpc import validate_get_routes
+
+
+async def get_proposal_state(wallet: DAOWallet, index: int) -> Tuple[bool, bool]:
+    return wallet.dao_info.proposals_list[index].passed, wallet.dao_info.proposals_list[index].closed
+
+
+async def rpc_state(
+    timeout: float,
+    async_function: Callable[[Dict[str, Any]], Awaitable[Dict]],
+    params: List[Dict],
+    condition_func: Callable[[Dict[str, Any]], bool],
+    result: Optional[Any] = None,
+) -> Dict:
+    __tracebackhide__ = True
+
+    timeout = adjusted_timeout(timeout=timeout)
+
+    start = time.monotonic()
+
+    while True:
+        resp = await async_function(*params)
+        assert isinstance(resp, dict)
+        try:
+            if result:
+                if condition_func(resp) == result:
+                    return True
+            else:
+                if condition_func(resp):
+                    return resp
+        except IndexError:
+            continue
+
+        now = time.monotonic()
+        elapsed = now - start
+        if elapsed >= timeout:
+            raise asyncio.TimeoutError(
+                f"timed out while waiting for {async_function.__name__}(): {elapsed} >= {timeout}",
+            )
+
+        await asyncio.sleep(0.3)
+
+
+puzzle_hash_0 = bytes32(32 * b"0")
+
+
+@pytest.mark.parametrize(
+    "trusted",
+    [True, False],
+)
+@pytest.mark.asyncio
+async def test_dao_creation(self_hostname: str, three_wallet_nodes: SimulatorsAndWallets, trusted: bool) -> None:
+    num_blocks = 3
+    full_nodes, wallets, _ = three_wallet_nodes
+    full_node_api = full_nodes[0]
+    full_node_server = full_node_api.server
+    wallet_node_0, server_0 = wallets[0]
+    wallet_node_1, server_1 = wallets[1]
+    wallet = wallet_node_0.wallet_state_manager.main_wallet
+    wallet_1 = wallet_node_1.wallet_state_manager.main_wallet
+    ph = await wallet.get_new_puzzlehash()
+    ph_1 = await wallet_1.get_new_puzzlehash()
+
+    if trusted:
+        wallet_node_0.config["trusted_peers"] = {
+            full_node_api.full_node.server.node_id.hex(): full_node_api.full_node.server.node_id.hex()
+        }
+        wallet_node_1.config["trusted_peers"] = {
+            full_node_api.full_node.server.node_id.hex(): full_node_api.full_node.server.node_id.hex()
+        }
+    else:
+        wallet_node_0.config["trusted_peers"] = {}
+        wallet_node_1.config["trusted_peers"] = {}
+
+    await server_0.start_client(PeerInfo(self_hostname, uint16(full_node_server._port)), None)
+    await server_1.start_client(PeerInfo(self_hostname, uint16(full_node_server._port)), None)
+
+    for i in range(0, num_blocks):
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(ph))
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(ph_1))
+    await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    funds = sum(
+        [calculate_pool_reward(uint32(i)) + calculate_base_farmer_reward(uint32(i)) for i in range(1, num_blocks + 1)]
+    )
+
+    await time_out_assert(20, wallet.get_confirmed_balance, funds)
+    await time_out_assert(20, full_node_api.wallet_is_synced, True, wallet_node_0)
+
+    cat_amt = 2000
+    dao_rules = DAORules(
+        proposal_timelock=uint64(10),
+        soft_close_length=uint64(5),
+        attendance_required=uint64(1000),  # 10%
+        pass_percentage=uint64(5100),  # 51%
+        self_destruct_length=uint64(20),
+        oracle_spend_delay=uint64(10),
+        proposal_minimum_amount=uint64(1),
+    )
+
+    # Try to create a DAO with more CATs than xch balance
+    with pytest.raises(ValueError) as e_info:
+        async with wallet_node_0.wallet_state_manager.lock:
+            dao_wallet_0 = await DAOWallet.create_new_dao_and_wallet(
+                wallet_node_0.wallet_state_manager,
+                wallet,
+                funds + 1,
+                dao_rules,
+            )
+    assert e_info.value.args[0] == f"Your balance of {funds} mojos is not enough to create {funds + 1} CATs"
+
+    async with wallet_node_0.wallet_state_manager.lock:
+        dao_wallet_0 = await DAOWallet.create_new_dao_and_wallet(
+            wallet_node_0.wallet_state_manager,
+            wallet,
+            uint64(cat_amt * 2),
+            dao_rules,
+        )
+        assert dao_wallet_0 is not None
+
+    # Get the full node sim to process the wallet creation spend
+    tx_queue: List[TransactionRecord] = await wallet_node_0.wallet_state_manager.tx_store.get_not_sent()
+    tx_record = tx_queue[0]
+    await full_node_api.process_transaction_records(records=[tx_record])
+    await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    # Check the spend was successful
+    treasury_id = dao_wallet_0.dao_info.treasury_id
+    await time_out_assert(
+        60,
+        dao_wallet_0.is_spend_retrievable,
+        True,
+        treasury_id,
+    )
+    # Farm enough blocks to pass the oracle_spend_delay and then complete the treasury eve spend
+    for i in range(1, 11):
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    # check the dao wallet balances
+    assert (await dao_wallet_0.get_confirmed_balance()) == uint64(1)
+    assert (await dao_wallet_0.get_unconfirmed_balance()) == uint64(1)
+    assert (await dao_wallet_0.get_pending_change_balance()) == uint64(0)
+    assert (await dao_wallet_0.get_spendable_balance()) == uint64(1)
+
+    # check select coins
+    no_coins = await dao_wallet_0.select_coins(uint64(2))
+    assert no_coins == set()
+    selected_coins = await dao_wallet_0.select_coins(uint64(1))
+    assert len(selected_coins) == 1
+
+    # get the cat wallets
+    cat_wallet_0 = dao_wallet_0.wallet_state_manager.wallets[dao_wallet_0.dao_info.cat_wallet_id]
+    dao_cat_wallet_0 = dao_wallet_0.wallet_state_manager.wallets[dao_wallet_0.dao_info.dao_cat_wallet_id]
+    cat_wallet_0_bal = await cat_wallet_0.get_confirmed_balance()
+    assert cat_wallet_0_bal == cat_amt * 2
+
+    # Create the other user's wallet from the treasury id
+    async with wallet_node_0.wallet_state_manager.lock:
+        dao_wallet_1 = await DAOWallet.create_new_dao_wallet_for_existing_dao(
+            wallet_node_1.wallet_state_manager,
+            wallet_1,
+            treasury_id,
+        )
+    assert dao_wallet_1 is not None
+    assert dao_wallet_0.dao_info.treasury_id == dao_wallet_1.dao_info.treasury_id
+
+    # Get the cat wallets for wallet_1
+    cat_wallet_1 = dao_wallet_1.wallet_state_manager.wallets[dao_wallet_1.dao_info.cat_wallet_id]
+    assert cat_wallet_1
+
+    # Send some cats to the dao_cat lockup
+    dao_cat_amt = uint64(100)
+    async with wallet_node_0.wallet_state_manager.lock:
+        txs, new_coins = await dao_wallet_0.create_new_dao_cats(dao_cat_amt, push=True)
+    sb = txs[0].spend_bundle
+    await time_out_assert_not_none(5, full_node_api.full_node.mempool_manager.get_spendbundle, sb.name())
+    await full_node_api.process_transaction_records(records=txs)
+
+    # Give the full node a moment to catch up if there are no trusted peers
+    if not trusted:
+        await asyncio.sleep(1)
+    for i in range(1, num_blocks):
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    # Test that we can get spendable coins from both cat and dao_cat wallet
+    fake_proposal_id = Program.to("proposal_id").get_tree_hash()
+    spendable_coins = await dao_cat_wallet_0.wallet_state_manager.get_spendable_coins_for_wallet(
+        dao_cat_wallet_0.id(), None
+    )
+
+    assert len(spendable_coins) > 0
+    coins = await dao_cat_wallet_0.advanced_select_coins(1, fake_proposal_id)
+    assert len(coins) > 0
+    # check that we have selected the coin from dao_cat_wallet
+    assert list(coins)[0].coin.amount == dao_cat_amt
+
+    # send some cats from wallet_0 to wallet_1 so we can test voting
+    cat_txs = await cat_wallet_0.generate_signed_transactions([cat_amt], [ph_1])
+    await wallet.wallet_state_manager.add_pending_transaction(cat_txs[0])
+    sb = cat_txs[0].spend_bundle
+    await time_out_assert_not_none(5, full_node_api.full_node.mempool_manager.get_spendbundle, sb.name())
+    await full_node_api.process_transaction_records(records=cat_txs)
+
+    for i in range(1, num_blocks):
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    await time_out_assert(10, cat_wallet_1.get_confirmed_balance, cat_amt)
+
+    # Smaller tests of dao_wallet funcs for coverage
+    # adjust filter level
+    await dao_wallet_0.adjust_filter_level(uint64(10))
+    assert dao_wallet_0.dao_info.filter_below_vote_amount == uint64(10)
+
+    assert dao_wallet_0.puzzle_for_pk(G1Element()) == Program.to(0)
+    assert dao_wallet_0.puzzle_hash_for_pk(G1Element()) == Program.to(0).get_tree_hash()
+    assert (await dao_wallet_0.get_new_puzzle()) == Program.to(0)
+
+    await dao_wallet_0.set_name("Renamed Wallet")
+    assert dao_wallet_0.get_name() == "Renamed Wallet"
+
+    new_inner_puzhash = await dao_wallet_0.get_new_p2_inner_hash()
+    assert isinstance(new_inner_puzhash, bytes32)
+
+    # generate new dao spends with bad cat details
+    with pytest.raises(ValueError) as e_info:
+        # negative cat amount
+        await DAOWallet.generate_new_dao_spend(wallet.wallet_state_manager, wallet, dao_rules, -100)
+    assert e_info.value.args[0] == "amount_of_cats must be >= 0, or None"
+
+    with pytest.raises(ValueError) as e_info:
+        # create 0 cats
+        await DAOWallet.generate_new_dao_spend(wallet.wallet_state_manager, wallet, dao_rules, 0)
+    assert e_info.value.args[0] == "amount_of_cats must be > 0 or cat_tail_hash must be specified"
+
+    with pytest.raises(ValueError) as e_info:
+        # create with existing tail
+        await DAOWallet.generate_new_dao_spend(wallet.wallet_state_manager, wallet, dao_rules, 100, bytes32(b"a" * 32))
+    assert e_info.value.args[0] == "cannot create voting cats and use existing cat_tail_hash"
+
+    # generate the spend successfully
+    new_dao_spend = await DAOWallet.generate_new_dao_spend(wallet.wallet_state_manager, wallet, dao_rules, cat_amt)
+
+
+@pytest.mark.parametrize(
+    "trusted",
+    [True, False],
+)
+@pytest.mark.asyncio
+async def test_dao_funding(self_hostname: str, three_wallet_nodes: SimulatorsAndWallets, trusted: bool) -> None:
+    num_blocks = 3
+    full_nodes, wallets, _ = three_wallet_nodes
+    full_node_api = full_nodes[0]
+    full_node_server = full_node_api.server
+    wallet_node_0, server_0 = wallets[0]
+    wallet_node_1, server_1 = wallets[1]
+    wallet_node_2, server_2 = wallets[2]
+    wallet = wallet_node_0.wallet_state_manager.main_wallet
+    wallet_1 = wallet_node_1.wallet_state_manager.main_wallet
+    wallet_2 = wallet_node_1.wallet_state_manager.main_wallet
+    ph = await wallet.get_new_puzzlehash()
+    ph_1 = await wallet_1.get_new_puzzlehash()
+    ph_2 = await wallet_2.get_new_puzzlehash()
+
+    if trusted:
+        wallet_node_0.config["trusted_peers"] = {
+            full_node_api.full_node.server.node_id.hex(): full_node_api.full_node.server.node_id.hex()
+        }
+        wallet_node_1.config["trusted_peers"] = {
+            full_node_api.full_node.server.node_id.hex(): full_node_api.full_node.server.node_id.hex()
+        }
+        wallet_node_2.config["trusted_peers"] = {
+            full_node_api.full_node.server.node_id.hex(): full_node_api.full_node.server.node_id.hex()
+        }
+    else:
+        wallet_node_0.config["trusted_peers"] = {}
+        wallet_node_1.config["trusted_peers"] = {}
+        wallet_node_2.config["trusted_peers"] = {}
+
+    await server_0.start_client(PeerInfo(self_hostname, uint16(full_node_server._port)), None)
+    await server_1.start_client(PeerInfo(self_hostname, uint16(full_node_server._port)), None)
+    await server_2.start_client(PeerInfo(self_hostname, uint16(full_node_server._port)), None)
+
+    for i in range(0, num_blocks):
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(ph))
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(ph_1))
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(ph_2))
+    await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    funds = sum(
+        [calculate_pool_reward(uint32(i)) + calculate_base_farmer_reward(uint32(i)) for i in range(1, num_blocks + 1)]
+    )
+
+    await time_out_assert(20, wallet.get_confirmed_balance, funds)
+    await time_out_assert(20, full_node_api.wallet_is_synced, True, wallet_node_0)
+
+    cat_amt = 300000
+    dao_rules = DAORules(
+        proposal_timelock=uint64(10),
+        soft_close_length=uint64(5),
+        attendance_required=uint64(1000),  # 10%
+        pass_percentage=uint64(5100),  # 51%
+        self_destruct_length=uint64(20),
+        oracle_spend_delay=uint64(10),
+        proposal_minimum_amount=uint64(1),
+    )
+
+    async with wallet_node_0.wallet_state_manager.lock:
+        dao_wallet_0 = await DAOWallet.create_new_dao_and_wallet(
+            wallet_node_0.wallet_state_manager,
+            wallet,
+            uint64(cat_amt),
+            dao_rules,
+        )
+        assert dao_wallet_0 is not None
+
+    treasury_id = dao_wallet_0.dao_info.treasury_id
+
+    # Get the full node sim to process the wallet creation spend
+    tx_queue: List[TransactionRecord] = await wallet_node_0.wallet_state_manager.tx_store.get_not_sent()
+    tx_record = tx_queue[0]
+    await full_node_api.process_transaction_records(records=[tx_record])
+    await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    # Farm enough blocks to pass the oracle_spend_delay and then complete the treasury eve spend
+    for i in range(1, 11):
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+    # async with wallet_node_0.wallet_state_manager.lock:
+    #     await dao_wallet_0.generate_treasury_eve_spend()
+    # tx_queue: List[TransactionRecord] = await wallet_node_0.wallet_state_manager.tx_store.get_not_sent()
+    # tx_record = tx_queue[0]
+    # await full_node_api.process_transaction_records(records=[tx_record])
+    # await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    # get the cat wallets
+    cat_wallet_0 = dao_wallet_0.wallet_state_manager.wallets[dao_wallet_0.dao_info.cat_wallet_id]
+    await time_out_assert(10, cat_wallet_0.get_confirmed_balance, cat_amt)
+
+    # Create funding spends for xch and cat
+    xch_funds = uint64(500000)
+    cat_funds = uint64(100000)
+    funding_tx = await dao_wallet_0.create_add_money_to_treasury_spend(xch_funds)
+    funding_sb = funding_tx.spend_bundle
+    await time_out_assert_not_none(5, full_node_api.full_node.mempool_manager.get_spendbundle, funding_sb.name())
+    await full_node_api.process_transaction_records(records=[funding_tx])
+
+    if not trusted:
+        await asyncio.sleep(1)
+    for i in range(1, num_blocks):
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    # Check that the funding spend is recognized by both dao wallets
+    await time_out_assert(10, dao_wallet_0.get_balance_by_asset_type, xch_funds)
+
+    cat_funding_tx = await dao_wallet_0.create_add_money_to_treasury_spend(
+        cat_funds, funding_wallet_id=cat_wallet_0.id()
+    )
+    cat_funding_sb = cat_funding_tx.spend_bundle
+    await time_out_assert_not_none(5, full_node_api.full_node.mempool_manager.get_spendbundle, cat_funding_sb.name())
+    await full_node_api.process_transaction_records(records=[cat_funding_tx])
+
+    if not trusted:
+        await asyncio.sleep(1)
+    for i in range(1, num_blocks):
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    await time_out_assert(10, cat_wallet_0.get_confirmed_balance, cat_amt - cat_funds)
+
+    # Check that the funding spend is found
+    cat_id = bytes32.from_hexstr(cat_wallet_0.get_asset_id())
+    await time_out_assert(10, dao_wallet_0.get_balance_by_asset_type, cat_funds, cat_id)
+
+    # Create the other user's wallet from the treasury id
+    async with wallet_node_0.wallet_state_manager.lock:
+        dao_wallet_1 = await DAOWallet.create_new_dao_wallet_for_existing_dao(
+            wallet_node_1.wallet_state_manager,
+            wallet_1,
+            treasury_id,
+        )
+    assert dao_wallet_1 is not None
+    assert dao_wallet_1.dao_info.treasury_id == dao_wallet_1.dao_info.treasury_id
+
+    # Get the cat wallets for wallet_1
+    cat_wallet_1 = dao_wallet_1.wallet_state_manager.wallets[dao_wallet_1.dao_info.cat_wallet_id]
+    assert cat_wallet_1
+    assert cat_wallet_1.cat_info.limitations_program_hash == cat_id
+
+    await time_out_assert(10, dao_wallet_1.get_balance_by_asset_type, xch_funds)
+    await time_out_assert(10, dao_wallet_1.get_balance_by_asset_type, cat_funds, cat_id)
+
+    assert dao_wallet_0.dao_info.assets == [None, cat_id]
+    assert dao_wallet_1.dao_info.assets == [None, cat_id]
+
+
+@pytest.mark.parametrize(
+    "trusted",
+    [True, False],
+)
+@pytest.mark.asyncio
+async def test_dao_proposals(self_hostname: str, three_wallet_nodes: SimulatorsAndWallets, trusted: bool) -> None:
+    num_blocks = 3
+    full_nodes, wallets, _ = three_wallet_nodes
+    full_node_api = full_nodes[0]
+    full_node_server = full_node_api.server
+    wallet_node_0, server_0 = wallets[0]
+    wallet_node_1, server_1 = wallets[1]
+    wallet_node_2, server_2 = wallets[2]
+    wallet = wallet_node_0.wallet_state_manager.main_wallet
+    wallet_1 = wallet_node_1.wallet_state_manager.main_wallet
+    wallet_2 = wallet_node_2.wallet_state_manager.main_wallet
+    ph = await wallet.get_new_puzzlehash()
+    ph_1 = await wallet_1.get_new_puzzlehash()
+    ph_2 = await wallet_2.get_new_puzzlehash()
+
+    if trusted:
+        wallet_node_0.config["trusted_peers"] = {
+            full_node_api.full_node.server.node_id.hex(): full_node_api.full_node.server.node_id.hex()
+        }
+        wallet_node_1.config["trusted_peers"] = {
+            full_node_api.full_node.server.node_id.hex(): full_node_api.full_node.server.node_id.hex()
+        }
+        wallet_node_2.config["trusted_peers"] = {
+            full_node_api.full_node.server.node_id.hex(): full_node_api.full_node.server.node_id.hex()
+        }
+    else:
+        wallet_node_0.config["trusted_peers"] = {}
+        wallet_node_1.config["trusted_peers"] = {}
+        wallet_node_2.config["trusted_peers"] = {}
+
+    await server_0.start_client(PeerInfo(self_hostname, uint16(full_node_server._port)), None)
+    await server_1.start_client(PeerInfo(self_hostname, uint16(full_node_server._port)), None)
+    await server_2.start_client(PeerInfo(self_hostname, uint16(full_node_server._port)), None)
+
+    for i in range(0, num_blocks):
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(ph))
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(ph_1))
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(ph_2))
+    await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    funds = sum(
+        [calculate_pool_reward(uint32(i)) + calculate_base_farmer_reward(uint32(i)) for i in range(1, num_blocks + 1)]
+    )
+
+    await time_out_assert(20, wallet.get_confirmed_balance, funds)
+    await time_out_assert(20, full_node_api.wallet_is_synced, True, wallet_node_0)
+
+    cat_amt = 300000
+    dao_rules = DAORules(
+        proposal_timelock=uint64(10),
+        soft_close_length=uint64(5),
+        attendance_required=uint64(1000),  # 10%
+        pass_percentage=uint64(5100),  # 51%
+        self_destruct_length=uint64(20),
+        oracle_spend_delay=uint64(10),
+        proposal_minimum_amount=uint64(101),
+    )
+
+    async with wallet_node_0.wallet_state_manager.lock:
+        dao_wallet_0 = await DAOWallet.create_new_dao_and_wallet(
+            wallet_node_0.wallet_state_manager,
+            wallet,
+            uint64(cat_amt),
+            dao_rules,
+        )
+        assert dao_wallet_0 is not None
+
+    # Get the full node sim to process the wallet creation spend
+    tx_queue: List[TransactionRecord] = await wallet_node_0.wallet_state_manager.tx_store.get_not_sent()
+    tx_record = tx_queue[0]
+    await full_node_api.process_transaction_records(records=[tx_record])
+    await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    # Farm enough blocks to pass the oracle_spend_delay and then complete the treasury eve spend
+    for i in range(1, 11):
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    # async with wallet_node_0.wallet_state_manager.lock:
+    #     await dao_wallet_0.generate_treasury_eve_spend()
+    # tx_queue: List[TransactionRecord] = await wallet_node_0.wallet_state_manager.tx_store.get_not_sent()
+    # tx_record = tx_queue[0]
+    # await full_node_api.process_transaction_records(records=[tx_record])
+    # await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    # get the cat wallets
+    cat_wallet_0 = dao_wallet_0.wallet_state_manager.wallets[dao_wallet_0.dao_info.cat_wallet_id]
+    await time_out_assert(10, cat_wallet_0.get_confirmed_balance, cat_amt)
+
+    # get the dao_cat wallet
+    dao_cat_wallet_0 = dao_wallet_0.wallet_state_manager.wallets[dao_wallet_0.dao_info.dao_cat_wallet_id]
+
+    treasury_id = dao_wallet_0.dao_info.treasury_id
+
+    # Create the other user's wallet from the treasury id
+    dao_wallet_1 = await DAOWallet.create_new_dao_wallet_for_existing_dao(
+        wallet_node_1.wallet_state_manager,
+        wallet_1,
+        treasury_id,
+    )
+    assert dao_wallet_1 is not None
+    assert dao_wallet_1.dao_info.treasury_id == treasury_id
+
+    # Create funding spends for xch
+    xch_funds = uint64(500000)
+    funding_tx = await dao_wallet_0.create_add_money_to_treasury_spend(xch_funds)
+    funding_sb = funding_tx.spend_bundle
+    await time_out_assert_not_none(5, full_node_api.full_node.mempool_manager.get_spendbundle, funding_sb.name())
+    await full_node_api.process_transaction_records(records=[funding_tx])
+
+    if not trusted:
+        await asyncio.sleep(1)
+    for i in range(1, num_blocks):
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    # Check that the funding spend is recognized by both dao wallets
+    await time_out_assert(10, dao_wallet_0.get_balance_by_asset_type, xch_funds)
+
+    # Send some dao_cats to wallet_1
+    # Get the cat wallets for wallet_1
+    cat_wallet_1 = dao_wallet_1.wallet_state_manager.wallets[dao_wallet_1.dao_info.cat_wallet_id]
+    dao_cat_wallet_1 = dao_wallet_1.wallet_state_manager.wallets[dao_wallet_1.dao_info.dao_cat_wallet_id]
+    assert cat_wallet_1
+    assert dao_cat_wallet_1
+
+    cat_tx = await cat_wallet_0.generate_signed_transactions([100000], [ph_1])
+    cat_sb = cat_tx[0].spend_bundle
+    await wallet.wallet_state_manager.add_pending_transaction(cat_tx[0])
+    await time_out_assert_not_none(5, full_node_api.full_node.mempool_manager.get_spendbundle, cat_sb.name())
+    await full_node_api.process_transaction_records(records=cat_tx)
+
+    if not trusted:
+        await asyncio.sleep(1)
+    for i in range(1, num_blocks):
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    # Create dao cats for voting
+    dao_cat_0_bal = await dao_cat_wallet_0.get_votable_balance()
+    txs, new_dao_cats = await dao_cat_wallet_0.create_new_dao_cats(dao_cat_0_bal, True)
+    dao_cat_sb = txs[0].spend_bundle
+    await time_out_assert_not_none(5, full_node_api.full_node.mempool_manager.get_spendbundle, dao_cat_sb.name())
+    await full_node_api.process_transaction_records(records=txs)
+
+    if not trusted:
+        await asyncio.sleep(1)
+    for i in range(1, num_blocks):
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    # Create a proposal for xch spend
+    recipient_puzzle_hash = await wallet_2.get_new_puzzlehash()
+    proposal_amount = 10000
+    xch_proposal_inner = dao_wallet_0.generate_simple_proposal_innerpuz(
+        [recipient_puzzle_hash],
+        [proposal_amount],
+        [None],
+    )
+    proposal_sb = await dao_wallet_0.generate_new_proposal(xch_proposal_inner, dao_cat_0_bal, uint64(1000))
+    await time_out_assert_not_none(5, full_node_api.full_node.mempool_manager.get_spendbundle, proposal_sb.name())
+    await full_node_api.process_spend_bundles(bundles=[proposal_sb])
+
+    # Give the wallet nodes a second
+    await asyncio.sleep(1)
+    for i in range(1, num_blocks):
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    # Check the proposal is saved
+    assert len(dao_wallet_0.dao_info.proposals_list) == 1
+    assert dao_wallet_0.dao_info.proposals_list[0].amount_voted == dao_cat_0_bal
+    assert dao_wallet_0.dao_info.proposals_list[0].timer_coin is not None
+
+    # Check that wallet_1 also finds and saved the proposal
+    assert len(dao_wallet_1.dao_info.proposals_list) == 1
+    prop = dao_wallet_1.dao_info.proposals_list[0]
+
+    # Create votable dao cats and add a new vote
+    dao_cat_1_bal = await dao_cat_wallet_1.get_votable_balance()
+    txs, new_dao_cats = await dao_cat_wallet_1.create_new_dao_cats(dao_cat_1_bal, True)
+    dao_cat_sb = txs[0].spend_bundle
+    await time_out_assert_not_none(5, full_node_api.full_node.mempool_manager.get_spendbundle, dao_cat_sb.name())
+    await full_node_api.process_transaction_records(records=txs)
+
+    if not trusted:
+        await asyncio.sleep(1)
+    for i in range(1, num_blocks):
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    vote_sb = await dao_wallet_1.generate_proposal_vote_spend(prop.proposal_id, dao_cat_1_bal, True, push=True)
+    await time_out_assert_not_none(5, full_node_api.full_node.mempool_manager.get_spendbundle, vote_sb.name())
+    await full_node_api.process_spend_bundles(bundles=[vote_sb])
+
+    # Give the wallet nodes a second
+    await asyncio.sleep(1)
+    for i in range(1, num_blocks):
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    total_votes = dao_cat_0_bal + dao_cat_1_bal
+
+    assert dao_wallet_0.dao_info.proposals_list[0].amount_voted == total_votes
+    assert dao_wallet_0.dao_info.proposals_list[0].yes_votes == total_votes
+    assert dao_wallet_1.dao_info.proposals_list[0].amount_voted == total_votes
+    assert dao_wallet_1.dao_info.proposals_list[0].yes_votes == total_votes
+
+    # Add a third wallet and check they can find proposal with accurate vote counts
+    dao_wallet_2 = await DAOWallet.create_new_dao_wallet_for_existing_dao(
+        wallet_node_2.wallet_state_manager,
+        wallet_2,
+        treasury_id,
+    )
+    assert dao_wallet_2 is not None
+    assert dao_wallet_2.dao_info.treasury_id == treasury_id
+
+    await asyncio.sleep(1)
+    await time_out_assert(20, len, 1, dao_wallet_2.dao_info.proposals_list)
+    await time_out_assert(20, int, total_votes, dao_wallet_2.dao_info.proposals_list[0].amount_voted)
+
+    # Get the proposal from singleton store and check the singleton block height updates correctly
+    proposal_state = await dao_wallet_0.get_proposal_state(prop.proposal_id)
+    assert proposal_state["passed"]
+    assert not proposal_state["closable"]
+    assert proposal_state["blocks_needed"] == 2
+
+    for i in range(1, 5):
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    proposal_state = await dao_wallet_0.get_proposal_state(prop.proposal_id)
+    assert proposal_state["passed"]
+    assert proposal_state["closable"]
+
+    # Create an update proposal
+    new_dao_rules = DAORules(
+        proposal_timelock=uint64(5),
+        soft_close_length=uint64(4),
+        attendance_required=uint64(200000),  # 100%
+        pass_percentage=uint64(10000),  # 100%
+        self_destruct_length=uint64(8),
+        oracle_spend_delay=uint64(2),
+        proposal_minimum_amount=uint64(1),
+    )
+    update_inner = await dao_wallet_0.generate_update_proposal_innerpuz(new_dao_rules)
+    dao_cat_0_bal = await dao_cat_wallet_0.get_votable_balance()
+    proposal_sb = await dao_wallet_0.generate_new_proposal(update_inner, dao_cat_0_bal, uint64(1000))
+    await time_out_assert_not_none(5, full_node_api.full_node.mempool_manager.get_spendbundle, proposal_sb.name())
+    await full_node_api.process_spend_bundles(bundles=[proposal_sb])
+
+    # Give the wallet nodes a second
+    await asyncio.sleep(1)
+    for i in range(1, num_blocks):
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    # Check the proposal is saved
+    assert len(dao_wallet_0.dao_info.proposals_list) == 2
+    assert len(dao_wallet_1.dao_info.proposals_list) == 2
+    assert len(dao_wallet_2.dao_info.proposals_list) == 2
+
+    # Create a third proposal which will fail
+    dao_cat_1_bal = await dao_cat_wallet_1.get_votable_balance()
+    recipient_puzzle_hash = await wallet_2.get_new_puzzlehash()
+    proposal_amount = 1000
+    xch_proposal_inner = dao_wallet_1.generate_simple_proposal_innerpuz(
+        [recipient_puzzle_hash], [proposal_amount], [None]
+    )
+    proposal_sb = await dao_wallet_1.generate_new_proposal(xch_proposal_inner, dao_cat_1_bal, uint64(1000))
+    await time_out_assert_not_none(5, full_node_api.full_node.mempool_manager.get_spendbundle, proposal_sb.name())
+    await full_node_api.process_spend_bundles(bundles=[proposal_sb])
+
+    # Give the wallet nodes a second
+    await asyncio.sleep(1)
+    for i in range(1, num_blocks):
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    # Check the proposal is saved
+    assert len(dao_wallet_0.dao_info.proposals_list) == 3
+    assert dao_wallet_0.dao_info.proposals_list[2].amount_voted == dao_cat_1_bal
+    assert dao_wallet_0.dao_info.proposals_list[2].timer_coin is not None
+
+    # The  third proposal should be in a "passed" state now, and this will change to "failed"
+    # once the treasury update proposal has closed.
+    async def check_prop_state(wallet, proposal_id, state):
+        prop_state = wallet.get_proposal_state(proposal_id)
+        return prop_state[state]
+
+    prop = dao_wallet_0.dao_info.proposals_list[2]
+    time_out_assert(20, check_prop_state, True, [dao_wallet_0, prop.proposal_id, "passed"])
+
+    wallet_2_start_bal = await wallet_2.get_confirmed_balance()
+
+    # check the proposal info
+    assert not dao_wallet_0.dao_info.proposals_list[0].closed
+    assert dao_wallet_0.dao_info.proposals_list[0].passed
+
+    # Close the first proposal
+    prop = dao_wallet_0.dao_info.proposals_list[0]
+    close_sb = await dao_wallet_0.create_proposal_close_spend(prop.proposal_id, fee=uint64(100))
+
+    await time_out_assert_not_none(5, full_node_api.full_node.mempool_manager.get_spendbundle, close_sb.name())
+    await full_node_api.process_spend_bundles(bundles=[close_sb])
+    await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    # Give the wallet nodes a second and farm enough blocks so we can close the next proposal
+    await asyncio.sleep(1)
+    for i in range(1, num_blocks):
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    time_out_assert(20, wallet_2.get_confirmed_balance, wallet_2_start_bal + proposal_amount)
+    time_out_assert(20, dao_wallet_0.get_balance_by_asset_type, xch_funds - proposal_amount)
+
+    time_out_assert(20, get_proposal_state, (True, True), [dao_wallet_0, 0])
+    time_out_assert(20, get_proposal_state, (True, True), [dao_wallet_1, 0])
+    time_out_assert(20, get_proposal_state, (True, True), [dao_wallet_2, 0])
+
+    # close the update proposal
+    prop = dao_wallet_0.dao_info.proposals_list[1]
+    while True:
+        prop_state = await dao_wallet_0.get_proposal_state(prop.proposal_id)
+        if prop_state["closable"]:
+            break
+        else:
+            for i in range(1, prop_state["blocks_needed"]):
+                await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    time_out_assert(20, check_prop_state, True, [dao_wallet_0, prop.proposal_id, "passed"])
+    time_out_assert(20, check_prop_state, True, [dao_wallet_0, prop.proposal_id, "closable"])
+
+    close_sb = await dao_wallet_0.create_proposal_close_spend(prop.proposal_id)
+    await time_out_assert_not_none(5, full_node_api.full_node.mempool_manager.get_spendbundle, close_sb.name())
+    await full_node_api.process_spend_bundles(bundles=[close_sb])
+    await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    # Give the wallet nodes a second and farm enough blocks so we can close the next proposal
+    await asyncio.sleep(1)
+    for i in range(1, num_blocks):
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    async def get_dao_rules(wallet):
+        return wallet.dao_rules
+
+    time_out_assert(20, get_dao_rules, new_dao_rules, dao_wallet_0)
+    time_out_assert(20, get_dao_rules, new_dao_rules, dao_wallet_1)
+    time_out_assert(20, get_dao_rules, new_dao_rules, dao_wallet_2)
+
+    time_out_assert(20, get_proposal_state, (True, True), [dao_wallet_0, 1])
+    time_out_assert(20, get_proposal_state, (True, True), [dao_wallet_1, 1])
+    time_out_assert(20, get_proposal_state, (True, True), [dao_wallet_2, 1])
+
+    # Have wallet_0 vote against the proposal
+    prop = dao_wallet_0.dao_info.proposals_list[2]
+    vote_sb = await dao_wallet_0.generate_proposal_vote_spend(prop.proposal_id, dao_cat_0_bal, False, push=True)
+    await time_out_assert_not_none(5, full_node_api.full_node.mempool_manager.get_spendbundle, vote_sb.name())
+    await full_node_api.process_spend_bundles(bundles=[vote_sb])
+    await asyncio.sleep(1)
+    # farm enough blocks to close the proposal
+    for i in range(1, 12):
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    time_out_assert(20, check_prop_state, True, [dao_wallet_0, prop.proposal_id, "closable"])
+    time_out_assert(20, check_prop_state, False, [dao_wallet_0, prop.proposal_id, "passed"])
+    await asyncio.sleep(1)
+    try:
+        close_sb = await dao_wallet_0.create_proposal_close_spend(prop.proposal_id, fee=uint64(100), push=True)
+    except Exception as e:
+        print(e)
+    # await time_out_assert_not_none(10, full_node_api.full_node.mempool_manager.get_spendbundle, close_sb.name())
+    # await full_node_api.process_spend_bundles(bundles=[close_sb])
+    await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    # Give the wallet nodes a second and farm enough blocks so we can close the next proposal
+    await asyncio.sleep(2)
+    for i in range(1, num_blocks):
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    time_out_assert(20, get_proposal_state, (False, True), [dao_wallet_0, 2])
+    time_out_assert(20, get_proposal_state, (False, True), [dao_wallet_1, 2])
+    time_out_assert(20, get_proposal_state, (False, True), [dao_wallet_2, 2])
+
+    # Finally create a broken proposal and force close
+    dao_cat_0_bal = await dao_cat_wallet_0.get_votable_balance()
+    recipient_puzzle_hash = await wallet_2.get_new_puzzlehash()
+    proposal_amount = 5000
+    xch_proposal_inner = Program.to(["x"])
+    proposal_sb = await dao_wallet_0.generate_new_proposal(xch_proposal_inner, dao_cat_0_bal, uint64(1000))
+    await time_out_assert_not_none(20, full_node_api.full_node.mempool_manager.get_spendbundle, proposal_sb.name())
+    await full_node_api.process_spend_bundles(bundles=[proposal_sb])
+
+    # Give the wallet nodes a second
+    await asyncio.sleep(1)
+    for i in range(1, 12):
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    # Check the proposal is passed and closable
+    prop = dao_wallet_0.dao_info.proposals_list[3]
+    time_out_assert(20, get_proposal_state, (True, True), [dao_wallet_0, 2])
+
+    with pytest.raises(Exception) as e_info:
+        close_sb = await dao_wallet_0.create_proposal_close_spend(prop.proposal_id, fee=uint64(100), push=True)
+    assert e_info.value.args[0] == "Unrecognised proposal type"
+
+    close_sb = await dao_wallet_0.create_proposal_close_spend(
+        prop.proposal_id, fee=uint64(100), push=True, self_destruct=True
+    )
+    await time_out_assert_not_none(20, full_node_api.full_node.mempool_manager.get_spendbundle, close_sb.name())
+    await full_node_api.process_spend_bundles(bundles=[close_sb])
+    await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    # Give the wallet nodes a second and farm enough blocks so we can close the next proposal
+    await asyncio.sleep(1)
+    for i in range(1, num_blocks):
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    time_out_assert(20, get_proposal_state, (True, True), [dao_wallet_0, 2])
+    time_out_assert(20, get_proposal_state, (True, True), [dao_wallet_1, 2])
+    time_out_assert(20, get_proposal_state, (True, True), [dao_wallet_2, 2])
+
+
+@pytest.mark.parametrize(
+    "trusted",
+    [True, False],
+)
+@pytest.mark.asyncio
+async def test_dao_proposal_partial_vote(
+    self_hostname: str, three_wallet_nodes: SimulatorsAndWallets, trusted: bool
+) -> None:
+    num_blocks = 3
+    full_nodes, wallets, _ = three_wallet_nodes
+    full_node_api = full_nodes[0]
+    full_node_server = full_node_api.server
+    wallet_node_0, server_0 = wallets[0]
+    wallet_node_1, server_1 = wallets[1]
+    wallet_node_2, server_2 = wallets[2]
+    wallet = wallet_node_0.wallet_state_manager.main_wallet
+    wallet_1 = wallet_node_1.wallet_state_manager.main_wallet
+    wallet_2 = wallet_node_2.wallet_state_manager.main_wallet
+    ph = await wallet.get_new_puzzlehash()
+    ph_1 = await wallet_1.get_new_puzzlehash()
+    ph_2 = await wallet_2.get_new_puzzlehash()
+
+    if trusted:
+        wallet_node_0.config["trusted_peers"] = {
+            full_node_api.full_node.server.node_id.hex(): full_node_api.full_node.server.node_id.hex()
+        }
+        wallet_node_1.config["trusted_peers"] = {
+            full_node_api.full_node.server.node_id.hex(): full_node_api.full_node.server.node_id.hex()
+        }
+        wallet_node_2.config["trusted_peers"] = {
+            full_node_api.full_node.server.node_id.hex(): full_node_api.full_node.server.node_id.hex()
+        }
+    else:
+        wallet_node_0.config["trusted_peers"] = {}
+        wallet_node_1.config["trusted_peers"] = {}
+        wallet_node_2.config["trusted_peers"] = {}
+
+    await server_0.start_client(PeerInfo(self_hostname, uint16(full_node_server._port)), None)
+    await server_1.start_client(PeerInfo(self_hostname, uint16(full_node_server._port)), None)
+    await server_2.start_client(PeerInfo(self_hostname, uint16(full_node_server._port)), None)
+
+    for i in range(0, num_blocks):
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(ph))
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(ph_1))
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(ph_2))
+    await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    funds = sum(
+        [calculate_pool_reward(uint32(i)) + calculate_base_farmer_reward(uint32(i)) for i in range(1, num_blocks + 1)]
+    )
+
+    await time_out_assert(20, wallet.get_confirmed_balance, funds)
+    await time_out_assert(20, full_node_api.wallet_is_synced, True, wallet_node_0)
+
+    cat_amt = 300000
+    dao_rules = DAORules(
+        proposal_timelock=uint64(10),
+        soft_close_length=uint64(5),
+        attendance_required=uint64(1000),  # 10%
+        pass_percentage=uint64(5100),  # 51%
+        self_destruct_length=uint64(20),
+        oracle_spend_delay=uint64(10),
+        proposal_minimum_amount=uint64(1),
+    )
+
+    async with wallet_node_0.wallet_state_manager.lock:
+        dao_wallet_0 = await DAOWallet.create_new_dao_and_wallet(
+            wallet_node_0.wallet_state_manager,
+            wallet,
+            uint64(cat_amt),
+            dao_rules,
+        )
+        assert dao_wallet_0 is not None
+
+    # Get the full node sim to process the wallet creation spend
+    tx_queue: List[TransactionRecord] = await wallet_node_0.wallet_state_manager.tx_store.get_not_sent()
+    tx_record = tx_queue[0]
+    await full_node_api.process_transaction_records(records=[tx_record])
+    await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    # Farm enough blocks to pass the oracle_spend_delay and then complete the treasury eve spend
+    for i in range(1, 11):
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    # async with wallet_node_0.wallet_state_manager.lock:
+    #     await dao_wallet_0.generate_treasury_eve_spend()
+    # tx_queue: List[TransactionRecord] = await wallet_node_0.wallet_state_manager.tx_store.get_not_sent()
+    # tx_record = tx_queue[0]
+    # await full_node_api.process_transaction_records(records=[tx_record])
+    # await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    # get the cat wallets
+    cat_wallet_0 = dao_wallet_0.wallet_state_manager.wallets[dao_wallet_0.dao_info.cat_wallet_id]
+    await time_out_assert(10, cat_wallet_0.get_confirmed_balance, cat_amt)
+
+    # get the dao_cat wallet
+    dao_cat_wallet_0 = dao_wallet_0.wallet_state_manager.wallets[dao_wallet_0.dao_info.dao_cat_wallet_id]
+
+    treasury_id = dao_wallet_0.dao_info.treasury_id
+
+    # Create the other user's wallet from the treasury id
+    dao_wallet_1 = await DAOWallet.create_new_dao_wallet_for_existing_dao(
+        wallet_node_1.wallet_state_manager,
+        wallet_1,
+        treasury_id,
+    )
+    assert dao_wallet_1 is not None
+    assert dao_wallet_1.dao_info.treasury_id == treasury_id
+
+    # Create funding spends for xch
+    xch_funds = uint64(500000)
+    funding_tx = await dao_wallet_0.create_add_money_to_treasury_spend(xch_funds)
+    funding_sb = funding_tx.spend_bundle
+    await time_out_assert_not_none(5, full_node_api.full_node.mempool_manager.get_spendbundle, funding_sb.name())
+    await full_node_api.process_transaction_records(records=[funding_tx])
+
+    if not trusted:
+        await asyncio.sleep(1)
+    for i in range(1, num_blocks):
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    # Check that the funding spend is recognized by both dao wallets
+    await time_out_assert(10, dao_wallet_0.get_balance_by_asset_type, xch_funds)
+
+    # Send some dao_cats to wallet_1
+    # Get the cat wallets for wallet_1
+    cat_wallet_1 = dao_wallet_1.wallet_state_manager.wallets[dao_wallet_1.dao_info.cat_wallet_id]
+    dao_cat_wallet_1 = dao_wallet_1.wallet_state_manager.wallets[dao_wallet_1.dao_info.dao_cat_wallet_id]
+    assert cat_wallet_1
+    assert dao_cat_wallet_1
+
+    cat_tx = await cat_wallet_0.generate_signed_transactions([100000], [ph_1])
+    cat_sb = cat_tx[0].spend_bundle
+    await wallet.wallet_state_manager.add_pending_transaction(cat_tx[0])
+    await time_out_assert_not_none(5, full_node_api.full_node.mempool_manager.get_spendbundle, cat_sb.name())
+    await full_node_api.process_transaction_records(records=cat_tx)
+
+    if not trusted:
+        await asyncio.sleep(1)
+    for i in range(1, num_blocks):
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    # Create dao cats for voting
+    dao_cat_0_bal = await dao_cat_wallet_0.get_votable_balance()
+    txs, new_dao_cats = await dao_cat_wallet_0.create_new_dao_cats(dao_cat_0_bal, True)
+    dao_cat_sb = txs[0].spend_bundle
+    await time_out_assert_not_none(5, full_node_api.full_node.mempool_manager.get_spendbundle, dao_cat_sb.name())
+    await full_node_api.process_transaction_records(records=txs)
+
+    if not trusted:
+        await asyncio.sleep(1)
+    for i in range(1, num_blocks):
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    # Create a mint proposal
+    recipient_puzzle_hash = await cat_wallet_1.get_new_inner_hash()
+    new_mint_amount = 500
+    mint_proposal_inner = await dao_wallet_0.generate_mint_proposal_innerpuz(
+        new_mint_amount,
+        recipient_puzzle_hash,
+    )
+    # (
+    #     [recipient_puzzle_hash],
+    #     [proposal_amount],
+    #     [None],
+    # )
+    proposal_sb = await dao_wallet_0.generate_new_proposal(mint_proposal_inner, dao_cat_0_bal, fee=uint64(1000))
+    await time_out_assert_not_none(5, full_node_api.full_node.mempool_manager.get_spendbundle, proposal_sb.name())
+    await full_node_api.process_spend_bundles(bundles=[proposal_sb])
+
+    # Give the wallet nodes a second
+    await asyncio.sleep(1)
+    for i in range(1, num_blocks):
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    # Check the proposal is saved
+    assert len(dao_wallet_0.dao_info.proposals_list) == 1
+    assert dao_wallet_0.dao_info.proposals_list[0].amount_voted == dao_cat_0_bal
+    assert dao_wallet_0.dao_info.proposals_list[0].timer_coin is not None
+
+    # Check that wallet_1 also finds and saved the proposal
+    assert len(dao_wallet_1.dao_info.proposals_list) == 1
+    prop = dao_wallet_1.dao_info.proposals_list[0]
+
+    # Create votable dao cats and add a new vote
+    dao_cat_1_bal = await dao_cat_wallet_1.get_votable_balance()
+    txs, new_dao_cats = await dao_cat_wallet_1.create_new_dao_cats(dao_cat_1_bal, True)
+    dao_cat_sb = txs[0].spend_bundle
+    await time_out_assert_not_none(5, full_node_api.full_node.mempool_manager.get_spendbundle, dao_cat_sb.name())
+    await full_node_api.process_transaction_records(records=txs)
+
+    if not trusted:
+        await asyncio.sleep(1)
+    for i in range(1, num_blocks):
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    vote_sb = await dao_wallet_1.generate_proposal_vote_spend(prop.proposal_id, dao_cat_1_bal // 2, True, push=True)
+    await time_out_assert_not_none(5, full_node_api.full_node.mempool_manager.get_spendbundle, vote_sb.name())
+    await full_node_api.process_spend_bundles(bundles=[vote_sb])
+
+    # Give the wallet nodes a second
+    await asyncio.sleep(1)
+    for i in range(1, dao_rules.proposal_timelock + 1):
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    total_votes = dao_cat_0_bal + dao_cat_1_bal // 2
+
+    assert dao_wallet_0.dao_info.proposals_list[0].amount_voted == total_votes
+    assert dao_wallet_0.dao_info.proposals_list[0].yes_votes == total_votes
+    assert dao_wallet_1.dao_info.proposals_list[0].amount_voted == total_votes
+    assert dao_wallet_1.dao_info.proposals_list[0].yes_votes == total_votes
+
+    try:
+        close_sb = await dao_wallet_0.create_proposal_close_spend(prop.proposal_id, fee=uint64(100), push=True)
+    except Exception as e:
+        print(e)
+    # await time_out_assert_not_none(10, full_node_api.full_node.mempool_manager.get_spendbundle, close_sb.name())
+    await full_node_api.process_spend_bundles(bundles=[close_sb])
+    balance = await cat_wallet_1.get_spendable_balance()
+    # breakpoint()
+    assert close_sb is not None
+    await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    # Give the wallet nodes a second and farm enough blocks so we can close the next proposal
+    await asyncio.sleep(2)
+    for i in range(1, num_blocks):
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    await time_out_assert(20, get_proposal_state, (True, True), dao_wallet_0, 0)
+    await time_out_assert(20, get_proposal_state, (True, True), dao_wallet_1, 0)
+
+    await time_out_assert(20, cat_wallet_1.get_spendable_balance, balance + new_mint_amount)
+    # Can we spend the newly minted CATs?
+    old_balance = await cat_wallet_0.get_spendable_balance()
+    ph_0 = await cat_wallet_0.get_new_inner_hash()
+    cat_tx = await cat_wallet_1.generate_signed_transactions([balance + new_mint_amount], [ph_0])
+    cat_sb = cat_tx[0].spend_bundle
+    await wallet_1.wallet_state_manager.add_pending_transaction(cat_tx[0])
+    await time_out_assert_not_none(5, full_node_api.full_node.mempool_manager.get_spendbundle, cat_sb.name())
+    await full_node_api.process_transaction_records(records=cat_tx)
+
+    if not trusted:
+        await asyncio.sleep(1)
+    for i in range(1, num_blocks):
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    await time_out_assert(20, cat_wallet_1.get_spendable_balance, 0)
+    await time_out_assert(20, cat_wallet_0.get_spendable_balance, old_balance + balance + new_mint_amount)
+
+
+@pytest.mark.parametrize(
+    "trusted",
+    [True, False],
+)
+@pytest.mark.asyncio
+async def test_dao_rpc_api(self_hostname: str, two_wallet_nodes: Any, trusted: Any) -> None:
+    num_blocks = 3
+    full_nodes, wallets, _ = two_wallet_nodes
+    full_node_api = full_nodes[0]
+    full_node_server = full_node_api.server
+    wallet_node_0, server_0 = wallets[0]
+    wallet_node_1, server_1 = wallets[1]
+    wallet_0 = wallet_node_0.wallet_state_manager.main_wallet
+    wallet_1 = wallet_node_1.wallet_state_manager.main_wallet
+
+    ph_0 = await wallet_0.get_new_puzzlehash()
+    ph_1 = await wallet_1.get_new_puzzlehash()
+
+    if trusted:
+        wallet_node_0.config["trusted_peers"] = {
+            full_node_api.full_node.server.node_id.hex(): full_node_api.full_node.server.node_id.hex()
+        }
+        wallet_node_1.config["trusted_peers"] = {
+            full_node_api.full_node.server.node_id.hex(): full_node_api.full_node.server.node_id.hex()
+        }
+    else:
+        wallet_node_0.config["trusted_peers"] = {}
+        wallet_node_1.config["trusted_peers"] = {}
+
+    await server_0.start_client(PeerInfo(self_hostname, uint16(full_node_server._port)), None)
+    await server_1.start_client(PeerInfo(self_hostname, uint16(full_node_server._port)), None)
+
+    for i in range(1, num_blocks):
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(ph_0))
+    await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    funds = sum(
+        [calculate_pool_reward(uint32(i)) + calculate_base_farmer_reward(uint32(i)) for i in range(1, num_blocks)]
+    )
+
+    await time_out_assert(30, wallet_0.get_unconfirmed_balance, funds)
+    await time_out_assert(30, wallet_0.get_confirmed_balance, funds)
+    await time_out_assert(30, wallet_node_0.wallet_state_manager.synced, True)
+    api_0 = WalletRpcApi(wallet_node_0)
+    api_1 = WalletRpcApi(wallet_node_1)
+    await full_node_api.wait_for_wallet_synced(wallet_node=wallet_node_0, timeout=30)
+
+    cat_amt = 300000
+    fee = 10000
+    dao_rules = DAORules(
+        proposal_timelock=uint64(10),
+        soft_close_length=uint64(5),
+        attendance_required=uint64(1000),  # 10%
+        pass_percentage=uint64(5100),  # 51%
+        self_destruct_length=uint64(20),
+        oracle_spend_delay=uint64(10),
+        proposal_minimum_amount=uint64(1),
+    )
+
+    dao_wallet_0 = await api_0.create_new_wallet(
+        dict(
+            wallet_type="dao_wallet",
+            name="DAO WALLET 1",
+            mode="new",
+            dao_rules=dao_rules,
+            amount_of_cats=cat_amt,
+            filter_amount=1,
+            fee=fee,
+        )
+    )
+    assert isinstance(dao_wallet_0, dict)
+    assert dao_wallet_0.get("success")
+    dao_wallet_0_id = dao_wallet_0["wallet_id"]
+    dao_cat_wallet_0_id = dao_wallet_0["cat_wallet_id"]
+    treasury_id = bytes32(dao_wallet_0["treasury_id"])
+    spend_bundle_list = await wallet_node_0.wallet_state_manager.tx_store.get_unconfirmed_for_wallet(dao_wallet_0_id)
+    spend_bundle = spend_bundle_list[0].spend_bundle
+    await time_out_assert_not_none(30, full_node_api.full_node.mempool_manager.get_spendbundle, spend_bundle.name())
+
+    for _ in range(1, num_blocks):
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    await time_out_assert(30, wallet_0.get_pending_change_balance, 0)
+    expected_xch = funds - 1 - cat_amt - fee
+    await time_out_assert(30, wallet_0.get_confirmed_balance, expected_xch)
+
+    dao_wallet_1 = await api_1.create_new_wallet(
+        dict(
+            wallet_type="dao_wallet",
+            name="DAO WALLET 2",
+            mode="existing",
+            treasury_id=treasury_id.hex(),
+            filter_amount=1,
+        )
+    )
+    assert isinstance(dao_wallet_1, dict)
+    assert dao_wallet_1.get("success")
+    dao_wallet_1_id = dao_wallet_1["wallet_id"]
+    # Create a cat wallet and add funds to treasury
+    new_cat_amt = 1000000000000
+    cat_wallet_0 = await api_0.create_new_wallet(
+        dict(
+            wallet_type="cat_wallet",
+            name="CAT WALLET 1",
+            mode="new",
+            amount=new_cat_amt,
+        )
+    )
+    tx_queue: List[TransactionRecord] = await wallet_node_0.wallet_state_manager.tx_store.get_not_sent()
+    await full_node_api.process_transaction_records(records=[tx for tx in tx_queue])
+    for _ in range(1, num_blocks):
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    cat_wallet_0_id = cat_wallet_0["wallet_id"]
+    cat_id = bytes32.from_hexstr(cat_wallet_0["asset_id"])
+
+    await rpc_state(
+        20,
+        api_0.get_wallet_balance,
+        [{"wallet_id": cat_wallet_0_id}],
+        lambda x: x["wallet_balance"]["confirmed_wallet_balance"],
+        new_cat_amt,
+    )
+
+    cat_funding_amt = 500000
+    await api_0.dao_add_funds_to_treasury(
+        dict(
+            wallet_id=dao_wallet_0_id,
+            amount=cat_funding_amt,
+            funding_wallet_id=cat_wallet_0_id,
+        )
+    )
+
+    xch_funding_amt = 200000
+    await api_0.dao_add_funds_to_treasury(
+        dict(
+            wallet_id=dao_wallet_0_id,
+            amount=xch_funding_amt,
+            funding_wallet_id=1,
+        )
+    )
+    tx_queue: List[TransactionRecord] = await wallet_node_0.wallet_state_manager.tx_store.get_not_sent()
+    await full_node_api.process_transaction_records(records=[tx for tx in tx_queue])
+    for _ in range(1, num_blocks):
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    expected_xch -= xch_funding_amt + new_cat_amt
+    await time_out_assert(30, wallet_0.get_confirmed_balance, expected_xch)
+
+    await rpc_state(
+        20,
+        api_0.get_wallet_balance,
+        [{"wallet_id": cat_wallet_0_id}],
+        lambda x: x["wallet_balance"]["confirmed_wallet_balance"],
+        new_cat_amt - cat_funding_amt,
+    )
+
+    balances = await api_1.dao_get_treasury_balance({"wallet_id": dao_wallet_1_id})
+    assert balances["balances"][None] == xch_funding_amt
+    assert balances["balances"][cat_id] == cat_funding_amt
+
+    # Send some cats to wallet_1
+    await api_0.cat_spend(
+        {
+            "wallet_id": dao_cat_wallet_0_id,
+            "amount": cat_amt // 2,
+            "inner_address": encode_puzzle_hash(ph_1, "xch"),
+            "fee": fee,
+        }
+    )
+    tx_queue: List[TransactionRecord] = await wallet_node_0.wallet_state_manager.tx_store.get_not_sent()
+    await full_node_api.process_transaction_records(records=[tx for tx in tx_queue])
+    for _ in range(1, num_blocks):
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    await rpc_state(
+        20,
+        api_0.get_wallet_balance,
+        [{"wallet_id": dao_cat_wallet_0_id}],
+        lambda x: x["wallet_balance"]["confirmed_wallet_balance"],
+        cat_amt // 2,
+    )
+
+    # send cats to lockup
+    await api_0.dao_send_to_lockup({"wallet_id": dao_wallet_0_id, "amount": cat_amt // 2})
+    tx_queue: List[TransactionRecord] = await wallet_node_0.wallet_state_manager.tx_store.get_not_sent()
+    await full_node_api.process_transaction_records(records=[tx for tx in tx_queue])
+    await api_1.dao_send_to_lockup({"wallet_id": dao_wallet_1_id, "amount": cat_amt // 2})
+    tx_queue: List[TransactionRecord] = await wallet_node_1.wallet_state_manager.tx_store.get_not_sent()
+    await full_node_api.process_transaction_records(records=[tx for tx in tx_queue])
+    for _ in range(1, num_blocks):
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    # create the first proposal
+    additions = [
+        {"puzzle_hash": ph_1.hex(), "amount": 1000},
+        # {"puzzle_hash": ph_1.hex(), "amount": 2000, "asset_id": cat_id.hex()},
+    ]
+    create_proposal = await api_0.dao_create_proposal(
+        {
+            "wallet_id": dao_wallet_0_id,
+            "proposal_type": "spend",
+            "additions": additions,
+            # "amount": 100,
+            # "inner_address": encode_puzzle_hash(ph_1, "xch"),
+            "vote_amount": cat_amt // 2,
+            "fee": fee,
+        }
+    )
+    assert create_proposal["success"]
+    tx_queue: List[TransactionRecord] = await wallet_node_0.wallet_state_manager.tx_store.get_not_sent()
+    await full_node_api.process_transaction_records(records=[tx for tx in tx_queue])
+    for _ in range(1, num_blocks):
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    await rpc_state(20, api_0.dao_get_proposals, [{"wallet_id": dao_wallet_0_id}], lambda x: len(x["proposals"]), 1)
+
+    await rpc_state(20, api_1.dao_get_proposals, [{"wallet_id": dao_wallet_1_id}], lambda x: len(x["proposals"]), 1)
+
+    props_0 = await api_0.dao_get_proposals({"wallet_id": dao_wallet_0_id})
+    prop = props_0["proposals"][0]
+    assert prop.amount_voted == cat_amt // 2
+    assert prop.yes_votes == cat_amt // 2
+
+    state = await api_0.dao_get_proposal_state({"wallet_id": dao_wallet_0_id, "proposal_id": prop.proposal_id.hex()})
+    assert state["state"]["passed"]
+    assert not state["state"]["closable"]
+
+    # Add votes
+    await api_1.dao_vote_on_proposal(
+        {
+            "wallet_id": dao_wallet_1_id,
+            "vote_amount": cat_amt // 2,
+            "proposal_id": prop.proposal_id.hex(),
+            "is_yes_vote": True,
+        }
+    )
+    tx_queue: List[TransactionRecord] = await wallet_node_1.wallet_state_manager.tx_store.get_not_sent()
+    await full_node_api.process_transaction_records(records=[tx for tx in tx_queue])
+    for _ in range(1, num_blocks):
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    await rpc_state(
+        20, api_0.dao_get_proposals, [{"wallet_id": dao_wallet_0_id}], lambda x: x["proposals"][0].amount_voted, cat_amt
+    )
+
+    # farm blocks until we can close proposal
+    for _ in range(1, state["state"]["blocks_needed"]):
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    await rpc_state(
+        20,
+        api_0.dao_get_proposal_state,
+        [{"wallet_id": dao_wallet_0_id, "proposal_id": prop.proposal_id.hex()}],
+        lambda x: x["state"]["closable"],
+        True,
+    )
+
+    await api_0.dao_close_proposal({"wallet_id": dao_wallet_0_id, "proposal_id": prop.proposal_id.hex()})
+    tx_queue: List[TransactionRecord] = await wallet_node_0.wallet_state_manager.tx_store.get_not_sent()
+    await full_node_api.process_transaction_records(records=[tx for tx in tx_queue])
+    for _ in range(1, num_blocks):
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    await rpc_state(
+        20, api_0.dao_get_proposals, [{"wallet_id": dao_wallet_0_id}], lambda x: x["proposals"][0].closed, True
+    )
+
+
+@pytest.mark.parametrize(
+    "trusted",
+    [True, False],
+)
+@pytest.mark.asyncio
+async def test_dao_rpc_client(
+    two_wallet_nodes_services: SimulatorsAndWalletsServices, trusted: bool, self_hostname: str
+) -> None:
+    num_blocks = 3
+    [full_node_service], wallet_services, bt = two_wallet_nodes_services
+    full_node_api = full_node_service._api
+    full_node_server = full_node_api.full_node.server
+    wallet_node_0 = wallet_services[0]._node
+    server_0 = wallet_node_0.server
+    wallet_node_1 = wallet_services[1]._node
+    server_1 = wallet_node_1.server
+    wallet_0 = wallet_node_0.wallet_state_manager.main_wallet
+    wallet_1 = wallet_node_1.wallet_state_manager.main_wallet
+    ph_0 = await wallet_0.get_new_puzzlehash()
+    ph_1 = await wallet_1.get_new_puzzlehash()
+
+    if trusted:
+        wallet_node_0.config["trusted_peers"] = {full_node_server.node_id.hex(): full_node_server.node_id.hex()}
+        wallet_node_1.config["trusted_peers"] = {full_node_server.node_id.hex(): full_node_server.node_id.hex()}
+    else:
+        wallet_node_0.config["trusted_peers"] = {}
+        wallet_node_1.config["trusted_peers"] = {}
+
+    await server_0.start_client(PeerInfo(self_hostname, uint16(full_node_server._port)), None)
+    await server_1.start_client(PeerInfo(self_hostname, uint16(full_node_server._port)), None)
+
+    for i in range(1, num_blocks):
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(ph_0))
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(ph_1))
+    await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    initial_funds = sum(
+        [calculate_pool_reward(uint32(i)) + calculate_base_farmer_reward(uint32(i)) for i in range(1, num_blocks)]
+    )
+
+    await time_out_assert(15, wallet_0.get_confirmed_balance, initial_funds)
+    await time_out_assert(15, wallet_0.get_unconfirmed_balance, initial_funds)
+
+    assert wallet_services[0].rpc_server is not None
+    assert wallet_services[1].rpc_server is not None
+
+    client_0 = await WalletRpcClient.create(
+        self_hostname,
+        wallet_services[0].rpc_server.listen_port,
+        wallet_services[0].root_path,
+        wallet_services[0].config,
+    )
+    await validate_get_routes(client_0, wallet_services[0].rpc_server.rpc_api)
+    client_1 = await WalletRpcClient.create(
+        self_hostname,
+        wallet_services[1].rpc_server.listen_port,
+        wallet_services[1].root_path,
+        wallet_services[1].config,
+    )
+    await validate_get_routes(client_1, wallet_services[1].rpc_server.rpc_api)
+
+    try:
+        cat_amt = 150000
+        amount_of_cats = cat_amt * 2
+        dao_rules = DAORules(
+            proposal_timelock=uint64(8),
+            soft_close_length=uint64(4),
+            attendance_required=uint64(1000),  # 10%
+            pass_percentage=uint64(5100),  # 51%
+            self_destruct_length=uint64(20),
+            oracle_spend_delay=uint64(10),
+            proposal_minimum_amount=uint64(1),
+        )
+        filter_amount = 1
+        fee = 10000
+
+        # create new dao
+        dao_wallet_dict_0 = await client_0.create_new_dao_wallet(
+            mode="new",
+            dao_rules=dao_rules.to_json_dict(),
+            amount_of_cats=amount_of_cats,
+            filter_amount=filter_amount,
+            name="DAO WALLET 0",
+        )
+        assert dao_wallet_dict_0["success"]
+        dao_id_0 = dao_wallet_dict_0["wallet_id"]
+        treasury_id_hex = dao_wallet_dict_0["treasury_id"]
+        cat_wallet_0 = wallet_node_0.wallet_state_manager.wallets[dao_wallet_dict_0["cat_wallet_id"]]
+
+        for i in range(1, num_blocks):
+            await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+            await asyncio.sleep(0.5)  # add sleep after block per client testing in other wallets
+
+        await time_out_assert(20, cat_wallet_0.get_confirmed_balance, amount_of_cats)
+
+        # join dao
+        dao_wallet_dict_1 = await client_1.create_new_dao_wallet(
+            mode="existing", treasury_id=treasury_id_hex, filter_amount=filter_amount, name="DAO WALLET 1"
+        )
+        assert dao_wallet_dict_1["success"]
+        dao_id_1 = dao_wallet_dict_1["wallet_id"]
+        cat_wallet_1 = wallet_node_1.wallet_state_manager.wallets[dao_wallet_dict_1["cat_wallet_id"]]
+
+        # fund treasury
+        xch_funds = 10000000000
+        funding_tx = await client_0.dao_add_funds_to_treasury(dao_id_0, 1, xch_funds)
+        assert funding_tx["success"]
+        for i in range(1, num_blocks):
+            await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+            await asyncio.sleep(0.5)
+
+        await rpc_state(20, client_0.dao_get_treasury_balance, [dao_id_0], lambda x: x["balances"]["null"], xch_funds)
+
+        # send cats to wallet 1
+        await client_0.cat_spend(
+            wallet_id=dao_wallet_dict_0["cat_wallet_id"],
+            amount=cat_amt,
+            inner_address=encode_puzzle_hash(ph_1, "xch"),
+            fee=fee,
+        )
+
+        for i in range(1, num_blocks):
+            await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+            await asyncio.sleep(0.5)
+
+        await time_out_assert(20, cat_wallet_0.get_confirmed_balance, cat_amt)
+        await time_out_assert(20, cat_wallet_1.get_confirmed_balance, cat_amt)
+
+        # send cats to lockup
+        lockup_0 = await client_0.dao_send_to_lockup(dao_id_0, cat_amt)
+        lockup_1 = await client_1.dao_send_to_lockup(dao_id_1, cat_amt)
+        assert lockup_0["success"]
+        assert lockup_1["success"]
+
+        for i in range(1, num_blocks):
+            await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+            await asyncio.sleep(0.5)
+
+        # create a spend proposal
+        # TODO: Fix handling of comples spends
+        additions = [
+            {"puzzle_hash": ph_1.hex(), "amount": 1000},
+        ]
+        proposal = await client_0.dao_create_proposal(
+            wallet_id=dao_id_0,
+            proposal_type="spend",
+            additions=additions,
+            vote_amount=cat_amt,
+            # inner_address=encode_puzzle_hash(ph_1, "xch"),
+            fee=fee,
+        )
+        assert proposal["success"]
+        for i in range(1, num_blocks):
+            await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+            await asyncio.sleep(0.5)
+
+        # check proposal is found by wallet 1
+        await rpc_state(20, client_1.dao_get_proposals, [dao_id_1], lambda x: x["proposals"][0]["yes_votes"], cat_amt)
+        props = await client_1.dao_get_proposals(dao_id_1)
+        proposal_id_hex = props["proposals"][0]["proposal_id"]
+
+        # vote spend
+        vote = await client_1.dao_vote_on_proposal(
+            wallet_id=dao_id_1, proposal_id=proposal_id_hex, vote_amount=cat_amt, is_yes_vote=True, fee=fee
+        )
+        assert vote["success"]
+        for i in range(1, num_blocks):
+            await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+            await asyncio.sleep(0.5)
+
+        # check updated proposal is found by wallet 0
+        await rpc_state(
+            20, client_0.dao_get_proposals, [dao_id_0], lambda x: x["proposals"][0]["yes_votes"], cat_amt * 2
+        )
+
+        # check proposal state and farm enough blocks to pass
+        state = await client_0.dao_get_proposal_state(wallet_id=dao_id_0, proposal_id=proposal_id_hex)
+        assert state["success"]
+        assert state["state"]["passed"]
+
+        for _ in range(0, state["state"]["blocks_needed"]):
+            await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+            await asyncio.sleep(0.5)
+
+        state = await client_0.dao_get_proposal_state(wallet_id=dao_id_0, proposal_id=proposal_id_hex)
+        assert state["success"]
+        assert state["state"]["closable"]
+
+        # close the proposal
+        close = await client_0.dao_close_proposal(wallet_id=dao_id_0, proposal_id=proposal_id_hex, fee=fee)
+        assert close["success"]
+
+        for i in range(1, num_blocks):
+            await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+            await asyncio.sleep(0.5)
+
+        # check proposal is closed
+        await rpc_state(20, client_1.dao_get_proposals, [dao_id_1], lambda x: x["proposals"][0]["closed"], True)
+        await rpc_state(20, client_0.dao_get_proposals, [dao_id_0], lambda x: x["proposals"][0]["closed"], True)
+
+        # free locked cats from finished proposal
+        res = await client_0.dao_free_coins_from_finished_proposals(wallet_id=dao_id_0)
+        assert res["success"]
+        sb_name = bytes32.from_hexstr(res["spend_name"])
+        await time_out_assert_not_none(5, full_node_api.full_node.mempool_manager.get_spendbundle, sb_name)
+
+        for i in range(1, num_blocks):
+            await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+            await asyncio.sleep(0.5)
+
+        bal = await client_0.get_wallet_balance(dao_wallet_dict_0["dao_cat_wallet_id"])
+        assert bal["confirmed_wallet_balance"] == cat_amt
+
+        exit = await client_0.dao_exit_lockup(dao_id_0)
+        assert exit["success"]
+        for i in range(1, num_blocks):
+            await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+            await asyncio.sleep(0.5)
+
+    finally:
+        client_0.close()
+        client_1.close()
+        await client_0.await_closed()
+        await client_1.await_closed()
+
+
+@pytest.mark.parametrize(
+    "trusted",
+    [True, False],
+)
+@pytest.mark.asyncio
+async def test_dao_cat_exits(
+    two_wallet_nodes_services: SimulatorsAndWalletsServices, trusted: bool, self_hostname: str
+) -> None:
+    num_blocks = 3
+    [full_node_service], wallet_services, bt = two_wallet_nodes_services
+    full_node_api = full_node_service._api
+    full_node_server = full_node_api.full_node.server
+    wallet_node_0 = wallet_services[0]._node
+    server_0 = wallet_node_0.server
+    wallet_node_1 = wallet_services[1]._node
+    server_1 = wallet_node_1.server
+    wallet_0 = wallet_node_0.wallet_state_manager.main_wallet
+    wallet_1 = wallet_node_1.wallet_state_manager.main_wallet
+    ph_0 = await wallet_0.get_new_puzzlehash()
+    ph_1 = await wallet_1.get_new_puzzlehash()
+
+    if trusted:
+        wallet_node_0.config["trusted_peers"] = {full_node_server.node_id.hex(): full_node_server.node_id.hex()}
+        wallet_node_1.config["trusted_peers"] = {full_node_server.node_id.hex(): full_node_server.node_id.hex()}
+    else:
+        wallet_node_0.config["trusted_peers"] = {}
+        wallet_node_1.config["trusted_peers"] = {}
+
+    await server_0.start_client(PeerInfo(self_hostname, uint16(full_node_server._port)), None)
+    await server_1.start_client(PeerInfo(self_hostname, uint16(full_node_server._port)), None)
+
+    for i in range(1, num_blocks):
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(ph_0))
+        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(ph_1))
+    await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+
+    initial_funds = sum(
+        [calculate_pool_reward(uint32(i)) + calculate_base_farmer_reward(uint32(i)) for i in range(1, num_blocks)]
+    )
+
+    await time_out_assert(15, wallet_0.get_confirmed_balance, initial_funds)
+    await time_out_assert(15, wallet_0.get_unconfirmed_balance, initial_funds)
+
+    assert wallet_services[0].rpc_server is not None
+    assert wallet_services[1].rpc_server is not None
+
+    client_0 = await WalletRpcClient.create(
+        self_hostname,
+        wallet_services[0].rpc_server.listen_port,
+        wallet_services[0].root_path,
+        wallet_services[0].config,
+    )
+    await validate_get_routes(client_0, wallet_services[0].rpc_server.rpc_api)
+    client_1 = await WalletRpcClient.create(
+        self_hostname,
+        wallet_services[1].rpc_server.listen_port,
+        wallet_services[1].root_path,
+        wallet_services[1].config,
+    )
+    await validate_get_routes(client_1, wallet_services[1].rpc_server.rpc_api)
+
+    try:
+        cat_amt = 150000
+        amount_of_cats = cat_amt
+        dao_rules = DAORules(
+            proposal_timelock=uint64(8),
+            soft_close_length=uint64(4),
+            attendance_required=uint64(1000),  # 10%
+            pass_percentage=uint64(5100),  # 51%
+            self_destruct_length=uint64(20),
+            oracle_spend_delay=uint64(10),
+            proposal_minimum_amount=uint64(1),
+        )
+        filter_amount = 1
+        fee = 10000
+
+        # create new dao
+        dao_wallet_dict_0 = await client_0.create_new_dao_wallet(
+            mode="new",
+            dao_rules=dao_rules.to_json_dict(),
+            amount_of_cats=amount_of_cats,
+            filter_amount=filter_amount,
+            name="DAO WALLET 0",
+        )
+        assert dao_wallet_dict_0["success"]
+        dao_id_0 = dao_wallet_dict_0["wallet_id"]
+        # treasury_id_hex = dao_wallet_dict_0["treasury_id"]
+        cat_wallet_0 = wallet_node_0.wallet_state_manager.wallets[dao_wallet_dict_0["cat_wallet_id"]]
+        dao_cat_wallet_0 = wallet_node_0.wallet_state_manager.wallets[dao_wallet_dict_0["dao_cat_wallet_id"]]
+
+        for i in range(1, num_blocks):
+            await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+            await asyncio.sleep(0.5)  # add sleep after block per client testing in other wallets
+
+        await time_out_assert(20, cat_wallet_0.get_confirmed_balance, amount_of_cats)
+
+        # fund treasury
+        xch_funds = 10000000000
+        funding_tx = await client_0.dao_add_funds_to_treasury(dao_id_0, 1, xch_funds)
+        assert funding_tx["success"]
+        for i in range(1, num_blocks):
+            await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+            await asyncio.sleep(0.5)
+
+        await rpc_state(20, client_0.dao_get_treasury_balance, [dao_id_0], lambda x: x["balances"]["null"], xch_funds)
+
+        # send cats to lockup
+        lockup_0 = await client_0.dao_send_to_lockup(dao_id_0, cat_amt)
+        # lockup_1 = await client_1.dao_send_to_lockup(dao_id_1, cat_amt)
+        assert lockup_0["success"]
+        # assert lockup_1["success"]
+
+        for i in range(1, num_blocks):
+            await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+            await asyncio.sleep(0.5)
+
+        # create a spend proposal
+        # TODO: Fix handling of comples spends
+        additions = [
+            {"puzzle_hash": ph_1.hex(), "amount": 1000},
+        ]
+        proposal = await client_0.dao_create_proposal(
+            wallet_id=dao_id_0,
+            proposal_type="spend",
+            additions=additions,
+            vote_amount=cat_amt,
+            # inner_address=encode_puzzle_hash(ph_1, "xch"),
+            fee=fee,
+        )
+        assert proposal["success"]
+        for i in range(1, num_blocks):
+            await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+            await asyncio.sleep(0.5)
+
+        props = await client_0.dao_get_proposals(dao_id_0)
+        proposal_id_hex = props["proposals"][0]["proposal_id"]
+
+        # check proposal state and farm enough blocks to pass
+        state = await client_0.dao_get_proposal_state(wallet_id=dao_id_0, proposal_id=proposal_id_hex)
+        assert state["success"]
+        assert state["state"]["passed"]
+
+        for _ in range(0, state["state"]["blocks_needed"]):
+            await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+            await asyncio.sleep(0.5)
+
+        state = await client_0.dao_get_proposal_state(wallet_id=dao_id_0, proposal_id=proposal_id_hex)
+        assert state["success"]
+        assert state["state"]["closable"]
+
+        # close the proposal
+        close = await client_0.dao_close_proposal(wallet_id=dao_id_0, proposal_id=proposal_id_hex, fee=fee)
+        assert close["success"]
+
+        for i in range(1, num_blocks):
+            await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+            await asyncio.sleep(0.5)
+
+        # check proposal is closed
+        await rpc_state(20, client_0.dao_get_proposals, [dao_id_0], lambda x: x["proposals"][0]["closed"], True)
+
+        # free locked cats from finished proposal
+        res = await client_0.dao_free_coins_from_finished_proposals(wallet_id=dao_id_0)
+        assert res["success"]
+        sb_name = bytes32.from_hexstr(res["spend_name"])
+        await time_out_assert_not_none(5, full_node_api.full_node.mempool_manager.get_spendbundle, sb_name)
+
+        for i in range(1, num_blocks):
+            await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+            await asyncio.sleep(0.5)
+
+        assert dao_cat_wallet_0.dao_cat_info.locked_coins[0].active_votes == []
+
+        exit = await client_0.dao_exit_lockup(dao_id_0)
+        assert exit["success"]
+        for i in range(1, num_blocks):
+            await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(puzzle_hash_0))
+            await asyncio.sleep(0.5)
+
+        time_out_assert(20, dao_cat_wallet_0.get_confirmed_balance, 0)
+        time_out_assert(20, cat_wallet_0.get_confirmed_balance, cat_amt)
+
+    finally:
+        client_0.close()
+        client_1.close()
+        await client_0.await_closed()
+        await client_1.await_closed()
diff --git a/tests/wallet/nft_wallet/test_nft_1_offers.py b/tests/wallet/nft_wallet/test_nft_1_offers.py
index 2bd69259d..29910d004 100644
--- a/tests/wallet/nft_wallet/test_nft_1_offers.py
+++ b/tests/wallet/nft_wallet/test_nft_1_offers.py
@@ -727,7 +727,7 @@ async def test_nft_offer_sell_nft_for_cat(
 
     ph_taker_cat_1 = await wallet_taker.get_new_puzzlehash()
     ph_taker_cat_2 = await wallet_taker.get_new_puzzlehash()
-    cat_tx_records = await cat_wallet_maker.generate_signed_transaction(
+    cat_tx_records = await cat_wallet_maker.generate_signed_transactions(
         [cats_to_trade, cats_to_trade], [ph_taker_cat_1, ph_taker_cat_2], memos=[[ph_taker_cat_1], [ph_taker_cat_2]]
     )
     for tx_record in cat_tx_records:
@@ -943,7 +943,7 @@ async def test_nft_offer_request_nft_for_cat(
         extra_change = cats_to_mint - (2 * cats_to_trade)
         amounts.append(uint64(extra_change))
         puzzle_hashes.append(ph_taker_cat_1)
-    cat_tx_records = await cat_wallet_maker.generate_signed_transaction(amounts, puzzle_hashes)
+    cat_tx_records = await cat_wallet_maker.generate_signed_transactions(amounts, puzzle_hashes)
     for tx_record in cat_tx_records:
         await wallet_maker.wallet_state_manager.add_pending_transaction(tx_record)
     await full_node_api.process_transaction_records(records=cat_tx_records)
diff --git a/tests/wallet/test_singleton_store.py b/tests/wallet/test_singleton_store.py
new file mode 100644
index 000000000..867173618
--- /dev/null
+++ b/tests/wallet/test_singleton_store.py
@@ -0,0 +1,85 @@
+from __future__ import annotations
+
+# import dataclasses
+from secrets import token_bytes
+
+import pytest
+
+from chia.types.blockchain_format.coin import Coin
+from chia.types.blockchain_format.program import Program
+from chia.types.blockchain_format.sized_bytes import bytes32
+from chia.types.coin_spend import CoinSpend
+from chia.util.ints import uint32, uint64
+
+# from chia.wallet.dao_wallet.dao_wallet import DAOInfo, DAOWallet
+from chia.wallet.lineage_proof import LineageProof
+from chia.wallet.singleton import create_singleton_puzzle
+from chia.wallet.singleton_record import SingletonRecord
+from chia.wallet.wallet_singleton_store import WalletSingletonStore
+from tests.util.db_connection import DBConnection
+
+
+def get_record() -> SingletonRecord:
+    launcher_id = bytes32(token_bytes(32))
+    inner_puz = Program.to(1)
+    inner_puz_hash = inner_puz.get_tree_hash()
+    parent_puz = create_singleton_puzzle(inner_puz, launcher_id)
+    parent_puz_hash = parent_puz.get_tree_hash()
+    parent_coin = Coin(launcher_id, parent_puz_hash, 1)
+    inner_sol = Program.to([[51, parent_puz_hash, 1]])
+    lineage_proof = LineageProof(launcher_id, inner_puz.get_tree_hash(), uint64(1))
+    parent_sol = Program.to([lineage_proof.to_program(), 1, inner_sol])
+    parent_coinspend = CoinSpend(parent_coin, parent_puz, parent_sol)
+    # child_coin = Coin(parent_coin.name(), parent_puz_hash, 1)
+    wallet_id = uint32(2)
+    pending = True
+    removed_height = 0
+    custom_data = "{'key': 'value'}"
+    record = SingletonRecord(
+        coin=parent_coin,
+        singleton_id=launcher_id,
+        wallet_id=wallet_id,
+        parent_coinspend=parent_coinspend,
+        inner_puzzle_hash=inner_puz_hash,
+        pending=pending,
+        removed_height=removed_height,
+        lineage_proof=lineage_proof,
+        custom_data=custom_data,
+    )
+    return record
+
+
+class TestSingletonStore:
+    @pytest.mark.asyncio
+    async def test_singleton_insert(self) -> None:
+        async with DBConnection(1) as wrapper:
+            db = await WalletSingletonStore.create(wrapper)
+            record = get_record()
+            await db.save_singleton(record)
+            records_by_wallet = await db.get_records_by_wallet_id(record.wallet_id)
+            assert records_by_wallet[0] == record
+            record_by_coin_id = await db.get_records_by_coin_id(record.coin.name())
+            assert record_by_coin_id[0] == record
+            records_by_singleton_id = await db.get_records_by_singleton_id(record.singleton_id)
+            assert records_by_singleton_id[0] == record
+            # modify pending
+            await db.update_pending_transaction(record.coin.name(), False)
+            record_to_check = await db.get_records_by_coin_id(record.coin.name())
+            assert record_to_check[0].pending is False
+
+    @pytest.mark.asyncio
+    async def test_singleton_remove(self) -> None:
+        async with DBConnection(1) as wrapper:
+            db = await WalletSingletonStore.create(wrapper)
+            record_1 = get_record()
+            record_2 = get_record()
+            await db.save_singleton(record_1)
+            await db.save_singleton(record_2)
+            resp_1 = await db.delete_singleton_by_coin_id(record_1.coin.name(), uint32(1))
+            assert resp_1
+            resp_2 = await db.delete_singleton_by_singleton_id(record_2.singleton_id, uint32(1))
+            assert resp_2
+            record = (await db.get_records_by_coin_id(record_1.coin.name()))[0]
+            assert record.removed_height == 1
+            record = (await db.get_records_by_coin_id(record_2.coin.name()))[0]
+            assert record.removed_height == 1
diff --git a/tests/wallet/test_wallet.py b/tests/wallet/test_wallet.py
index 8f236add4..efc0c939b 100644
--- a/tests/wallet/test_wallet.py
+++ b/tests/wallet/test_wallet.py
@@ -345,10 +345,7 @@ class TestWalletSimulator:
         assert await wallet.get_confirmed_balance() == 3999999999500
         # clawback merkle coin
         merkle_coin = tx.additions[0] if tx.additions[0].amount == 500 else tx.additions[1]
-        interested_coins = await wallet_node_2.wallet_state_manager.interested_store.get_interested_coin_ids()
-        assert merkle_coin.name() in set(interested_coins)
         assert len(txs["transactions"]) == 1
-        assert not txs["transactions"][0]["confirmed"]
         assert txs["transactions"][0]["metadata"]["recipient_puzzle_hash"][2:] == normal_puzhash.hex()
         assert txs["transactions"][0]["metadata"]["coin_id"] == merkle_coin.name().hex()
         has_exception = False
@@ -405,8 +402,6 @@ class TestWalletSimulator:
         )
         assert len(txs["transactions"]) == 1
         assert txs["transactions"][0]["confirmed"]
-        interested_coins = await wallet_node_2.wallet_state_manager.interested_store.get_interested_coin_ids()
-        assert merkle_coin.name() not in set(interested_coins)
 
     @pytest.mark.parametrize(
         "trusted",
diff --git a/tests/wallet/test_wallet_interested_store.py b/tests/wallet/test_wallet_interested_store.py
index 43c7e50ec..c561f452b 100644
--- a/tests/wallet/test_wallet_interested_store.py
+++ b/tests/wallet/test_wallet_interested_store.py
@@ -24,8 +24,6 @@ class TestWalletInterestedStore:
             assert (await store.get_interested_coin_ids()) == [coin_1.name()]
             await store.add_interested_coin_id(coin_2.name())
             assert set(await store.get_interested_coin_ids()) == {coin_1.name(), coin_2.name()}
-            await store.remove_interested_coin_id(coin_1.name())
-            assert set(await store.get_interested_coin_ids()) == {coin_2.name()}
             puzzle_hash = token_bytes(32)
             assert len(await store.get_interested_puzzle_hashes()) == 0
 
diff --git a/tools/manage_clvm.py b/tools/manage_clvm.py
index a9d5a6c91..1ebdb21ab 100644
--- a/tools/manage_clvm.py
+++ b/tools/manage_clvm.py
@@ -153,6 +153,9 @@ class ClvmBytes:
             hash=generate_hash_bytes(hex_bytes=hex_bytes),
         )
 
+    def strip(self) -> ClvmBytes:
+        return ClvmBytes(hex=self.hex.strip(b"\n"), hash=self.hash.strip(b"\n"))
+
 
 # These files have the wrong extension for now so we'll just manually exclude them
 excludes: typing.Set[str] = set()
@@ -297,7 +300,7 @@ def check(use_cache: bool) -> int:
 
                     generated_bytes = ClvmBytes.from_hex_bytes(hex_bytes=generated_paths.hex.read_bytes())
 
-                if generated_bytes != reference_bytes:
+                if generated_bytes.strip() != reference_bytes.strip():
                     file_fail = True
                     error = f"        reference: {reference_bytes!r}\n"
                     error += f"        generated: {generated_bytes!r}"
diff --git a/update-chia.sh b/update-chia.sh
new file mode 100644
index 000000000..cdecc8732
--- /dev/null
+++ b/update-chia.sh
@@ -0,0 +1,8 @@
+#!/bin/bash
+
+pip install --upgrade pip
+rm -rf venv
+python3 -m venv venv
+# shellcheck disable=SC1091
+. ./venv/bin/activate
+pip install -e .\[dev\]
